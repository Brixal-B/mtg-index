"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_src_lib_utils_allPrintingsStorage_ts";
exports.ids = ["_ssr_src_lib_utils_allPrintingsStorage_ts"];
exports.modules = {

/***/ "(ssr)/./src/lib/utils/allPrintingsStorage.ts":
/*!**********************************************!*\
  !*** ./src/lib/utils/allPrintingsStorage.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allPrintingsStorage: () => (/* binding */ allPrintingsStorage)\n/* harmony export */ });\n/**\r\n * Optimized storage solution for MTGJSON AllPrintings.json data\r\n * Handles the large (~200MB) dataset efficiently using IndexedDB with compression\r\n */ class AllPrintingsStorage {\n    /**\r\n   * Store AllPrintings data in compressed chunks\r\n   */ async storeAllPrintings(allPrintingsData) {\n        console.log('Starting AllPrintings storage process...');\n        try {\n            const metadata = {\n                version: allPrintingsData.meta.version,\n                date: allPrintingsData.meta.date,\n                totalSets: 0,\n                totalCards: 0,\n                chunks: [],\n                lastUpdated: new Date().toISOString()\n            };\n            const chunks = [];\n            // Process each set\n            for (const [setCode, setData] of Object.entries(allPrintingsData.data)){\n                const cards = setData.cards || [];\n                metadata.totalSets++;\n                metadata.totalCards += cards.length;\n                // Split large sets into chunks\n                for(let i = 0; i < cards.length; i += this.CHUNK_SIZE){\n                    const chunkCards = cards.slice(i, i + this.CHUNK_SIZE);\n                    const chunkId = `${setCode}-${Math.floor(i / this.CHUNK_SIZE)}`;\n                    // Extract only necessary data for mapping\n                    const optimizedCards = chunkCards.map((card)=>({\n                            uuid: card.uuid,\n                            name: card.name,\n                            setCode: card.setCode || setCode,\n                            number: card.number,\n                            rarity: card.rarity,\n                            identifiers: card.identifiers ? {\n                                scryfallId: card.identifiers.scryfallId,\n                                multiverseId: card.identifiers.multiverseId\n                            } : undefined\n                        }));\n                    // Compress the data\n                    const compressed = await this.compressData(optimizedCards);\n                    const chunk = {\n                        id: chunkId,\n                        setCode,\n                        compressedData: compressed,\n                        uncompressedSize: JSON.stringify(optimizedCards).length,\n                        cardCount: optimizedCards.length,\n                        lastUpdated: new Date().toISOString()\n                    };\n                    chunks.push(chunk);\n                    metadata.chunks.push(chunkId);\n                }\n            }\n            // Store chunks in batches to avoid overwhelming IndexedDB\n            console.log(`Storing ${chunks.length} chunks...`);\n            await this.storeChunksInBatches(chunks);\n            // Store metadata\n            await this.storeMetadata(metadata);\n            console.log(`Successfully stored AllPrintings data: ${metadata.totalCards} cards in ${metadata.totalSets} sets`);\n        } catch (error) {\n            console.error('Failed to store AllPrintings data:', error);\n            // Clean up any partially stored data on failure\n            try {\n                await this.clearAllData();\n                console.log('Cleaned up partially stored data due to error');\n            } catch (cleanupError) {\n                console.error('Failed to cleanup after storage error:', cleanupError);\n            }\n            throw error;\n        }\n    }\n    /**\r\n   * Retrieve specific set data\r\n   */ async getSetData(setCode) {\n        try {\n            const metadata = await this.getMetadata();\n            if (!metadata) {\n                throw new Error('AllPrintings metadata not found');\n            }\n            const setChunks = metadata.chunks.filter((chunkId)=>chunkId.startsWith(setCode));\n            const cards = [];\n            for (const chunkId of setChunks){\n                const chunk = await this.getChunk(chunkId);\n                if (chunk) {\n                    const decompressed = await this.decompressData(chunk.compressedData);\n                    cards.push(...decompressed);\n                }\n            }\n            return cards;\n        } catch (error) {\n            console.error(`Failed to get set data for ${setCode}:`, error);\n            return [];\n        }\n    }\n    /**\r\n   * Search for cards across all sets\r\n   */ async searchCards(searchTerm, maxResults = 50) {\n        try {\n            const metadata = await this.getMetadata();\n            if (!metadata) return [];\n            const results = [];\n            const normalizedSearch = searchTerm.toLowerCase();\n            // Search through chunks until we have enough results\n            for (const chunkId of metadata.chunks){\n                if (results.length >= maxResults) break;\n                const chunk = await this.getChunk(chunkId);\n                if (!chunk) continue;\n                const cards = await this.decompressData(chunk.compressedData);\n                for (const card of cards){\n                    if (results.length >= maxResults) break;\n                    if (card.name.toLowerCase().includes(normalizedSearch)) {\n                        results.push(card);\n                    }\n                }\n            }\n            return results;\n        } catch (error) {\n            console.error('Failed to search cards:', error);\n            return [];\n        }\n    }\n    /**\r\n   * Find card by Scryfall ID\r\n   */ async findCardByScryfallId(scryfallId) {\n        try {\n            const metadata = await this.getMetadata();\n            if (!metadata) return null;\n            // Search through all chunks\n            for (const chunkId of metadata.chunks){\n                const chunk = await this.getChunk(chunkId);\n                if (!chunk) continue;\n                const cards = await this.decompressData(chunk.compressedData);\n                for (const card of cards){\n                    if (card.identifiers?.scryfallId === scryfallId) {\n                        return card;\n                    }\n                }\n            }\n            return null;\n        } catch (error) {\n            console.error('Failed to find card by Scryfall ID:', error);\n            return null;\n        }\n    }\n    /**\r\n   * Get storage statistics\r\n   */ async getStorageStats() {\n        try {\n            const metadata = await this.getMetadata();\n            if (!metadata) return null;\n            return {\n                totalSets: metadata.totalSets,\n                totalCards: metadata.totalCards,\n                totalChunks: metadata.chunks.length,\n                lastUpdated: metadata.lastUpdated,\n                version: metadata.version\n            };\n        } catch (error) {\n            console.error('Failed to get storage stats:', error);\n            return null;\n        }\n    }\n    /**\r\n   * Clear all stored data\r\n   */ async clearAllData() {\n        try {\n            // Clear IndexedDB data\n            const metadata = await this.getMetadata();\n            if (metadata) {\n                // Remove all chunks\n                for (const chunkId of metadata.chunks){\n                    await this.removeChunk(chunkId);\n                }\n            }\n            // Remove metadata\n            await this.removeMetadata();\n            // Also clear any old localStorage data from previous versions\n            this.clearLegacyLocalStorageData();\n            console.log('All AllPrintings data cleared');\n        } catch (error) {\n            console.error('Failed to clear AllPrintings data:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Clear legacy localStorage data from previous versions\r\n   */ clearLegacyLocalStorageData() {\n        try {\n            // Clear old metadata\n            localStorage.removeItem('allprintings-metadata');\n            // Clear old chunks (scan for chunk- prefixed keys)\n            const keysToRemove = [];\n            for(let i = 0; i < localStorage.length; i++){\n                const key = localStorage.key(i);\n                if (key && key.startsWith('chunk-')) {\n                    keysToRemove.push(key);\n                }\n            }\n            keysToRemove.forEach((key)=>{\n                localStorage.removeItem(key);\n            });\n            if (keysToRemove.length > 0) {\n                console.log(`Cleared ${keysToRemove.length} legacy localStorage chunks`);\n            }\n        } catch (error) {\n            console.error('Failed to clear legacy localStorage data:', error);\n        }\n    }\n    /**\r\n   * Check if data exists and is fresh\r\n   */ async isDataAvailable() {\n        try {\n            const metadata = await this.getMetadata();\n            if (!metadata) return false;\n            // Check if data is less than 7 days old\n            const dataAge = Date.now() - new Date(metadata.lastUpdated).getTime();\n            const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days\n            return dataAge < maxAge;\n        } catch (error) {\n            console.error('Failed to check data availability:', error);\n            return false;\n        }\n    }\n    // Private helper methods\n    async compressData(data) {\n        try {\n            // Simple compression using JSON stringify with reduced precision\n            const jsonString = JSON.stringify(data);\n            // Basic compression by removing unnecessary whitespace and using shorter keys\n            const compressed = jsonString.replace(/\\s+/g, '').replace(/\"uuid\":/g, '\"u\":').replace(/\"name\":/g, '\"n\":').replace(/\"setCode\":/g, '\"s\":').replace(/\"number\":/g, '\"#\":').replace(/\"rarity\":/g, '\"r\":').replace(/\"identifiers\":/g, '\"i\":').replace(/\"scryfallId\":/g, '\"si\":').replace(/\"multiverseId\":/g, '\"mi\":');\n            // Try different encoding approaches\n            try {\n                // Method 1: Use TextEncoder for proper Unicode handling\n                const encoder = new TextEncoder();\n                const uint8Array = encoder.encode(compressed);\n                // Convert to base64 using proper binary handling\n                let binaryString = '';\n                for(let i = 0; i < uint8Array.length; i++){\n                    binaryString += String.fromCharCode(uint8Array[i]);\n                }\n                return btoa(binaryString);\n            } catch (encodingError) {\n                console.warn('TextEncoder method failed, trying fallback:', encodingError);\n                // Method 2: Fallback - escape Unicode characters first\n                const escapedCompressed = compressed.replace(/[\\u0080-\\uFFFF]/g, (match)=>{\n                    return '\\\\u' + ('0000' + match.charCodeAt(0).toString(16)).substr(-4);\n                });\n                return btoa(escapedCompressed);\n            }\n        } catch (error) {\n            console.error('Failed to compress data with all methods:', error);\n            // Method 3: Last resort - store uncompressed but with key shortening\n            const jsonString = JSON.stringify(data);\n            const shortened = jsonString.replace(/\"uuid\":/g, '\"u\":').replace(/\"name\":/g, '\"n\":').replace(/\"setCode\":/g, '\"s\":').replace(/\"number\":/g, '\"#\":').replace(/\"rarity\":/g, '\"r\":');\n            // Mark as uncompressed with a prefix\n            return 'UNCOMPRESSED:' + shortened;\n        }\n    }\n    async decompressData(compressedData) {\n        try {\n            let decoded;\n            // Check if data is uncompressed (fallback method)\n            if (compressedData.startsWith('UNCOMPRESSED:')) {\n                decoded = compressedData.substring('UNCOMPRESSED:'.length);\n            } else {\n                // Try different decoding approaches\n                try {\n                    // Method 1: Use TextDecoder for proper Unicode handling\n                    const binaryString = atob(compressedData);\n                    // Convert binary string back to Uint8Array\n                    const uint8Array = new Uint8Array(binaryString.length);\n                    for(let i = 0; i < binaryString.length; i++){\n                        uint8Array[i] = binaryString.charCodeAt(i);\n                    }\n                    // Use TextDecoder to handle Unicode characters properly\n                    const decoder = new TextDecoder();\n                    decoded = decoder.decode(uint8Array);\n                } catch (decodingError) {\n                    console.warn('TextDecoder method failed, trying fallback:', decodingError);\n                    // Method 2: Fallback - simple atob and unescape Unicode\n                    decoded = atob(compressedData);\n                    // Unescape Unicode characters\n                    decoded = decoded.replace(/\\\\u([0-9a-fA-F]{4})/g, (match, hex)=>{\n                        return String.fromCharCode(parseInt(hex, 16));\n                    });\n                }\n            }\n            // Expand the shortened keys back to original\n            const expanded = decoded.replace(/\"u\":/g, '\"uuid\":').replace(/\"n\":/g, '\"name\":').replace(/\"s\":/g, '\"setCode\":').replace(/\"#\":/g, '\"number\":').replace(/\"r\":/g, '\"rarity\":').replace(/\"i\":/g, '\"identifiers\":').replace(/\"si\":/g, '\"scryfallId\":').replace(/\"mi\":/g, '\"multiverseId\":');\n            return JSON.parse(expanded);\n        } catch (error) {\n            console.error('Failed to decompress data with all methods:', error);\n            throw error;\n        }\n    }\n    async storeChunksInBatches(chunks) {\n        const batchSize = 10;\n        for(let i = 0; i < chunks.length; i += batchSize){\n            const batch = chunks.slice(i, i + batchSize);\n            const batchPromises = batch.map((chunk)=>this.storeChunk(chunk));\n            await Promise.all(batchPromises);\n            // Small delay to avoid overwhelming IndexedDB\n            await new Promise((resolve)=>setTimeout(resolve, 10));\n            // Progress logging\n            if (i % 100 === 0) {\n                console.log(`Stored ${Math.min(i + batchSize, chunks.length)} / ${chunks.length} chunks`);\n            }\n        }\n    }\n    async storeChunk(chunk) {\n        return new Promise(async (resolve, reject)=>{\n            try {\n                const db = await this.openIndexedDB();\n                const transaction = db.transaction([\n                    'chunks'\n                ], 'readwrite');\n                const store = transaction.objectStore('chunks');\n                const request = store.put(chunk, chunk.id);\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(request.error);\n            } catch (error) {\n                console.error(`Failed to store chunk ${chunk.id}:`, error);\n                reject(error);\n            }\n        });\n    }\n    async getChunk(chunkId) {\n        return new Promise(async (resolve, reject)=>{\n            try {\n                const db = await this.openIndexedDB();\n                const transaction = db.transaction([\n                    'chunks'\n                ], 'readonly');\n                const store = transaction.objectStore('chunks');\n                const request = store.get(chunkId);\n                request.onsuccess = ()=>resolve(request.result || null);\n                request.onerror = ()=>reject(request.error);\n            } catch (error) {\n                console.error(`Failed to get chunk ${chunkId}:`, error);\n                resolve(null);\n            }\n        });\n    }\n    async removeChunk(chunkId) {\n        return new Promise(async (resolve, reject)=>{\n            try {\n                const db = await this.openIndexedDB();\n                const transaction = db.transaction([\n                    'chunks'\n                ], 'readwrite');\n                const store = transaction.objectStore('chunks');\n                const request = store.delete(chunkId);\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(request.error);\n            } catch (error) {\n                console.error(`Failed to remove chunk ${chunkId}:`, error);\n                resolve(); // Don't fail the entire operation for cleanup errors\n            }\n        });\n    }\n    async storeMetadata(metadata) {\n        return new Promise(async (resolve, reject)=>{\n            try {\n                const db = await this.openIndexedDB();\n                const transaction = db.transaction([\n                    'metadata'\n                ], 'readwrite');\n                const store = transaction.objectStore('metadata');\n                const request = store.put(metadata, 'allprintings-metadata');\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(request.error);\n            } catch (error) {\n                console.error('Failed to store metadata:', error);\n                reject(error);\n            }\n        });\n    }\n    async getMetadata() {\n        return new Promise(async (resolve, reject)=>{\n            try {\n                const db = await this.openIndexedDB();\n                const transaction = db.transaction([\n                    'metadata'\n                ], 'readonly');\n                const store = transaction.objectStore('metadata');\n                const request = store.get('allprintings-metadata');\n                request.onsuccess = ()=>resolve(request.result || null);\n                request.onerror = ()=>reject(request.error);\n            } catch (error) {\n                console.error('Failed to get metadata:', error);\n                resolve(null);\n            }\n        });\n    }\n    async removeMetadata() {\n        return new Promise(async (resolve, reject)=>{\n            try {\n                const db = await this.openIndexedDB();\n                const transaction = db.transaction([\n                    'metadata'\n                ], 'readwrite');\n                const store = transaction.objectStore('metadata');\n                const request = store.delete('allprintings-metadata');\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(request.error);\n            } catch (error) {\n                console.error('Failed to remove metadata:', error);\n                resolve(); // Don't fail for cleanup errors\n            }\n        });\n    }\n    async openIndexedDB() {\n        if (this.dbPromise) {\n            return this.dbPromise;\n        }\n        this.dbPromise = new Promise((resolve, reject)=>{\n            const request = indexedDB.open('MTGJSONStorage', 1);\n            request.onerror = ()=>{\n                reject(new Error('Failed to open IndexedDB'));\n            };\n            request.onsuccess = ()=>{\n                resolve(request.result);\n            };\n            request.onupgradeneeded = (event)=>{\n                const db = event.target.result;\n                // Create object stores\n                if (!db.objectStoreNames.contains('chunks')) {\n                    db.createObjectStore('chunks');\n                }\n                if (!db.objectStoreNames.contains('metadata')) {\n                    db.createObjectStore('metadata');\n                }\n            };\n        });\n        return this.dbPromise;\n    }\n    constructor(){\n        this.CHUNK_SIZE = 50; // Cards per chunk\n        this.METADATA_KEY = 'allprintings-metadata';\n        this.CHUNK_PREFIX = 'chunk-';\n        // IndexedDB helper methods\n        this.dbPromise = null;\n    }\n}\n// Export singleton instance\nconst allPrintingsStorage = new AllPrintingsStorage();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvbGliL3V0aWxzL2FsbFByaW50aW5nc1N0b3JhZ2UudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Q0FHQyxHQWtDRCxNQUFNQTtJQUtKOztHQUVDLEdBQ0QsTUFBTUMsa0JBQWtCQyxnQkFBcUIsRUFBaUI7UUFDNURDLFFBQVFDLEdBQUcsQ0FBQztRQUVaLElBQUk7WUFDRixNQUFNQyxXQUFpQztnQkFDckNDLFNBQVNKLGlCQUFpQkssSUFBSSxDQUFDRCxPQUFPO2dCQUN0Q0UsTUFBTU4saUJBQWlCSyxJQUFJLENBQUNDLElBQUk7Z0JBQ2hDQyxXQUFXO2dCQUNYQyxZQUFZO2dCQUNaQyxRQUFRLEVBQUU7Z0JBQ1ZDLGFBQWEsSUFBSUMsT0FBT0MsV0FBVztZQUNyQztZQUVBLE1BQU1ILFNBQTRCLEVBQUU7WUFFcEMsbUJBQW1CO1lBQ25CLEtBQUssTUFBTSxDQUFDSSxTQUFTQyxRQUFRLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ2hCLGlCQUFpQmlCLElBQUksRUFBMEI7Z0JBQzdGLE1BQU1DLFFBQVFKLFFBQVFJLEtBQUssSUFBSSxFQUFFO2dCQUNqQ2YsU0FBU0ksU0FBUztnQkFDbEJKLFNBQVNLLFVBQVUsSUFBSVUsTUFBTUMsTUFBTTtnQkFFbkMsK0JBQStCO2dCQUMvQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsTUFBTUMsTUFBTSxFQUFFQyxLQUFLLElBQUksQ0FBQ0MsVUFBVSxDQUFFO29CQUN0RCxNQUFNQyxhQUFhSixNQUFNSyxLQUFLLENBQUNILEdBQUdBLElBQUksSUFBSSxDQUFDQyxVQUFVO29CQUNyRCxNQUFNRyxVQUFVLEdBQUdYLFFBQVEsQ0FBQyxFQUFFWSxLQUFLQyxLQUFLLENBQUNOLElBQUksSUFBSSxDQUFDQyxVQUFVLEdBQUc7b0JBRS9ELDBDQUEwQztvQkFDMUMsTUFBTU0saUJBQWdDTCxXQUFXTSxHQUFHLENBQUMsQ0FBQ0MsT0FBZTs0QkFDbkVDLE1BQU1ELEtBQUtDLElBQUk7NEJBQ2ZDLE1BQU1GLEtB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QWdCLENBQUNDLFFBQVEsQ0FBQyxXQUFXO29CQUMzQ25CLEdBQUdvQixpQkFBaUIsQ0FBQztnQkFDdkI7Z0JBRUEsSUFBSSxDQUFDcEIsR0FBR2tCLGdCQUFnQixDQUFDQyxRQUFRLENBQUMsYUFBYTtvQkFDN0NuQixHQUFHb0IsaUJBQWlCLENBQUM7Z0JBQ3ZCO1lBQ0Y7UUFDRjtRQUVBLE9BQU8sSUFBSSxDQUFDUixTQUFTO0lBQ3ZCOzthQXBpQmlCcEgsYUFBYSxJQUFJLGtCQUFrQjthQUNuQzZILGVBQWU7YUFDZkMsZUFBZTtRQWdnQmhDLDJCQUEyQjthQUNuQlYsWUFBeUM7O0FBa0NuRDtBQUVBLDRCQUE0QjtBQUNyQixNQUFNVyxzQkFBc0IsSUFBSXRKLHNCQUFzQiIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFxtdGctaW5kZXhcXHNyY1xcbGliXFx1dGlsc1xcYWxsUHJpbnRpbmdzU3RvcmFnZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogT3B0aW1pemVkIHN0b3JhZ2Ugc29sdXRpb24gZm9yIE1UR0pTT04gQWxsUHJpbnRpbmdzLmpzb24gZGF0YVxyXG4gKiBIYW5kbGVzIHRoZSBsYXJnZSAofjIwME1CKSBkYXRhc2V0IGVmZmljaWVudGx5IHVzaW5nIEluZGV4ZWREQiB3aXRoIGNvbXByZXNzaW9uXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgbXRnanNvbkNhY2hlIH0gZnJvbSAnLi9tdGdqc29uQ2FjaGUnO1xyXG5cclxuaW50ZXJmYWNlIENvbXByZXNzZWRDaHVuayB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBzZXRDb2RlOiBzdHJpbmc7XHJcbiAgY29tcHJlc3NlZERhdGE6IHN0cmluZztcclxuICB1bmNvbXByZXNzZWRTaXplOiBudW1iZXI7XHJcbiAgY2FyZENvdW50OiBudW1iZXI7XHJcbiAgbGFzdFVwZGF0ZWQ6IHN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIEFsbFByaW50aW5nc01ldGFkYXRhIHtcclxuICB2ZXJzaW9uOiBzdHJpbmc7XHJcbiAgZGF0ZTogc3RyaW5nO1xyXG4gIHRvdGFsU2V0czogbnVtYmVyO1xyXG4gIHRvdGFsQ2FyZHM6IG51bWJlcjtcclxuICBjaHVua3M6IHN0cmluZ1tdO1xyXG4gIGxhc3RVcGRhdGVkOiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBTZXRDYXJkRGF0YSB7XHJcbiAgdXVpZDogc3RyaW5nO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBzZXRDb2RlOiBzdHJpbmc7XHJcbiAgbnVtYmVyOiBzdHJpbmc7XHJcbiAgcmFyaXR5OiBzdHJpbmc7XHJcbiAgaWRlbnRpZmllcnM/OiB7XHJcbiAgICBzY3J5ZmFsbElkPzogc3RyaW5nO1xyXG4gICAgbXVsdGl2ZXJzZUlkPzogbnVtYmVyO1xyXG4gIH07XHJcbn1cclxuXHJcbmNsYXNzIEFsbFByaW50aW5nc1N0b3JhZ2Uge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgQ0hVTktfU0laRSA9IDUwOyAvLyBDYXJkcyBwZXIgY2h1bmtcclxuICBwcml2YXRlIHJlYWRvbmx5IE1FVEFEQVRBX0tFWSA9ICdhbGxwcmludGluZ3MtbWV0YWRhdGEnO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgQ0hVTktfUFJFRklYID0gJ2NodW5rLSc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3JlIEFsbFByaW50aW5ncyBkYXRhIGluIGNvbXByZXNzZWQgY2h1bmtzXHJcbiAgICovXHJcbiAgYXN5bmMgc3RvcmVBbGxQcmludGluZ3MoYWxsUHJpbnRpbmdzRGF0YTogYW55KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgQWxsUHJpbnRpbmdzIHN0b3JhZ2UgcHJvY2Vzcy4uLicpO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBtZXRhZGF0YTogQWxsUHJpbnRpbmdzTWV0YWRhdGEgPSB7XHJcbiAgICAgICAgdmVyc2lvbjogYWxsUHJpbnRpbmdzRGF0YS5tZXRhLnZlcnNpb24sXHJcbiAgICAgICAgZGF0ZTogYWxsUHJpbnRpbmdzRGF0YS5tZXRhLmRhdGUsXHJcbiAgICAgICAgdG90YWxTZXRzOiAwLFxyXG4gICAgICAgIHRvdGFsQ2FyZHM6IDAsXHJcbiAgICAgICAgY2h1bmtzOiBbXSxcclxuICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgY2h1bmtzOiBDb21wcmVzc2VkQ2h1bmtbXSA9IFtdO1xyXG4gICAgICBcclxuICAgICAgLy8gUHJvY2VzcyBlYWNoIHNldFxyXG4gICAgICBmb3IgKGNvbnN0IFtzZXRDb2RlLCBzZXREYXRhXSBvZiBPYmplY3QuZW50cmllcyhhbGxQcmludGluZ3NEYXRhLmRhdGEgYXMgUmVjb3JkPHN0cmluZywgYW55PikpIHtcclxuICAgICAgICBjb25zdCBjYXJkcyA9IHNldERhdGEuY2FyZHMgfHwgW107XHJcbiAgICAgICAgbWV0YWRhdGEudG90YWxTZXRzKys7XHJcbiAgICAgICAgbWV0YWRhdGEudG90YWxDYXJkcyArPSBjYXJkcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFNwbGl0IGxhcmdlIHNldHMgaW50byBjaHVua3NcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhcmRzLmxlbmd0aDsgaSArPSB0aGlzLkNIVU5LX1NJWkUpIHtcclxuICAgICAgICAgIGNvbnN0IGNodW5rQ2FyZHMgPSBjYXJkcy5zbGljZShpLCBpICsgdGhpcy5DSFVOS19TSVpFKTtcclxuICAgICAgICAgIGNvbnN0IGNodW5rSWQgPSBgJHtzZXRDb2RlfS0ke01hdGguZmxvb3IoaSAvIHRoaXMuQ0hVTktfU0laRSl9YDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gRXh0cmFjdCBvbmx5IG5lY2Vzc2FyeSBkYXRhIGZvciBtYXBwaW5nXHJcbiAgICAgICAgICBjb25zdCBvcHRpbWl6ZWRDYXJkczogU2V0Q2FyZERhdGFbXSA9IGNodW5rQ2FyZHMubWFwKChjYXJkOiBhbnkpID0+ICh7XHJcbiAgICAgICAgICAgIHV1aWQ6IGNhcmQudXVpZCxcclxuICAgICAgICAgICAgbmFtZTogY2FyZC5uYW1lLFxyXG4gICAgICAgICAgICBzZXRDb2RlOiBjYXJkLnNldENvZGUgfHwgc2V0Q29kZSxcclxuICAgICAgICAgICAgbnVtYmVyOiBjYXJkLm51bWJlcixcclxuICAgICAgICAgICAgcmFyaXR5OiBjYXJkLnJhcml0eSxcclxuICAgICAgICAgICAgaWRlbnRpZmllcnM6IGNhcmQuaWRlbnRpZmllcnMgPyB7XHJcbiAgICAgICAgICAgICAgc2NyeWZhbGxJZDogY2FyZC5pZGVudGlmaWVycy5zY3J5ZmFsbElkLFxyXG4gICAgICAgICAgICAgIG11bHRpdmVyc2VJZDogY2FyZC5pZGVudGlmaWVycy5tdWx0aXZlcnNlSWQsXHJcbiAgICAgICAgICAgIH0gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgICAgLy8gQ29tcHJlc3MgdGhlIGRhdGFcclxuICAgICAgICAgIGNvbnN0IGNvbXByZXNzZWQgPSBhd2FpdCB0aGlzLmNvbXByZXNzRGF0YShvcHRpbWl6ZWRDYXJkcyk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IGNodW5rOiBDb21wcmVzc2VkQ2h1bmsgPSB7XHJcbiAgICAgICAgICAgIGlkOiBjaHVua0lkLFxyXG4gICAgICAgICAgICBzZXRDb2RlLFxyXG4gICAgICAgICAgICBjb21wcmVzc2VkRGF0YTogY29tcHJlc3NlZCxcclxuICAgICAgICAgICAgdW5jb21wcmVzc2VkU2l6ZTogSlNPTi5zdHJpbmdpZnkob3B0aW1pemVkQ2FyZHMpLmxlbmd0aCxcclxuICAgICAgICAgICAgY2FyZENvdW50OiBvcHRpbWl6ZWRDYXJkcy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcclxuICAgICAgICAgIG1ldGFkYXRhLmNodW5rcy5wdXNoKGNodW5rSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU3RvcmUgY2h1bmtzIGluIGJhdGNoZXMgdG8gYXZvaWQgb3ZlcndoZWxtaW5nIEluZGV4ZWREQlxyXG4gICAgICBjb25zb2xlLmxvZyhgU3RvcmluZyAke2NodW5rcy5sZW5ndGh9IGNodW5rcy4uLmApO1xyXG4gICAgICBhd2FpdCB0aGlzLnN0b3JlQ2h1bmtzSW5CYXRjaGVzKGNodW5rcyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdG9yZSBtZXRhZGF0YVxyXG4gICAgICBhd2FpdCB0aGlzLnN0b3JlTWV0YWRhdGEobWV0YWRhdGEpO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBzdG9yZWQgQWxsUHJpbnRpbmdzIGRhdGE6ICR7bWV0YWRhdGEudG90YWxDYXJkc30gY2FyZHMgaW4gJHttZXRhZGF0YS50b3RhbFNldHN9IHNldHNgKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzdG9yZSBBbGxQcmludGluZ3MgZGF0YTonLCBlcnJvcik7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDbGVhbiB1cCBhbnkgcGFydGlhbGx5IHN0b3JlZCBkYXRhIG9uIGZhaWx1cmVcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCB0aGlzLmNsZWFyQWxsRGF0YSgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdDbGVhbmVkIHVwIHBhcnRpYWxseSBzdG9yZWQgZGF0YSBkdWUgdG8gZXJyb3InKTtcclxuICAgICAgfSBjYXRjaCAoY2xlYW51cEVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNsZWFudXAgYWZ0ZXIgc3RvcmFnZSBlcnJvcjonLCBjbGVhbnVwRXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlIHNwZWNpZmljIHNldCBkYXRhXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0U2V0RGF0YShzZXRDb2RlOiBzdHJpbmcpOiBQcm9taXNlPFNldENhcmREYXRhW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5nZXRNZXRhZGF0YSgpO1xyXG4gICAgICBpZiAoIW1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbGxQcmludGluZ3MgbWV0YWRhdGEgbm90IGZvdW5kJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHNldENodW5rcyA9IG1ldGFkYXRhLmNodW5rcy5maWx0ZXIoY2h1bmtJZCA9PiBjaHVua0lkLnN0YXJ0c1dpdGgoc2V0Q29kZSkpO1xyXG4gICAgICBjb25zdCBjYXJkczogU2V0Q2FyZERhdGFbXSA9IFtdO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjaHVua0lkIG9mIHNldENodW5rcykge1xyXG4gICAgICAgIGNvbnN0IGNodW5rID0gYXdhaXQgdGhpcy5nZXRDaHVuayhjaHVua0lkKTtcclxuICAgICAgICBpZiAoY2h1bmspIHtcclxuICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlZCA9IGF3YWl0IHRoaXMuZGVjb21wcmVzc0RhdGEoY2h1bmsuY29tcHJlc3NlZERhdGEpO1xyXG4gICAgICAgICAgY2FyZHMucHVzaCguLi5kZWNvbXByZXNzZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNhcmRzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGdldCBzZXQgZGF0YSBmb3IgJHtzZXRDb2RlfTpgLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlYXJjaCBmb3IgY2FyZHMgYWNyb3NzIGFsbCBzZXRzXHJcbiAgICovXHJcbiAgYXN5bmMgc2VhcmNoQ2FyZHMoc2VhcmNoVGVybTogc3RyaW5nLCBtYXhSZXN1bHRzID0gNTApOiBQcm9taXNlPFNldENhcmREYXRhW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5nZXRNZXRhZGF0YSgpO1xyXG4gICAgICBpZiAoIW1ldGFkYXRhKSByZXR1cm4gW107XHJcblxyXG4gICAgICBjb25zdCByZXN1bHRzOiBTZXRDYXJkRGF0YVtdID0gW107XHJcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTZWFyY2ggPSBzZWFyY2hUZXJtLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAvLyBTZWFyY2ggdGhyb3VnaCBjaHVua3MgdW50aWwgd2UgaGF2ZSBlbm91Z2ggcmVzdWx0c1xyXG4gICAgICBmb3IgKGNvbnN0IGNodW5rSWQgb2YgbWV0YWRhdGEuY2h1bmtzKSB7XHJcbiAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID49IG1heFJlc3VsdHMpIGJyZWFrO1xyXG5cclxuICAgICAgICBjb25zdCBjaHVuayA9IGF3YWl0IHRoaXMuZ2V0Q2h1bmsoY2h1bmtJZCk7XHJcbiAgICAgICAgaWYgKCFjaHVuaykgY29udGludWU7XHJcblxyXG4gICAgICAgIGNvbnN0IGNhcmRzID0gYXdhaXQgdGhpcy5kZWNvbXByZXNzRGF0YShjaHVuay5jb21wcmVzc2VkRGF0YSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChjb25zdCBjYXJkIG9mIGNhcmRzKSB7XHJcbiAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPj0gbWF4UmVzdWx0cykgYnJlYWs7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChjYXJkLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhub3JtYWxpemVkU2VhcmNoKSkge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY2FyZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzZWFyY2ggY2FyZHM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kIGNhcmQgYnkgU2NyeWZhbGwgSURcclxuICAgKi9cclxuICBhc3luYyBmaW5kQ2FyZEJ5U2NyeWZhbGxJZChzY3J5ZmFsbElkOiBzdHJpbmcpOiBQcm9taXNlPFNldENhcmREYXRhIHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKCk7XHJcbiAgICAgIGlmICghbWV0YWRhdGEpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgLy8gU2VhcmNoIHRocm91Z2ggYWxsIGNodW5rc1xyXG4gICAgICBmb3IgKGNvbnN0IGNodW5rSWQgb2YgbWV0YWRhdGEuY2h1bmtzKSB7XHJcbiAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCB0aGlzLmdldENodW5rKGNodW5rSWQpO1xyXG4gICAgICAgIGlmICghY2h1bmspIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBjb25zdCBjYXJkcyA9IGF3YWl0IHRoaXMuZGVjb21wcmVzc0RhdGEoY2h1bmsuY29tcHJlc3NlZERhdGEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoY29uc3QgY2FyZCBvZiBjYXJkcykge1xyXG4gICAgICAgICAgaWYgKGNhcmQuaWRlbnRpZmllcnM/LnNjcnlmYWxsSWQgPT09IHNjcnlmYWxsSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhcmQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGNhcmQgYnkgU2NyeWZhbGwgSUQ6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBzdG9yYWdlIHN0YXRpc3RpY3NcclxuICAgKi9cclxuICBhc3luYyBnZXRTdG9yYWdlU3RhdHMoKTogUHJvbWlzZTx7XHJcbiAgICB0b3RhbFNldHM6IG51bWJlcjtcclxuICAgIHRvdGFsQ2FyZHM6IG51bWJlcjtcclxuICAgIHRvdGFsQ2h1bmtzOiBudW1iZXI7XHJcbiAgICBsYXN0VXBkYXRlZDogc3RyaW5nO1xyXG4gICAgdmVyc2lvbjogc3RyaW5nO1xyXG4gIH0gfCBudWxsPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEoKTtcclxuICAgICAgaWYgKCFtZXRhZGF0YSkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvdGFsU2V0czogbWV0YWRhdGEudG90YWxTZXRzLFxyXG4gICAgICAgIHRvdGFsQ2FyZHM6IG1ldGFkYXRhLnRvdGFsQ2FyZHMsXHJcbiAgICAgICAgdG90YWxDaHVua3M6IG1ldGFkYXRhLmNodW5rcy5sZW5ndGgsXHJcbiAgICAgICAgbGFzdFVwZGF0ZWQ6IG1ldGFkYXRhLmxhc3RVcGRhdGVkLFxyXG4gICAgICAgIHZlcnNpb246IG1ldGFkYXRhLnZlcnNpb24sXHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IHN0b3JhZ2Ugc3RhdHM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFyIGFsbCBzdG9yZWQgZGF0YVxyXG4gICAqL1xyXG4gIGFzeW5jIGNsZWFyQWxsRGF0YSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIENsZWFyIEluZGV4ZWREQiBkYXRhXHJcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5nZXRNZXRhZGF0YSgpO1xyXG4gICAgICBpZiAobWV0YWRhdGEpIHtcclxuICAgICAgICAvLyBSZW1vdmUgYWxsIGNodW5rc1xyXG4gICAgICAgIGZvciAoY29uc3QgY2h1bmtJZCBvZiBtZXRhZGF0YS5jaHVua3MpIHtcclxuICAgICAgICAgIGF3YWl0IHRoaXMucmVtb3ZlQ2h1bmsoY2h1bmtJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgbWV0YWRhdGFcclxuICAgICAgYXdhaXQgdGhpcy5yZW1vdmVNZXRhZGF0YSgpO1xyXG4gICAgICBcclxuICAgICAgLy8gQWxzbyBjbGVhciBhbnkgb2xkIGxvY2FsU3RvcmFnZSBkYXRhIGZyb20gcHJldmlvdXMgdmVyc2lvbnNcclxuICAgICAgdGhpcy5jbGVhckxlZ2FjeUxvY2FsU3RvcmFnZURhdGEoKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdBbGwgQWxsUHJpbnRpbmdzIGRhdGEgY2xlYXJlZCcpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNsZWFyIEFsbFByaW50aW5ncyBkYXRhOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhciBsZWdhY3kgbG9jYWxTdG9yYWdlIGRhdGEgZnJvbSBwcmV2aW91cyB2ZXJzaW9uc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgY2xlYXJMZWdhY3lMb2NhbFN0b3JhZ2VEYXRhKCk6IHZvaWQge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQ2xlYXIgb2xkIG1ldGFkYXRhXHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhbGxwcmludGluZ3MtbWV0YWRhdGEnKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENsZWFyIG9sZCBjaHVua3MgKHNjYW4gZm9yIGNodW5rLSBwcmVmaXhlZCBrZXlzKVxyXG4gICAgICBjb25zdCBrZXlzVG9SZW1vdmU6IHN0cmluZ1tdID0gW107XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcclxuICAgICAgICBpZiAoa2V5ICYmIGtleS5zdGFydHNXaXRoKCdjaHVuay0nKSkge1xyXG4gICAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGtleXNUb1JlbW92ZS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoa2V5c1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgQ2xlYXJlZCAke2tleXNUb1JlbW92ZS5sZW5ndGh9IGxlZ2FjeSBsb2NhbFN0b3JhZ2UgY2h1bmtzYCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjbGVhciBsZWdhY3kgbG9jYWxTdG9yYWdlIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgZGF0YSBleGlzdHMgYW5kIGlzIGZyZXNoXHJcbiAgICovXHJcbiAgYXN5bmMgaXNEYXRhQXZhaWxhYmxlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKCk7XHJcbiAgICAgIGlmICghbWV0YWRhdGEpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIGRhdGEgaXMgbGVzcyB0aGFuIDcgZGF5cyBvbGRcclxuICAgICAgY29uc3QgZGF0YUFnZSA9IERhdGUubm93KCkgLSBuZXcgRGF0ZShtZXRhZGF0YS5sYXN0VXBkYXRlZCkuZ2V0VGltZSgpO1xyXG4gICAgICBjb25zdCBtYXhBZ2UgPSA3ICogMjQgKiA2MCAqIDYwICogMTAwMDsgLy8gNyBkYXlzXHJcblxyXG4gICAgICByZXR1cm4gZGF0YUFnZSA8IG1heEFnZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjaGVjayBkYXRhIGF2YWlsYWJpbGl0eTonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFByaXZhdGUgaGVscGVyIG1ldGhvZHNcclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBjb21wcmVzc0RhdGEoZGF0YTogU2V0Q2FyZERhdGFbXSk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTaW1wbGUgY29tcHJlc3Npb24gdXNpbmcgSlNPTiBzdHJpbmdpZnkgd2l0aCByZWR1Y2VkIHByZWNpc2lvblxyXG4gICAgICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBCYXNpYyBjb21wcmVzc2lvbiBieSByZW1vdmluZyB1bm5lY2Vzc2FyeSB3aGl0ZXNwYWNlIGFuZCB1c2luZyBzaG9ydGVyIGtleXNcclxuICAgICAgY29uc3QgY29tcHJlc3NlZCA9IGpzb25TdHJpbmdcclxuICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnJylcclxuICAgICAgICAucmVwbGFjZSgvXCJ1dWlkXCI6L2csICdcInVcIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cIm5hbWVcIjovZywgJ1wiblwiOicpXHJcbiAgICAgICAgLnJlcGxhY2UoL1wic2V0Q29kZVwiOi9nLCAnXCJzXCI6JylcclxuICAgICAgICAucmVwbGFjZSgvXCJudW1iZXJcIjovZywgJ1wiI1wiOicpXHJcbiAgICAgICAgLnJlcGxhY2UoL1wicmFyaXR5XCI6L2csICdcInJcIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cImlkZW50aWZpZXJzXCI6L2csICdcImlcIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cInNjcnlmYWxsSWRcIjovZywgJ1wic2lcIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cIm11bHRpdmVyc2VJZFwiOi9nLCAnXCJtaVwiOicpO1xyXG5cclxuICAgICAgLy8gVHJ5IGRpZmZlcmVudCBlbmNvZGluZyBhcHByb2FjaGVzXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gTWV0aG9kIDE6IFVzZSBUZXh0RW5jb2RlciBmb3IgcHJvcGVyIFVuaWNvZGUgaGFuZGxpbmdcclxuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgICAgICAgY29uc3QgdWludDhBcnJheSA9IGVuY29kZXIuZW5jb2RlKGNvbXByZXNzZWQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENvbnZlcnQgdG8gYmFzZTY0IHVzaW5nIHByb3BlciBiaW5hcnkgaGFuZGxpbmdcclxuICAgICAgICBsZXQgYmluYXJ5U3RyaW5nID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1aW50OEFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBiaW5hcnlTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1aW50OEFycmF5W2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGJ0b2EoYmluYXJ5U3RyaW5nKTtcclxuICAgICAgfSBjYXRjaCAoZW5jb2RpbmdFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignVGV4dEVuY29kZXIgbWV0aG9kIGZhaWxlZCwgdHJ5aW5nIGZhbGxiYWNrOicsIGVuY29kaW5nRXJyb3IpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE1ldGhvZCAyOiBGYWxsYmFjayAtIGVzY2FwZSBVbmljb2RlIGNoYXJhY3RlcnMgZmlyc3RcclxuICAgICAgICBjb25zdCBlc2NhcGVkQ29tcHJlc3NlZCA9IGNvbXByZXNzZWQucmVwbGFjZSgvW1xcdTAwODAtXFx1RkZGRl0vZywgKG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArICgnMDAwMCcgKyBtYXRjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gYnRvYShlc2NhcGVkQ29tcHJlc3NlZCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb21wcmVzcyBkYXRhIHdpdGggYWxsIG1ldGhvZHM6JywgZXJyb3IpO1xyXG4gICAgICBcclxuICAgICAgLy8gTWV0aG9kIDM6IExhc3QgcmVzb3J0IC0gc3RvcmUgdW5jb21wcmVzc2VkIGJ1dCB3aXRoIGtleSBzaG9ydGVuaW5nXHJcbiAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuICAgICAgY29uc3Qgc2hvcnRlbmVkID0ganNvblN0cmluZ1xyXG4gICAgICAgIC5yZXBsYWNlKC9cInV1aWRcIjovZywgJ1widVwiOicpXHJcbiAgICAgICAgLnJlcGxhY2UoL1wibmFtZVwiOi9nLCAnXCJuXCI6JylcclxuICAgICAgICAucmVwbGFjZSgvXCJzZXRDb2RlXCI6L2csICdcInNcIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cIm51bWJlclwiOi9nLCAnXCIjXCI6JylcclxuICAgICAgICAucmVwbGFjZSgvXCJyYXJpdHlcIjovZywgJ1wiclwiOicpO1xyXG4gICAgICBcclxuICAgICAgLy8gTWFyayBhcyB1bmNvbXByZXNzZWQgd2l0aCBhIHByZWZpeFxyXG4gICAgICByZXR1cm4gJ1VOQ09NUFJFU1NFRDonICsgc2hvcnRlbmVkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBkZWNvbXByZXNzRGF0YShjb21wcmVzc2VkRGF0YTogc3RyaW5nKTogUHJvbWlzZTxTZXRDYXJkRGF0YVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBsZXQgZGVjb2RlZDogc3RyaW5nO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgZGF0YSBpcyB1bmNvbXByZXNzZWQgKGZhbGxiYWNrIG1ldGhvZClcclxuICAgICAgaWYgKGNvbXByZXNzZWREYXRhLnN0YXJ0c1dpdGgoJ1VOQ09NUFJFU1NFRDonKSkge1xyXG4gICAgICAgIGRlY29kZWQgPSBjb21wcmVzc2VkRGF0YS5zdWJzdHJpbmcoJ1VOQ09NUFJFU1NFRDonLmxlbmd0aCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVHJ5IGRpZmZlcmVudCBkZWNvZGluZyBhcHByb2FjaGVzXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIE1ldGhvZCAxOiBVc2UgVGV4dERlY29kZXIgZm9yIHByb3BlciBVbmljb2RlIGhhbmRsaW5nXHJcbiAgICAgICAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBhdG9iKGNvbXByZXNzZWREYXRhKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQ29udmVydCBiaW5hcnkgc3RyaW5nIGJhY2sgdG8gVWludDhBcnJheVxyXG4gICAgICAgICAgY29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdWludDhBcnJheVtpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBVc2UgVGV4dERlY29kZXIgdG8gaGFuZGxlIFVuaWNvZGUgY2hhcmFjdGVycyBwcm9wZXJseVxyXG4gICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xyXG4gICAgICAgICAgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKHVpbnQ4QXJyYXkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGRlY29kaW5nRXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybignVGV4dERlY29kZXIgbWV0aG9kIGZhaWxlZCwgdHJ5aW5nIGZhbGxiYWNrOicsIGRlY29kaW5nRXJyb3IpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBNZXRob2QgMjogRmFsbGJhY2sgLSBzaW1wbGUgYXRvYiBhbmQgdW5lc2NhcGUgVW5pY29kZVxyXG4gICAgICAgICAgZGVjb2RlZCA9IGF0b2IoY29tcHJlc3NlZERhdGEpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBVbmVzY2FwZSBVbmljb2RlIGNoYXJhY3RlcnNcclxuICAgICAgICAgIGRlY29kZWQgPSBkZWNvZGVkLnJlcGxhY2UoL1xcXFx1KFswLTlhLWZBLUZdezR9KS9nLCAobWF0Y2gsIGhleCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEV4cGFuZCB0aGUgc2hvcnRlbmVkIGtleXMgYmFjayB0byBvcmlnaW5hbFxyXG4gICAgICBjb25zdCBleHBhbmRlZCA9IGRlY29kZWRcclxuICAgICAgICAucmVwbGFjZSgvXCJ1XCI6L2csICdcInV1aWRcIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cIm5cIjovZywgJ1wibmFtZVwiOicpXHJcbiAgICAgICAgLnJlcGxhY2UoL1wic1wiOi9nLCAnXCJzZXRDb2RlXCI6JylcclxuICAgICAgICAucmVwbGFjZSgvXCIjXCI6L2csICdcIm51bWJlclwiOicpXHJcbiAgICAgICAgLnJlcGxhY2UoL1wiclwiOi9nLCAnXCJyYXJpdHlcIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cImlcIjovZywgJ1wiaWRlbnRpZmllcnNcIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cInNpXCI6L2csICdcInNjcnlmYWxsSWRcIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cIm1pXCI6L2csICdcIm11bHRpdmVyc2VJZFwiOicpO1xyXG5cclxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZXhwYW5kZWQpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlY29tcHJlc3MgZGF0YSB3aXRoIGFsbCBtZXRob2RzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHN0b3JlQ2h1bmtzSW5CYXRjaGVzKGNodW5rczogQ29tcHJlc3NlZENodW5rW10pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IDEwO1xyXG4gICAgXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkgKz0gYmF0Y2hTaXplKSB7XHJcbiAgICAgIGNvbnN0IGJhdGNoID0gY2h1bmtzLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgYmF0Y2hQcm9taXNlcyA9IGJhdGNoLm1hcChjaHVuayA9PiB0aGlzLnN0b3JlQ2h1bmsoY2h1bmspKTtcclxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYmF0Y2hQcm9taXNlcyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTbWFsbCBkZWxheSB0byBhdm9pZCBvdmVyd2hlbG1pbmcgSW5kZXhlZERCXHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMCkpO1xyXG4gICAgICBcclxuICAgICAgLy8gUHJvZ3Jlc3MgbG9nZ2luZ1xyXG4gICAgICBpZiAoaSAlIDEwMCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBTdG9yZWQgJHtNYXRoLm1pbihpICsgYmF0Y2hTaXplLCBjaHVua3MubGVuZ3RoKX0gLyAke2NodW5rcy5sZW5ndGh9IGNodW5rc2ApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHN0b3JlQ2h1bmsoY2h1bms6IENvbXByZXNzZWRDaHVuayk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMub3BlbkluZGV4ZWREQigpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oWydjaHVua3MnXSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ2NodW5rcycpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoY2h1bmssIGNodW5rLmlkKTtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHN0b3JlIGNodW5rICR7Y2h1bmsuaWR9OmAsIGVycm9yKTtcclxuICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0Q2h1bmsoY2h1bmtJZDogc3RyaW5nKTogUHJvbWlzZTxDb21wcmVzc2VkQ2h1bmsgfCBudWxsPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5vcGVuSW5kZXhlZERCKCk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbJ2NodW5rcyddLCAncmVhZG9ubHknKTtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdjaHVua3MnKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KGNodW5rSWQpO1xyXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCB8fCBudWxsKTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGdldCBjaHVuayAke2NodW5rSWR9OmAsIGVycm9yKTtcclxuICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcmVtb3ZlQ2h1bmsoY2h1bmtJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5vcGVuSW5kZXhlZERCKCk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbJ2NodW5rcyddLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnY2h1bmtzJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmRlbGV0ZShjaHVua0lkKTtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHJlbW92ZSBjaHVuayAke2NodW5rSWR9OmAsIGVycm9yKTtcclxuICAgICAgICByZXNvbHZlKCk7IC8vIERvbid0IGZhaWwgdGhlIGVudGlyZSBvcGVyYXRpb24gZm9yIGNsZWFudXAgZXJyb3JzXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBzdG9yZU1ldGFkYXRhKG1ldGFkYXRhOiBBbGxQcmludGluZ3NNZXRhZGF0YSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMub3BlbkluZGV4ZWREQigpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oWydtZXRhZGF0YSddLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnbWV0YWRhdGEnKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUucHV0KG1ldGFkYXRhLCAnYWxscHJpbnRpbmdzLW1ldGFkYXRhJyk7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzdG9yZSBtZXRhZGF0YTonLCBlcnJvcik7XHJcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldE1ldGFkYXRhKCk6IFByb21pc2U8QWxsUHJpbnRpbmdzTWV0YWRhdGEgfCBudWxsPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5vcGVuSW5kZXhlZERCKCk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbJ21ldGFkYXRhJ10sICdyZWFkb25seScpO1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ21ldGFkYXRhJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldCgnYWxscHJpbnRpbmdzLW1ldGFkYXRhJyk7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcXVlc3QucmVzdWx0IHx8IG51bGwpO1xyXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IG1ldGFkYXRhOicsIGVycm9yKTtcclxuICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcmVtb3ZlTWV0YWRhdGEoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5vcGVuSW5kZXhlZERCKCk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbJ21ldGFkYXRhJ10sICdyZWFkd3JpdGUnKTtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdtZXRhZGF0YScpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5kZWxldGUoJ2FsbHByaW50aW5ncy1tZXRhZGF0YScpO1xyXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVtb3ZlIG1ldGFkYXRhOicsIGVycm9yKTtcclxuICAgICAgICByZXNvbHZlKCk7IC8vIERvbid0IGZhaWwgZm9yIGNsZWFudXAgZXJyb3JzXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gSW5kZXhlZERCIGhlbHBlciBtZXRob2RzXHJcbiAgcHJpdmF0ZSBkYlByb21pc2U6IFByb21pc2U8SURCRGF0YWJhc2U+IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgb3BlbkluZGV4ZWREQigpOiBQcm9taXNlPElEQkRhdGFiYXNlPiB7XHJcbiAgICBpZiAodGhpcy5kYlByb21pc2UpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGJQcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oJ01UR0pTT05TdG9yYWdlJywgMSk7XHJcblxyXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIG9wZW4gSW5kZXhlZERCJykpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRiID0gKGV2ZW50LnRhcmdldCBhcyBJREJPcGVuREJSZXF1ZXN0KS5yZXN1bHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ3JlYXRlIG9iamVjdCBzdG9yZXNcclxuICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ2NodW5rcycpKSB7XHJcbiAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZSgnY2h1bmtzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnbWV0YWRhdGEnKSkge1xyXG4gICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ21ldGFkYXRhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZGJQcm9taXNlO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxyXG5leHBvcnQgY29uc3QgYWxsUHJpbnRpbmdzU3RvcmFnZSA9IG5ldyBBbGxQcmludGluZ3NTdG9yYWdlKCk7XHJcblxyXG4vLyBFeHBvcnQgdHlwZXNcclxuZXhwb3J0IHR5cGUgeyBTZXRDYXJkRGF0YSwgQWxsUHJpbnRpbmdzTWV0YWRhdGEgfTtcclxuIl0sIm5hbWVzIjpbIkFsbFByaW50aW5nc1N0b3JhZ2UiLCJzdG9yZUFsbFByaW50aW5ncyIsImFsbFByaW50aW5nc0RhdGEiLCJjb25zb2xlIiwibG9nIiwibWV0YWRhdGEiLCJ2ZXJzaW9uIiwibWV0YSIsImRhdGUiLCJ0b3RhbFNldHMiLCJ0b3RhbENhcmRzIiwiY2h1bmtzIiwibGFzdFVwZGF0ZWQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzZXRDb2RlIiwic2V0RGF0YSIsIk9iamVjdCIsImVudHJpZXMiLCJkYXRhIiwiY2FyZHMiLCJsZW5ndGgiLCJpIiwiQ0hVTktfU0laRSIsImNodW5rQ2FyZHMiLCJzbGljZSIsImNodW5rSWQiLCJNYXRoIiwiZmxvb3IiLCJvcHRpbWl6ZWRDYXJkcyIsIm1hcCIsImNhcmQiLCJ1dWlkIiwibmFtZSIsIm51bWJlciIsInJhcml0eSIsImlkZW50aWZpZXJzIiwic2NyeWZhbGxJZCIsIm11bHRpdmVyc2VJZCIsInVuZGVmaW5lZCIsImNvbXByZXNzZWQiLCJjb21wcmVzc0RhdGEiLCJjaHVuayIsImlkIiwiY29tcHJlc3NlZERhdGEiLCJ1bmNvbXByZXNzZWRTaXplIiwiSlNPTiIsInN0cmluZ2lmeSIsImNhcmRDb3VudCIsInB1c2giLCJzdG9yZUNodW5rc0luQmF0Y2hlcyIsInN0b3JlTWV0YWRhdGEiLCJlcnJvciIsImNsZWFyQWxsRGF0YSIsImNsZWFudXBFcnJvciIsImdldFNldERhdGEiLCJnZXRNZXRhZGF0YSIsIkVycm9yIiwic2V0Q2h1bmtzIiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsImdldENodW5rIiwiZGVjb21wcmVzc2VkIiwiZGVjb21wcmVzc0RhdGEiLCJzZWFyY2hDYXJkcyIsInNlYXJjaFRlcm0iLCJtYXhSZXN1bHRzIiwicmVzdWx0cyIsIm5vcm1hbGl6ZWRTZWFyY2giLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwiZmluZENhcmRCeVNjcnlmYWxsSWQiLCJnZXRTdG9yYWdlU3RhdHMiLCJ0b3RhbENodW5rcyIsInJlbW92ZUNodW5rIiwicmVtb3ZlTWV0YWRhdGEiLCJjbGVhckxlZ2FjeUxvY2FsU3RvcmFnZURhdGEiLCJsb2NhbFN0b3JhZ2UiLCJyZW1vdmVJdGVtIiwia2V5c1RvUmVtb3ZlIiwia2V5IiwiZm9yRWFjaCIsImlzRGF0YUF2YWlsYWJsZSIsImRhdGFBZ2UiLCJub3ciLCJnZXRUaW1lIiwibWF4QWdlIiwianNvblN0cmluZyIsInJlcGxhY2UiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJ1aW50OEFycmF5IiwiZW5jb2RlIiwiYmluYXJ5U3RyaW5nIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYnRvYSIsImVuY29kaW5nRXJyb3IiLCJ3YXJuIiwiZXNjYXBlZENvbXByZXNzZWQiLCJtYXRjaCIsImNoYXJDb2RlQXQiLCJ0b1N0cmluZyIsInN1YnN0ciIsInNob3J0ZW5lZCIsImRlY29kZWQiLCJzdWJzdHJpbmciLCJhdG9iIiwiVWludDhBcnJheSIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsImRlY29kaW5nRXJyb3IiLCJoZXgiLCJwYXJzZUludCIsImV4cGFuZGVkIiwicGFyc2UiLCJiYXRjaFNpemUiLCJiYXRjaCIsImJhdGNoUHJvbWlzZXMiLCJzdG9yZUNodW5rIiwiUHJvbWlzZSIsImFsbCIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwibWluIiwicmVqZWN0IiwiZGIiLCJvcGVuSW5kZXhlZERCIiwidHJhbnNhY3Rpb24iLCJzdG9yZSIsIm9iamVjdFN0b3JlIiwicmVxdWVzdCIsInB1dCIsIm9uc3VjY2VzcyIsIm9uZXJyb3IiLCJnZXQiLCJyZXN1bHQiLCJkZWxldGUiLCJkYlByb21pc2UiLCJpbmRleGVkREIiLCJvcGVuIiwib251cGdyYWRlbmVlZGVkIiwiZXZlbnQiLCJ0YXJnZXQiLCJvYmplY3RTdG9yZU5hbWVzIiwiY29udGFpbnMiLCJjcmVhdGVPYmplY3RTdG9yZSIsIk1FVEFEQVRBX0tFWSIsIkNIVU5LX1BSRUZJWCIsImFsbFByaW50aW5nc1N0b3JhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/lib/utils/allPrintingsStorage.ts\n");

/***/ })

};
;