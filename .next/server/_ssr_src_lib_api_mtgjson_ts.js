"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_src_lib_api_mtgjson_ts";
exports.ids = ["_ssr_src_lib_api_mtgjson_ts"];
exports.modules = {

/***/ "(ssr)/./src/lib/api/mtgjson.ts":
/*!********************************!*\
  !*** ./src/lib/api/mtgjson.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MTGJSON_CONFIG: () => (/* binding */ MTGJSON_CONFIG),\n/* harmony export */   batchGetPriceHistories: () => (/* binding */ batchGetPriceHistories),\n/* harmony export */   clearMTGJSONCache: () => (/* binding */ clearMTGJSONCache),\n/* harmony export */   convertMTGJSONPrices: () => (/* binding */ convertMTGJSONPrices),\n/* harmony export */   fetchPriceHistoryByUUID: () => (/* binding */ fetchPriceHistoryByUUID),\n/* harmony export */   getCardMapping: () => (/* binding */ getCardMapping),\n/* harmony export */   getMTGJSONCacheStats: () => (/* binding */ getMTGJSONCacheStats),\n/* harmony export */   getPriceHistoryForCard: () => (/* binding */ getPriceHistoryForCard)\n/* harmony export */ });\n/* harmony import */ var _lib_services_cardMappingService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/services/cardMappingService */ \"(ssr)/./src/lib/services/cardMappingService.ts\");\n// MTGJSON Configuration\nconst MTGJSON_CONFIG = {\n    baseUrl: 'https://mtgjson.com/api/v5',\n    cacheExpiry: 24 * 60 * 60 * 1000,\n    preferredProvider: 'tcgplayer',\n    enableCaching: true\n};\n// Cache management\nconst CACHE_KEYS = {\n    ALL_PRICES: 'mtgjson-all-prices',\n    CARD_MAPPINGS: 'mtgjson-card-mappings',\n    PRICE_HISTORY: 'mtgjson-price-history-'\n};\n// Rate limiting: MTGJSON doesn't specify limits, but we'll be conservative\nconst RATE_LIMIT_DELAY = 200; // 200ms between requests\nlet lastRequestTime = 0;\nasync function rateLimitedFetch(url) {\n    const now = Date.now();\n    const timeSinceLastRequest = now - lastRequestTime;\n    if (timeSinceLastRequest < RATE_LIMIT_DELAY) {\n        await new Promise((resolve)=>setTimeout(resolve, RATE_LIMIT_DELAY - timeSinceLastRequest));\n    }\n    lastRequestTime = Date.now();\n    try {\n        console.log(`Fetching MTGJSON data: ${url}`);\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`MTGJSON API Error: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    } catch (error) {\n        console.error('MTGJSON API request failed:', {\n            url,\n            error: error instanceof Error ? error.message : 'Unknown error',\n            timestamp: new Date().toISOString()\n        });\n        if (error instanceof Error) {\n            if (error.message.includes('Failed to fetch')) {\n                throw new Error('Network error: Unable to connect to MTGJSON API. Please check your internet connection.');\n            }\n        }\n        throw error;\n    }\n}\n// Cache utilities\nfunction getCachedData(key) {\n    if (!MTGJSON_CONFIG.enableCaching || \"undefined\" === 'undefined') {\n        return null;\n    }\n    try {\n        const cached = localStorage.getItem(key);\n        if (!cached) return null;\n        const parsed = JSON.parse(cached);\n        const now = Date.now();\n        if (parsed.expiresAt && now > parsed.expiresAt) {\n            localStorage.removeItem(key);\n            return null;\n        }\n        return parsed.data;\n    } catch (error) {\n        console.error(`Error reading cache for key ${key}:`, error);\n        return null;\n    }\n}\nfunction setCachedData(key, data, customExpiry) {\n    if (!MTGJSON_CONFIG.enableCaching || \"undefined\" === 'undefined') {\n        return;\n    }\n    try {\n        const expiry = customExpiry || MTGJSON_CONFIG.cacheExpiry;\n        const cacheEntry = {\n            data,\n            expiresAt: Date.now() + expiry,\n            cachedAt: Date.now()\n        };\n        localStorage.setItem(key, JSON.stringify(cacheEntry));\n    } catch (error) {\n        console.error(`Error setting cache for key ${key}:`, error);\n    }\n}\n// Import the card mapping service\n\n// Map Scryfall card to MTGJSON UUID\nasync function getCardMapping(scryfallCard) {\n    try {\n        // Use the card mapping service\n        const uuid = await _lib_services_cardMappingService__WEBPACK_IMPORTED_MODULE_0__.cardMappingService.getMapping(scryfallCard);\n        if (uuid) {\n            // Cache the successful mapping\n            const cacheKey = `${CACHE_KEYS.CARD_MAPPINGS}${scryfallCard.id}`;\n            setCachedData(cacheKey, uuid);\n        }\n        return uuid;\n    } catch (error) {\n        console.error(`Error getting card mapping for ${scryfallCard.name}:`, error);\n        return null;\n    }\n}\n// Fetch price history for a specific UUID\nasync function fetchPriceHistoryByUUID(uuid) {\n    try {\n        // Check cache first\n        const cacheKey = `${CACHE_KEYS.PRICE_HISTORY}${uuid}`;\n        const cached = getCachedData(cacheKey);\n        if (cached) return cached;\n        // Try to get from AllPrices data\n        const priceData = await getAllPricesData();\n        if (priceData && priceData[uuid]) {\n            const cardPrices = priceData[uuid];\n            // Cache the result\n            setCachedData(cacheKey, cardPrices);\n            return cardPrices;\n        }\n        console.log(`No price history found for UUID ${uuid}`);\n        return null;\n    } catch (error) {\n        console.error('Error fetching price history:', error);\n        return null;\n    }\n}\n// Fetch and cache AllPrices.json data\nlet allPricesCache = null;\nlet allPricesLoadingPromise = null;\nasync function getAllPricesData() {\n    // Return cached data if available\n    if (allPricesCache) {\n        return allPricesCache;\n    }\n    // Return existing loading promise if in progress\n    if (allPricesLoadingPromise) {\n        return allPricesLoadingPromise;\n    }\n    // Start loading AllPrices data\n    allPricesLoadingPromise = loadAllPricesData();\n    return allPricesLoadingPromise;\n}\nasync function loadAllPricesData() {\n    try {\n        console.log('Loading MTGJSON AllPrices data...');\n        // Check if we have cached AllPrices data\n        const cachedAllPrices = getCachedData('mtgjson-all-prices-data');\n        // Use cached data if it's less than 24 hours old\n        if (cachedAllPrices && Date.now() - cachedAllPrices.timestamp < 24 * 60 * 60 * 1000) {\n            console.log('Using cached AllPrices data');\n            allPricesCache = cachedAllPrices.data;\n            return allPricesCache;\n        }\n        // Fetch fresh AllPrices data\n        console.log('Fetching fresh AllPrices data from MTGJSON...');\n        const response = await rateLimitedFetch('https://mtgjson.com/api/v5/AllPrices.json');\n        if (!response.ok) {\n            throw new Error(`Failed to fetch AllPrices: ${response.status} ${response.statusText}`);\n        }\n        // Parse the JSON response\n        const allPricesResponse = await response.json();\n        if (!allPricesResponse.data) {\n            throw new Error('Invalid AllPrices response format');\n        }\n        // Cache the data\n        const cacheData = {\n            data: allPricesResponse.data,\n            timestamp: Date.now(),\n            version: allPricesResponse.meta?.version || 'unknown'\n        };\n        setCachedData('mtgjson-all-prices-data', cacheData);\n        allPricesCache = allPricesResponse.data;\n        console.log(`Loaded AllPrices data for ${Object.keys(allPricesCache || {}).length} cards`);\n        return allPricesCache;\n    } catch (error) {\n        console.error('Failed to load AllPrices data:', error);\n        // Try to use stale cached data as fallback\n        const staleCache = getCachedData('mtgjson-all-prices-data');\n        if (staleCache) {\n            console.warn('Using stale AllPrices cache due to fetch failure');\n            allPricesCache = staleCache.data;\n            return allPricesCache;\n        }\n        return null;\n    } finally{\n        allPricesLoadingPromise = null;\n    }\n}\n// Convert MTGJSON price data to our internal format\nfunction convertMTGJSONPrices(uuid, mtgjsonPrices, cardName) {\n    const processedPrices = [];\n    try {\n        // Get the preferred provider's data\n        const provider = MTGJSON_CONFIG.preferredProvider;\n        const paperPrices = mtgjsonPrices.paper?.[provider];\n        if (paperPrices?.normal) {\n            paperPrices.normal.forEach((pricePoint)=>{\n                processedPrices.push({\n                    cardId: uuid,\n                    date: pricePoint.date,\n                    price: pricePoint.price,\n                    priceType: 'usd'\n                });\n            });\n        }\n        if (paperPrices?.foil) {\n            paperPrices.foil.forEach((pricePoint)=>{\n                processedPrices.push({\n                    cardId: uuid,\n                    date: pricePoint.date,\n                    price: pricePoint.price,\n                    priceType: 'usdFoil'\n                });\n            });\n        }\n    } catch (error) {\n        console.error(`Error converting MTGJSON prices for ${cardName}:`, error);\n    }\n    return processedPrices.sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n}\n// Get price history for a Scryfall card\nasync function getPriceHistoryForCard(scryfallCard) {\n    try {\n        // First, get the MTGJSON UUID mapping\n        const uuid = await getCardMapping(scryfallCard);\n        if (!uuid) {\n            console.log(`No MTGJSON mapping found for ${scryfallCard.name}`);\n            return null;\n        }\n        // Fetch the price history\n        const mtgjsonPrices = await fetchPriceHistoryByUUID(uuid);\n        if (!mtgjsonPrices) {\n            return null;\n        }\n        // Convert to our internal format\n        const processedPrices = convertMTGJSONPrices(uuid, mtgjsonPrices, scryfallCard.name);\n        if (processedPrices.length === 0) {\n            return null;\n        }\n        // Calculate trend and volatility\n        const prices = processedPrices.map((p)=>p.price);\n        const averagePrice = prices.reduce((sum, price)=>sum + price, 0) / prices.length;\n        // Simple trend calculation (last 7 days vs previous 7 days)\n        const recent = prices.slice(-7);\n        const previous = prices.slice(-14, -7);\n        const recentAvg = recent.reduce((sum, p)=>sum + p, 0) / recent.length;\n        const previousAvg = previous.reduce((sum, p)=>sum + p, 0) / previous.length;\n        const trend = recentAvg > previousAvg * 1.05 ? 'up' : recentAvg < previousAvg * 0.95 ? 'down' : 'stable';\n        // Calculate volatility (standard deviation)\n        const variance = prices.reduce((sum, price)=>sum + Math.pow(price - averagePrice, 2), 0) / prices.length;\n        const volatility = Math.sqrt(variance);\n        // Calculate percentage changes\n        const percentChange24h = prices.length >= 2 ? (prices[prices.length - 1] - prices[prices.length - 2]) / prices[prices.length - 2] * 100 : undefined;\n        const percentChange7d = recent.length > 0 && previous.length > 0 ? (recentAvg - previousAvg) / previousAvg * 100 : undefined;\n        return {\n            cardId: scryfallCard.id,\n            uuid,\n            prices: processedPrices,\n            trend,\n            volatility,\n            averagePrice,\n            percentChange24h,\n            percentChange7d,\n            lastUpdated: new Date().toISOString(),\n            provider: 'mtgjson'\n        };\n    } catch (error) {\n        console.error(`Error getting price history for ${scryfallCard.name}:`, error);\n        return null;\n    }\n}\n// Batch fetch price histories for multiple cards\nasync function batchGetPriceHistories(cards) {\n    const results = new Map();\n    // Process cards in batches to avoid overwhelming the system\n    const batchSize = 10;\n    for(let i = 0; i < cards.length; i += batchSize){\n        const batch = cards.slice(i, i + batchSize);\n        const batchPromises = batch.map(async (card)=>{\n            const history = await getPriceHistoryForCard(card);\n            if (history) {\n                results.set(card.id, history);\n            }\n        });\n        await Promise.all(batchPromises);\n        // Add a small delay between batches\n        if (i + batchSize < cards.length) {\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n        }\n    }\n    return results;\n}\n// Utility function to clear MTGJSON cache\nfunction clearMTGJSONCache() {\n    if (true) return;\n    try {\n        const keys = Object.keys(localStorage);\n        keys.forEach((key)=>{\n            if (key.startsWith('mtgjson-')) {\n                localStorage.removeItem(key);\n            }\n        });\n        console.log('MTGJSON cache cleared');\n    } catch (error) {\n        console.error('Error clearing MTGJSON cache:', error);\n    }\n}\n// Get cache statistics\nfunction getMTGJSONCacheStats() {\n    if (true) return null;\n    try {\n        const keys = Object.keys(localStorage);\n        const mtgjsonKeys = keys.filter((key)=>key.startsWith('mtgjson-'));\n        let totalSize = 0;\n        const cacheEntries = mtgjsonKeys.map((key)=>{\n            const data = localStorage.getItem(key);\n            const size = data ? data.length : 0;\n            totalSize += size;\n            return {\n                key,\n                size,\n                sizeFormatted: `${(size / 1024).toFixed(2)} KB`\n            };\n        });\n        return {\n            totalEntries: mtgjsonKeys.length,\n            totalSize,\n            totalSizeFormatted: `${(totalSize / 1024 / 1024).toFixed(2)} MB`,\n            entries: cacheEntries\n        };\n    } catch (error) {\n        console.error('Error getting cache stats:', error);\n        return null;\n    }\n}\n// Export configuration for external use\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RXRELElBQUlJLFlBQVk7UUFDaEIsTUFBTUMsZUFBZUgsWUFBWW5DLEdBQUcsQ0FBQ2pFLENBQUFBO1lBQ25DLE1BQU1TLE9BQU9QLGFBQWFDLE9BQU8sQ0FBQ0g7WUFDbEMsTUFBTXdHLE9BQU8vRixPQUFPQSxLQUFLK0IsTUFBTSxHQUFHO1lBQ2xDOEQsYUFBYUU7WUFFYixPQUFPO2dCQUNMeEc7Z0JBQ0F3RztnQkFDQUMsZUFBZSxHQUFHLENBQUNELE9BQU8sSUFBRyxFQUFHRSxPQUFPLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDakQ7UUFDRjtRQUVBLE9BQU87WUFDTEMsY0FBY1AsWUFBWTVELE1BQU07WUFDaEM4RDtZQUNBTSxvQkFBb0IsR0FBRyxDQUFDTixZQUFZLE9BQU8sSUFBRyxFQUFHSSxPQUFPLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDaEVHLFNBQVNOO1FBQ1g7SUFDRixFQUFFLE9BQU83RyxPQUFPO1FBQ2RSLFFBQVFRLEtBQUssQ0FBQyw4QkFBOEJBO1FBQzVDLE9BQU87SUFDVDtBQUNGO0FBRUEsd0NBQXdDO0FBQ2QiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcbXRnLWluZGV4XFxzcmNcXGxpYlxcYXBpXFxtdGdqc29uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxyXG4gIE1UR0pTT05DYXJkLCBcclxuICBNVEdKU09OQ2FyZFByaWNlcywgXHJcbiAgTVRHSlNPTlByaWNlUG9pbnQsIFxyXG4gIE1UR0pTT05Db25maWcsIFxyXG4gIE1UR0pTT05DYWNoZSxcclxuICBQcmljZUhpc3RvcnksXHJcbiAgUHJvY2Vzc2VkQ2FyZFByaWNlLFxyXG4gIE1UR0NhcmQgXHJcbn0gZnJvbSAnQC9saWIvdHlwZXMnO1xyXG5cclxuLy8gTVRHSlNPTiBDb25maWd1cmF0aW9uXHJcbmNvbnN0IE1UR0pTT05fQ09ORklHOiBNVEdKU09OQ29uZmlnID0ge1xyXG4gIGJhc2VVcmw6ICdodHRwczovL210Z2pzb24uY29tL2FwaS92NScsXHJcbiAgY2FjaGVFeHBpcnk6IDI0ICogNjAgKiA2MCAqIDEwMDAsIC8vIDI0IGhvdXJzXHJcbiAgcHJlZmVycmVkUHJvdmlkZXI6ICd0Y2dwbGF5ZXInLFxyXG4gIGVuYWJsZUNhY2hpbmc6IHRydWUsXHJcbn07XHJcblxyXG4vLyBDYWNoZSBtYW5hZ2VtZW50XHJcbmNvbnN0IENBQ0hFX0tFWVMgPSB7XHJcbiAgQUxMX1BSSUNFUzogJ210Z2pzb24tYWxsLXByaWNlcycsXHJcbiAgQ0FSRF9NQVBQSU5HUzogJ210Z2pzb24tY2FyZC1tYXBwaW5ncycsXHJcbiAgUFJJQ0VfSElTVE9SWTogJ210Z2pzb24tcHJpY2UtaGlzdG9yeS0nLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuLy8gUmF0ZSBsaW1pdGluZzogTVRHSlNPTiBkb2Vzbid0IHNwZWNpZnkgbGltaXRzLCBidXQgd2UnbGwgYmUgY29uc2VydmF0aXZlXHJcbmNvbnN0IFJBVEVfTElNSVRfREVMQVkgPSAyMDA7IC8vIDIwMG1zIGJldHdlZW4gcmVxdWVzdHNcclxubGV0IGxhc3RSZXF1ZXN0VGltZSA9IDA7XHJcblxyXG5hc3luYyBmdW5jdGlvbiByYXRlTGltaXRlZEZldGNoKHVybDogc3RyaW5nKTogUHJvbWlzZTxSZXNwb25zZT4ge1xyXG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgY29uc3QgdGltZVNpbmNlTGFzdFJlcXVlc3QgPSBub3cgLSBsYXN0UmVxdWVzdFRpbWU7XHJcbiAgXHJcbiAgaWYgKHRpbWVTaW5jZUxhc3RSZXF1ZXN0IDwgUkFURV9MSU1JVF9ERUxBWSkge1xyXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIFJBVEVfTElNSVRfREVMQVkgLSB0aW1lU2luY2VMYXN0UmVxdWVzdCkpO1xyXG4gIH1cclxuICBcclxuICBsYXN0UmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgTVRHSlNPTiBkYXRhOiAke3VybH1gKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1UR0pTT04gQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ01UR0pTT04gQVBJIHJlcXVlc3QgZmFpbGVkOicsIHtcclxuICAgICAgdXJsLFxyXG4gICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0ZhaWxlZCB0byBmZXRjaCcpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yOiBVbmFibGUgdG8gY29ubmVjdCB0byBNVEdKU09OIEFQSS4gUGxlYXNlIGNoZWNrIHlvdXIgaW50ZXJuZXQgY29ubmVjdGlvbi4nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbi8vIENhY2hlIHV0aWxpdGllc1xyXG5mdW5jdGlvbiBnZXRDYWNoZWREYXRhPFQ+KGtleTogc3RyaW5nKTogVCB8IG51bGwge1xyXG4gIGlmICghTVRHSlNPTl9DT05GSUcuZW5hYmxlQ2FjaGluZyB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgY2FjaGVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcclxuICAgIGlmICghY2FjaGVkKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGNhY2hlZCk7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgXHJcbiAgICBpZiAocGFyc2VkLmV4cGlyZXNBdCAmJiBub3cgPiBwYXJzZWQuZXhwaXJlc0F0KSB7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJzZWQuZGF0YTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVhZGluZyBjYWNoZSBmb3Iga2V5ICR7a2V5fTpgLCBlcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldENhY2hlZERhdGE8VD4oa2V5OiBzdHJpbmcsIGRhdGE6IFQsIGN1c3RvbUV4cGlyeT86IG51bWJlcik6IHZvaWQge1xyXG4gIGlmICghTVRHSlNPTl9DT05GSUcuZW5hYmxlQ2FjaGluZyB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGV4cGlyeSA9IGN1c3RvbUV4cGlyeSB8fCBNVEdKU09OX0NPTkZJRy5jYWNoZUV4cGlyeTtcclxuICAgIGNvbnN0IGNhY2hlRW50cnkgPSB7XHJcbiAgICAgIGRhdGEsXHJcbiAgICAgIGV4cGlyZXNBdDogRGF0ZS5ub3coKSArIGV4cGlyeSxcclxuICAgICAgY2FjaGVkQXQ6IERhdGUubm93KCksXHJcbiAgICB9O1xyXG5cclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkoY2FjaGVFbnRyeSkpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzZXR0aW5nIGNhY2hlIGZvciBrZXkgJHtrZXl9OmAsIGVycm9yKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEltcG9ydCB0aGUgY2FyZCBtYXBwaW5nIHNlcnZpY2VcclxuaW1wb3J0IHsgY2FyZE1hcHBpbmdTZXJ2aWNlIH0gZnJvbSAnQC9saWIvc2VydmljZXMvY2FyZE1hcHBpbmdTZXJ2aWNlJztcclxuXHJcbi8vIE1hcCBTY3J5ZmFsbCBjYXJkIHRvIE1UR0pTT04gVVVJRFxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FyZE1hcHBpbmcoc2NyeWZhbGxDYXJkOiBNVEdDYXJkKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIFVzZSB0aGUgY2FyZCBtYXBwaW5nIHNlcnZpY2VcclxuICAgIGNvbnN0IHV1aWQgPSBhd2FpdCBjYXJkTWFwcGluZ1NlcnZpY2UuZ2V0TWFwcGluZyhzY3J5ZmFsbENhcmQpO1xyXG4gICAgXHJcbiAgICBpZiAodXVpZCkge1xyXG4gICAgICAvLyBDYWNoZSB0aGUgc3VjY2Vzc2Z1bCBtYXBwaW5nXHJcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7Q0FDSEVfS0VZUy5DQVJEX01BUFBJTkdTfSR7c2NyeWZhbGxDYXJkLmlkfWA7XHJcbiAgICAgIHNldENhY2hlZERhdGEoY2FjaGVLZXksIHV1aWQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gdXVpZDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyBjYXJkIG1hcHBpbmcgZm9yICR7c2NyeWZhbGxDYXJkLm5hbWV9OmAsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRmV0Y2ggcHJpY2UgaGlzdG9yeSBmb3IgYSBzcGVjaWZpYyBVVUlEXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFByaWNlSGlzdG9yeUJ5VVVJRCh1dWlkOiBzdHJpbmcpOiBQcm9taXNlPE1UR0pTT05DYXJkUHJpY2VzIHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxyXG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtDQUNIRV9LRVlTLlBSSUNFX0hJU1RPUll9JHt1dWlkfWA7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBnZXRDYWNoZWREYXRhPE1UR0pTT05DYXJkUHJpY2VzPihjYWNoZUtleSk7XHJcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xyXG5cclxuICAgIC8vIFRyeSB0byBnZXQgZnJvbSBBbGxQcmljZXMgZGF0YVxyXG4gICAgY29uc3QgcHJpY2VEYXRhID0gYXdhaXQgZ2V0QWxsUHJpY2VzRGF0YSgpO1xyXG4gICAgaWYgKHByaWNlRGF0YSAmJiBwcmljZURhdGFbdXVpZF0pIHtcclxuICAgICAgY29uc3QgY2FyZFByaWNlcyA9IHByaWNlRGF0YVt1dWlkXTtcclxuICAgICAgXHJcbiAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRcclxuICAgICAgc2V0Q2FjaGVkRGF0YShjYWNoZUtleSwgY2FyZFByaWNlcyk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gY2FyZFByaWNlcztcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhgTm8gcHJpY2UgaGlzdG9yeSBmb3VuZCBmb3IgVVVJRCAke3V1aWR9YCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJpY2UgaGlzdG9yeTonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8vIEZldGNoIGFuZCBjYWNoZSBBbGxQcmljZXMuanNvbiBkYXRhXHJcbmxldCBhbGxQcmljZXNDYWNoZTogUmVjb3JkPHN0cmluZywgTVRHSlNPTkNhcmRQcmljZXM+IHwgbnVsbCA9IG51bGw7XHJcbmxldCBhbGxQcmljZXNMb2FkaW5nUHJvbWlzZTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBNVEdKU09OQ2FyZFByaWNlcz4gfCBudWxsPiB8IG51bGwgPSBudWxsO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0QWxsUHJpY2VzRGF0YSgpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIE1UR0pTT05DYXJkUHJpY2VzPiB8IG51bGw+IHtcclxuICAvLyBSZXR1cm4gY2FjaGVkIGRhdGEgaWYgYXZhaWxhYmxlXHJcbiAgaWYgKGFsbFByaWNlc0NhY2hlKSB7XHJcbiAgICByZXR1cm4gYWxsUHJpY2VzQ2FjaGU7XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gZXhpc3RpbmcgbG9hZGluZyBwcm9taXNlIGlmIGluIHByb2dyZXNzXHJcbiAgaWYgKGFsbFByaWNlc0xvYWRpbmdQcm9taXNlKSB7XHJcbiAgICByZXR1cm4gYWxsUHJpY2VzTG9hZGluZ1Byb21pc2U7XHJcbiAgfVxyXG5cclxuICAvLyBTdGFydCBsb2FkaW5nIEFsbFByaWNlcyBkYXRhXHJcbiAgYWxsUHJpY2VzTG9hZGluZ1Byb21pc2UgPSBsb2FkQWxsUHJpY2VzRGF0YSgpO1xyXG4gIHJldHVybiBhbGxQcmljZXNMb2FkaW5nUHJvbWlzZTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gbG9hZEFsbFByaWNlc0RhdGEoKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBNVEdKU09OQ2FyZFByaWNlcz4gfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIE1UR0pTT04gQWxsUHJpY2VzIGRhdGEuLi4nKTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGNhY2hlZCBBbGxQcmljZXMgZGF0YVxyXG4gICAgY29uc3QgY2FjaGVkQWxsUHJpY2VzID0gZ2V0Q2FjaGVkRGF0YTx7XHJcbiAgICAgIGRhdGE6IFJlY29yZDxzdHJpbmcsIE1UR0pTT05DYXJkUHJpY2VzPjtcclxuICAgICAgdGltZXN0YW1wOiBudW1iZXI7XHJcbiAgICAgIHZlcnNpb246IHN0cmluZztcclxuICAgIH0+KCdtdGdqc29uLWFsbC1wcmljZXMtZGF0YScpO1xyXG5cclxuICAgIC8vIFVzZSBjYWNoZWQgZGF0YSBpZiBpdCdzIGxlc3MgdGhhbiAyNCBob3VycyBvbGRcclxuICAgIGlmIChjYWNoZWRBbGxQcmljZXMgJiYgKERhdGUubm93KCkgLSBjYWNoZWRBbGxQcmljZXMudGltZXN0YW1wKSA8IDI0ICogNjAgKiA2MCAqIDEwMDApIHtcclxuICAgICAgY29uc29sZS5sb2coJ1VzaW5nIGNhY2hlZCBBbGxQcmljZXMgZGF0YScpO1xyXG4gICAgICBhbGxQcmljZXNDYWNoZSA9IGNhY2hlZEFsbFByaWNlcy5kYXRhO1xyXG4gICAgICByZXR1cm4gYWxsUHJpY2VzQ2FjaGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmV0Y2ggZnJlc2ggQWxsUHJpY2VzIGRhdGFcclxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBmcmVzaCBBbGxQcmljZXMgZGF0YSBmcm9tIE1UR0pTT04uLi4nKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmF0ZUxpbWl0ZWRGZXRjaCgnaHR0cHM6Ly9tdGdqc29uLmNvbS9hcGkvdjUvQWxsUHJpY2VzLmpzb24nKTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBBbGxQcmljZXM6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFyc2UgdGhlIEpTT04gcmVzcG9uc2VcclxuICAgIGNvbnN0IGFsbFByaWNlc1Jlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgXHJcbiAgICBpZiAoIWFsbFByaWNlc1Jlc3BvbnNlLmRhdGEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEFsbFByaWNlcyByZXNwb25zZSBmb3JtYXQnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWNoZSB0aGUgZGF0YVxyXG4gICAgY29uc3QgY2FjaGVEYXRhID0ge1xyXG4gICAgICBkYXRhOiBhbGxQcmljZXNSZXNwb25zZS5kYXRhLFxyXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgIHZlcnNpb246IGFsbFByaWNlc1Jlc3BvbnNlLm1ldGE/LnZlcnNpb24gfHwgJ3Vua25vd24nLFxyXG4gICAgfTtcclxuXHJcbiAgICBzZXRDYWNoZWREYXRhKCdtdGdqc29uLWFsbC1wcmljZXMtZGF0YScsIGNhY2hlRGF0YSk7XHJcbiAgICBhbGxQcmljZXNDYWNoZSA9IGFsbFByaWNlc1Jlc3BvbnNlLmRhdGE7XHJcblxyXG4gICAgY29uc29sZS5sb2coYExvYWRlZCBBbGxQcmljZXMgZGF0YSBmb3IgJHtPYmplY3Qua2V5cyhhbGxQcmljZXNDYWNoZSB8fCB7fSkubGVuZ3RofSBjYXJkc2ApO1xyXG4gICAgcmV0dXJuIGFsbFByaWNlc0NhY2hlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBBbGxQcmljZXMgZGF0YTonLCBlcnJvcik7XHJcbiAgICBcclxuICAgIC8vIFRyeSB0byB1c2Ugc3RhbGUgY2FjaGVkIGRhdGEgYXMgZmFsbGJhY2tcclxuICAgIGNvbnN0IHN0YWxlQ2FjaGUgPSBnZXRDYWNoZWREYXRhPHtcclxuICAgICAgZGF0YTogUmVjb3JkPHN0cmluZywgTVRHSlNPTkNhcmRQcmljZXM+O1xyXG4gICAgICB0aW1lc3RhbXA6IG51bWJlcjtcclxuICAgIH0+KCdtdGdqc29uLWFsbC1wcmljZXMtZGF0YScpO1xyXG5cclxuICAgIGlmIChzdGFsZUNhY2hlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignVXNpbmcgc3RhbGUgQWxsUHJpY2VzIGNhY2hlIGR1ZSB0byBmZXRjaCBmYWlsdXJlJyk7XHJcbiAgICAgIGFsbFByaWNlc0NhY2hlID0gc3RhbGVDYWNoZS5kYXRhO1xyXG4gICAgICByZXR1cm4gYWxsUHJpY2VzQ2FjaGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIGFsbFByaWNlc0xvYWRpbmdQcm9taXNlID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8vIENvbnZlcnQgTVRHSlNPTiBwcmljZSBkYXRhIHRvIG91ciBpbnRlcm5hbCBmb3JtYXRcclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRNVEdKU09OUHJpY2VzKFxyXG4gIHV1aWQ6IHN0cmluZyxcclxuICBtdGdqc29uUHJpY2VzOiBNVEdKU09OQ2FyZFByaWNlcyxcclxuICBjYXJkTmFtZTogc3RyaW5nXHJcbik6IFByb2Nlc3NlZENhcmRQcmljZVtdIHtcclxuICBjb25zdCBwcm9jZXNzZWRQcmljZXM6IFByb2Nlc3NlZENhcmRQcmljZVtdID0gW107XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIC8vIEdldCB0aGUgcHJlZmVycmVkIHByb3ZpZGVyJ3MgZGF0YVxyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBNVEdKU09OX0NPTkZJRy5wcmVmZXJyZWRQcm92aWRlcjtcclxuICAgIGNvbnN0IHBhcGVyUHJpY2VzID0gbXRnanNvblByaWNlcy5wYXBlcj8uW3Byb3ZpZGVyXTtcclxuICAgIFxyXG4gICAgaWYgKHBhcGVyUHJpY2VzPy5ub3JtYWwpIHtcclxuICAgICAgcGFwZXJQcmljZXMubm9ybWFsLmZvckVhY2gocHJpY2VQb2ludCA9PiB7XHJcbiAgICAgICAgcHJvY2Vzc2VkUHJpY2VzLnB1c2goe1xyXG4gICAgICAgICAgY2FyZElkOiB1dWlkLFxyXG4gICAgICAgICAgZGF0ZTogcHJpY2VQb2ludC5kYXRlLFxyXG4gICAgICAgICAgcHJpY2U6IHByaWNlUG9pbnQucHJpY2UsXHJcbiAgICAgICAgICBwcmljZVR5cGU6ICd1c2QnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHBhcGVyUHJpY2VzPy5mb2lsKSB7XHJcbiAgICAgIHBhcGVyUHJpY2VzLmZvaWwuZm9yRWFjaChwcmljZVBvaW50ID0+IHtcclxuICAgICAgICBwcm9jZXNzZWRQcmljZXMucHVzaCh7XHJcbiAgICAgICAgICBjYXJkSWQ6IHV1aWQsXHJcbiAgICAgICAgICBkYXRlOiBwcmljZVBvaW50LmRhdGUsXHJcbiAgICAgICAgICBwcmljZTogcHJpY2VQb2ludC5wcmljZSxcclxuICAgICAgICAgIHByaWNlVHlwZTogJ3VzZEZvaWwnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgY29udmVydGluZyBNVEdKU09OIHByaWNlcyBmb3IgJHtjYXJkTmFtZX06YCwgZXJyb3IpO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gcHJvY2Vzc2VkUHJpY2VzLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGEuZGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5kYXRlKS5nZXRUaW1lKCkpO1xyXG59XHJcblxyXG4vLyBHZXQgcHJpY2UgaGlzdG9yeSBmb3IgYSBTY3J5ZmFsbCBjYXJkXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcmljZUhpc3RvcnlGb3JDYXJkKHNjcnlmYWxsQ2FyZDogTVRHQ2FyZCk6IFByb21pc2U8UHJpY2VIaXN0b3J5IHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBGaXJzdCwgZ2V0IHRoZSBNVEdKU09OIFVVSUQgbWFwcGluZ1xyXG4gICAgY29uc3QgdXVpZCA9IGF3YWl0IGdldENhcmRNYXBwaW5nKHNjcnlmYWxsQ2FyZCk7XHJcbiAgICBpZiAoIXV1aWQpIHtcclxuICAgICAgY29uc29sZS5sb2coYE5vIE1UR0pTT04gbWFwcGluZyBmb3VuZCBmb3IgJHtzY3J5ZmFsbENhcmQubmFtZX1gKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmV0Y2ggdGhlIHByaWNlIGhpc3RvcnlcclxuICAgIGNvbnN0IG10Z2pzb25QcmljZXMgPSBhd2FpdCBmZXRjaFByaWNlSGlzdG9yeUJ5VVVJRCh1dWlkKTtcclxuICAgIGlmICghbXRnanNvblByaWNlcykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb252ZXJ0IHRvIG91ciBpbnRlcm5hbCBmb3JtYXRcclxuICAgIGNvbnN0IHByb2Nlc3NlZFByaWNlcyA9IGNvbnZlcnRNVEdKU09OUHJpY2VzKHV1aWQsIG10Z2pzb25QcmljZXMsIHNjcnlmYWxsQ2FyZC5uYW1lKTtcclxuICAgIFxyXG4gICAgaWYgKHByb2Nlc3NlZFByaWNlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRyZW5kIGFuZCB2b2xhdGlsaXR5XHJcbiAgICBjb25zdCBwcmljZXMgPSBwcm9jZXNzZWRQcmljZXMubWFwKHAgPT4gcC5wcmljZSk7XHJcbiAgICBjb25zdCBhdmVyYWdlUHJpY2UgPSBwcmljZXMucmVkdWNlKChzdW0sIHByaWNlKSA9PiBzdW0gKyBwcmljZSwgMCkgLyBwcmljZXMubGVuZ3RoO1xyXG4gICAgXHJcbiAgICAvLyBTaW1wbGUgdHJlbmQgY2FsY3VsYXRpb24gKGxhc3QgNyBkYXlzIHZzIHByZXZpb3VzIDcgZGF5cylcclxuICAgIGNvbnN0IHJlY2VudCA9IHByaWNlcy5zbGljZSgtNyk7XHJcbiAgICBjb25zdCBwcmV2aW91cyA9IHByaWNlcy5zbGljZSgtMTQsIC03KTtcclxuICAgIGNvbnN0IHJlY2VudEF2ZyA9IHJlY2VudC5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcCwgMCkgLyByZWNlbnQubGVuZ3RoO1xyXG4gICAgY29uc3QgcHJldmlvdXNBdmcgPSBwcmV2aW91cy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcCwgMCkgLyBwcmV2aW91cy5sZW5ndGg7XHJcbiAgICBcclxuICAgIGNvbnN0IHRyZW5kOiAndXAnIHwgJ2Rvd24nIHwgJ3N0YWJsZScgPSBcclxuICAgICAgcmVjZW50QXZnID4gcHJldmlvdXNBdmcgKiAxLjA1ID8gJ3VwJyA6XHJcbiAgICAgIHJlY2VudEF2ZyA8IHByZXZpb3VzQXZnICogMC45NSA/ICdkb3duJyA6ICdzdGFibGUnO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB2b2xhdGlsaXR5IChzdGFuZGFyZCBkZXZpYXRpb24pXHJcbiAgICBjb25zdCB2YXJpYW5jZSA9IHByaWNlcy5yZWR1Y2UoKHN1bSwgcHJpY2UpID0+IHN1bSArIE1hdGgucG93KHByaWNlIC0gYXZlcmFnZVByaWNlLCAyKSwgMCkgLyBwcmljZXMubGVuZ3RoO1xyXG4gICAgY29uc3Qgdm9sYXRpbGl0eSA9IE1hdGguc3FydCh2YXJpYW5jZSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHBlcmNlbnRhZ2UgY2hhbmdlc1xyXG4gICAgY29uc3QgcGVyY2VudENoYW5nZTI0aCA9IHByaWNlcy5sZW5ndGggPj0gMiA/IFxyXG4gICAgICAoKHByaWNlc1twcmljZXMubGVuZ3RoIC0gMV0gLSBwcmljZXNbcHJpY2VzLmxlbmd0aCAtIDJdKSAvIHByaWNlc1twcmljZXMubGVuZ3RoIC0gMl0pICogMTAwIDogdW5kZWZpbmVkO1xyXG4gICAgXHJcbiAgICBjb25zdCBwZXJjZW50Q2hhbmdlN2QgPSByZWNlbnQubGVuZ3RoID4gMCAmJiBwcmV2aW91cy5sZW5ndGggPiAwID8gXHJcbiAgICAgICgocmVjZW50QXZnIC0gcHJldmlvdXNBdmcpIC8gcHJldmlvdXNBdmcpICogMTAwIDogdW5kZWZpbmVkO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNhcmRJZDogc2NyeWZhbGxDYXJkLmlkLFxyXG4gICAgICB1dWlkLFxyXG4gICAgICBwcmljZXM6IHByb2Nlc3NlZFByaWNlcyxcclxuICAgICAgdHJlbmQsXHJcbiAgICAgIHZvbGF0aWxpdHksXHJcbiAgICAgIGF2ZXJhZ2VQcmljZSxcclxuICAgICAgcGVyY2VudENoYW5nZTI0aCxcclxuICAgICAgcGVyY2VudENoYW5nZTdkLFxyXG4gICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBwcm92aWRlcjogJ210Z2pzb24nLFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyBwcmljZSBoaXN0b3J5IGZvciAke3NjcnlmYWxsQ2FyZC5uYW1lfTpgLCBlcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8vIEJhdGNoIGZldGNoIHByaWNlIGhpc3RvcmllcyBmb3IgbXVsdGlwbGUgY2FyZHNcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJhdGNoR2V0UHJpY2VIaXN0b3JpZXMoY2FyZHM6IE1UR0NhcmRbXSk6IFByb21pc2U8TWFwPHN0cmluZywgUHJpY2VIaXN0b3J5Pj4ge1xyXG4gIGNvbnN0IHJlc3VsdHMgPSBuZXcgTWFwPHN0cmluZywgUHJpY2VIaXN0b3J5PigpO1xyXG4gIFxyXG4gIC8vIFByb2Nlc3MgY2FyZHMgaW4gYmF0Y2hlcyB0byBhdm9pZCBvdmVyd2hlbG1pbmcgdGhlIHN5c3RlbVxyXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IDEwO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2FyZHMubGVuZ3RoOyBpICs9IGJhdGNoU2l6ZSkge1xyXG4gICAgY29uc3QgYmF0Y2ggPSBjYXJkcy5zbGljZShpLCBpICsgYmF0Y2hTaXplKTtcclxuICAgIFxyXG4gICAgY29uc3QgYmF0Y2hQcm9taXNlcyA9IGJhdGNoLm1hcChhc3luYyAoY2FyZCkgPT4ge1xyXG4gICAgICBjb25zdCBoaXN0b3J5ID0gYXdhaXQgZ2V0UHJpY2VIaXN0b3J5Rm9yQ2FyZChjYXJkKTtcclxuICAgICAgaWYgKGhpc3RvcnkpIHtcclxuICAgICAgICByZXN1bHRzLnNldChjYXJkLmlkLCBoaXN0b3J5KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGF3YWl0IFByb21pc2UuYWxsKGJhdGNoUHJvbWlzZXMpO1xyXG4gICAgXHJcbiAgICAvLyBBZGQgYSBzbWFsbCBkZWxheSBiZXR3ZWVuIGJhdGNoZXNcclxuICAgIGlmIChpICsgYmF0Y2hTaXplIDwgY2FyZHMubGVuZ3RoKSB7XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiByZXN1bHRzO1xyXG59XHJcblxyXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNsZWFyIE1UR0pTT04gY2FjaGVcclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyTVRHSlNPTkNhY2hlKCk6IHZvaWQge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKTtcclxuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ210Z2pzb24tJykpIHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKCdNVEdKU09OIGNhY2hlIGNsZWFyZWQnKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2xlYXJpbmcgTVRHSlNPTiBjYWNoZTonLCBlcnJvcik7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBHZXQgY2FjaGUgc3RhdGlzdGljc1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TVRHSlNPTkNhY2hlU3RhdHMoKSB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcclxuICBcclxuICB0cnkge1xyXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGxvY2FsU3RvcmFnZSk7XHJcbiAgICBjb25zdCBtdGdqc29uS2V5cyA9IGtleXMuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aCgnbXRnanNvbi0nKSk7XHJcbiAgICBcclxuICAgIGxldCB0b3RhbFNpemUgPSAwO1xyXG4gICAgY29uc3QgY2FjaGVFbnRyaWVzID0gbXRnanNvbktleXMubWFwKGtleSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xyXG4gICAgICBjb25zdCBzaXplID0gZGF0YSA/IGRhdGEubGVuZ3RoIDogMDtcclxuICAgICAgdG90YWxTaXplICs9IHNpemU7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGtleSxcclxuICAgICAgICBzaXplLFxyXG4gICAgICAgIHNpemVGb3JtYXR0ZWQ6IGAkeyhzaXplIC8gMTAyNCkudG9GaXhlZCgyKX0gS0JgLFxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvdGFsRW50cmllczogbXRnanNvbktleXMubGVuZ3RoLFxyXG4gICAgICB0b3RhbFNpemUsXHJcbiAgICAgIHRvdGFsU2l6ZUZvcm1hdHRlZDogYCR7KHRvdGFsU2l6ZSAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDIpfSBNQmAsXHJcbiAgICAgIGVudHJpZXM6IGNhY2hlRW50cmllcyxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY2FjaGUgc3RhdHM6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgY29uZmlndXJhdGlvbiBmb3IgZXh0ZXJuYWwgdXNlXHJcbmV4cG9ydCB7IE1UR0pTT05fQ09ORklHIH07XHJcbiJdLCJuYW1lcyI6WyJNVEdKU09OX0NPTkZJRyIsImJhc2VVcmwiLCJjYWNoZUV4cGlyeSIsInByZWZlcnJlZFByb3ZpZGVyIiwiZW5hYmxlQ2FjaGluZyIsIkNBQ0hFX0tFWVMiLCJBTExfUFJJQ0VTIiwiQ0FSRF9NQVBQSU5HUyIsIlBSSUNFX0hJU1RPUlkiLCJSQVRFX0xJTUlUX0RFTEFZIiwibGFzdFJlcXVlc3RUaW1lIiwicmF0ZUxpbWl0ZWRGZXRjaCIsInVybCIsIm5vdyIsIkRhdGUiLCJ0aW1lU2luY2VMYXN0UmVxdWVzdCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJlcnJvciIsIm1lc3NhZ2UiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsImluY2x1ZGVzIiwiZ2V0Q2FjaGVkRGF0YSIsImtleSIsImNhY2hlZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJleHBpcmVzQXQiLCJyZW1vdmVJdGVtIiwiZGF0YSIsInNldENhY2hlZERhdGEiLCJjdXN0b21FeHBpcnkiLCJleHBpcnkiLCJjYWNoZUVudHJ5IiwiY2FjaGVkQXQiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiY2FyZE1hcHBpbmdTZXJ2aWNlIiwiZ2V0Q2FyZE1hcHBpbmciLCJzY3J5ZmFsbENhcmQiLCJ1dWlkIiwiZ2V0TWFwcGluZyIsImNhY2hlS2V5IiwiaWQiLCJuYW1lIiwiZmV0Y2hQcmljZUhpc3RvcnlCeVVVSUQiLCJwcmljZURhdGEiLCJnZXRBbGxQcmljZXNEYXRhIiwiY2FyZFByaWNlcyIsImFsbFByaWNlc0NhY2hlIiwiYWxsUHJpY2VzTG9hZGluZ1Byb21pc2UiLCJsb2FkQWxsUHJpY2VzRGF0YSIsImNhY2hlZEFsbFByaWNlcyIsImFsbFByaWNlc1Jlc3BvbnNlIiwianNvbiIsImNhY2hlRGF0YSIsInZlcnNpb24iLCJtZXRhIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInN0YWxlQ2FjaGUiLCJ3YXJuIiwiY29udmVydE1UR0pTT05QcmljZXMiLCJtdGdqc29uUHJpY2VzIiwiY2FyZE5hbWUiLCJwcm9jZXNzZWRQcmljZXMiLCJwcm92aWRlciIsInBhcGVyUHJpY2VzIiwicGFwZXIiLCJub3JtYWwiLCJmb3JFYWNoIiwicHJpY2VQb2ludCIsInB1c2giLCJjYXJkSWQiLCJkYXRlIiwicHJpY2UiLCJwcmljZVR5cGUiLCJmb2lsIiwic29ydCIsImEiLCJiIiwiZ2V0VGltZSIsImdldFByaWNlSGlzdG9yeUZvckNhcmQiLCJwcmljZXMiLCJtYXAiLCJwIiwiYXZlcmFnZVByaWNlIiwicmVkdWNlIiwic3VtIiwicmVjZW50Iiwic2xpY2UiLCJwcmV2aW91cyIsInJlY2VudEF2ZyIsInByZXZpb3VzQXZnIiwidHJlbmQiLCJ2YXJpYW5jZSIsIk1hdGgiLCJwb3ciLCJ2b2xhdGlsaXR5Iiwic3FydCIsInBlcmNlbnRDaGFuZ2UyNGgiLCJ1bmRlZmluZWQiLCJwZXJjZW50Q2hhbmdlN2QiLCJsYXN0VXBkYXRlZCIsImJhdGNoR2V0UHJpY2VIaXN0b3JpZXMiLCJjYXJkcyIsInJlc3VsdHMiLCJNYXAiLCJiYXRjaFNpemUiLCJpIiwiYmF0Y2giLCJiYXRjaFByb21pc2VzIiwiY2FyZCIsImhpc3RvcnkiLCJzZXQiLCJhbGwiLCJjbGVhck1UR0pTT05DYWNoZSIsInN0YXJ0c1dpdGgiLCJnZXRNVEdKU09OQ2FjaGVTdGF0cyIsIm10Z2pzb25LZXlzIiwiZmlsdGVyIiwidG90YWxTaXplIiwiY2FjaGVFbnRyaWVzIiwic2l6ZSIsInNpemVGb3JtYXR0ZWQiLCJ0b0ZpeGVkIiwidG90YWxFbnRyaWVzIiwidG90YWxTaXplRm9ybWF0dGVkIiwiZW50cmllcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./src/lib/api/mtgjson.ts\n");

/***/ }),

/***/ "(ssr)/./src/lib/services/cardMappingService.ts":
/*!************************************************!*\
  !*** ./src/lib/services/cardMappingService.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cardMappingService: () => (/* binding */ cardMappingService)\n/* harmony export */ });\n/* harmony import */ var _lib_utils_mtgjsonCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/utils/mtgjsonCache */ \"(ssr)/./src/lib/utils/mtgjsonCache.ts\");\n\nclass CardMappingService {\n    /**\r\n   * Initialize the mapping service by loading AllPrintings data\r\n   */ async initialize() {\n        if (this.loadingPromise) {\n            return this.loadingPromise;\n        }\n        this.loadingPromise = this.loadAllPrintingsData();\n        return this.loadingPromise;\n    }\n    /**\r\n   * Load and cache AllPrintings.json data\r\n   */ async loadAllPrintingsData() {\n        try {\n            console.log('Loading MTGJSON AllPrintings data...');\n            // Try to load from cache first\n            const cached = await this.getCachedAllPrintings();\n            if (cached && this.isDataFresh(cached.meta.date)) {\n                this.allPrintingsData = cached;\n                console.log('Loaded AllPrintings from cache');\n                await this.loadMappingCache();\n                return;\n            }\n            // Fetch fresh data from MTGJSON\n            console.log('Fetching fresh AllPrintings data from MTGJSON...');\n            const response = await fetch(this.MTGJSON_ALL_PRINTINGS_URL);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch AllPrintings: ${response.status} ${response.statusText}`);\n            }\n            // Parse the response\n            const data = await response.json();\n            if (!data.data || !data.meta) {\n                throw new Error('Invalid AllPrintings response format');\n            }\n            this.allPrintingsData = data;\n            // Store using the optimized storage system\n            const { allPrintingsStorage } = await __webpack_require__.e(/*! import() */ \"_ssr_src_lib_utils_allPrintingsStorage_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/utils/allPrintingsStorage */ \"(ssr)/./src/lib/utils/allPrintingsStorage.ts\"));\n            await allPrintingsStorage.storeAllPrintings(data);\n            await this.loadMappingCache();\n            console.log(`Loaded ${Object.keys(data.data).length} sets from MTGJSON`);\n        } catch (error) {\n            console.error('Failed to load AllPrintings data:', error);\n            // Try to use optimized storage as fallback\n            try {\n                const { allPrintingsStorage } = await __webpack_require__.e(/*! import() */ \"_ssr_src_lib_utils_allPrintingsStorage_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/utils/allPrintingsStorage */ \"(ssr)/./src/lib/utils/allPrintingsStorage.ts\"));\n                const isAvailable = await allPrintingsStorage.isDataAvailable();\n                if (isAvailable) {\n                    console.log('Using stored AllPrintings data as fallback');\n                    // We'll work with the stored data without loading everything into memory\n                    await this.loadMappingCache();\n                    return;\n                }\n            } catch (storageError) {\n                console.error('Failed to access stored AllPrintings data:', storageError);\n            }\n            throw new Error('Failed to load AllPrintings data and no cache available');\n        }\n    }\n    /**\r\n   * Get the MTGJSON UUID for a Scryfall card\r\n   */ async getMapping(scryfallCard) {\n        await this.initialize();\n        // Check cache first\n        const cached = this.mappingCache.get(scryfallCard.id);\n        if (cached) {\n            return cached.mtgjsonUuid;\n        }\n        // Try to find mapping\n        const mapping = await this.findCardMapping(scryfallCard);\n        if (mapping) {\n            // Cache the mapping\n            this.mappingCache.set(scryfallCard.id, mapping);\n            await this.saveMappingToCache(mapping);\n            return mapping.mtgjsonUuid;\n        }\n        return null;\n    }\n    /**\r\n   * Find mapping for a Scryfall card using multiple strategies\r\n   */ async findCardMapping(scryfallCard) {\n        // First try with in-memory AllPrintings data if available\n        if (this.allPrintingsData) {\n            const strategies = [\n                ()=>this.findByDirectScryfallId(scryfallCard),\n                ()=>this.findByNameAndSet(scryfallCard),\n                ()=>this.findByCollectorNumber(scryfallCard),\n                ()=>this.findByFuzzyName(scryfallCard)\n            ];\n            for (const strategy of strategies){\n                const result = strategy();\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        // Fallback to optimized storage search\n        try {\n            const { allPrintingsStorage } = await __webpack_require__.e(/*! import() */ \"_ssr_src_lib_utils_allPrintingsStorage_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/utils/allPrintingsStorage */ \"(ssr)/./src/lib/utils/allPrintingsStorage.ts\"));\n            // Strategy 1: Direct Scryfall ID search\n            if (scryfallCard.scryfallId) {\n                const card = await allPrintingsStorage.findCardByScryfallId(scryfallCard.scryfallId);\n                if (card) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: 1.0,\n                        matchMethod: 'direct',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n            }\n            // Strategy 2: Search by name and try to match with set\n            const searchResults = await allPrintingsStorage.searchCards(scryfallCard.name, 20);\n            for (const card of searchResults){\n                // Exact name and set match\n                if (this.normalizeCardName(card.name) === this.normalizeCardName(scryfallCard.name) && card.setCode.toLowerCase() === scryfallCard.setCode.toLowerCase()) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: 0.95,\n                        matchMethod: 'name_set',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n                // Collector number match within same set\n                if (card.setCode.toLowerCase() === scryfallCard.setCode.toLowerCase() && card.number.toLowerCase() === (scryfallCard.number || '').toLowerCase()) {\n                    const nameSimilarity = this.calculateNameSimilarity(scryfallCard.name, card.name);\n                    if (nameSimilarity > 0.8) {\n                        return {\n                            scryfallId: scryfallCard.id,\n                            mtgjsonUuid: card.uuid,\n                            confidence: 0.9,\n                            matchMethod: 'collector_number',\n                            lastUpdated: new Date().toISOString()\n                        };\n                    }\n                }\n                // Fuzzy name match\n                const similarity = this.calculateNameSimilarity(scryfallCard.name, card.name);\n                if (similarity > 0.9) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: similarity * 0.8,\n                        matchMethod: 'name_fuzzy',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n            }\n        } catch (error) {\n            console.error('Error searching optimized storage:', error);\n        }\n        console.warn(`No mapping found for card: ${scryfallCard.name} (${scryfallCard.setCode})`);\n        return null;\n    }\n    /**\r\n   * Strategy 1: Direct Scryfall ID match (most reliable)\r\n   */ findByDirectScryfallId(scryfallCard) {\n        if (!scryfallCard.scryfallId) return null;\n        for (const set of Object.values(this.allPrintingsData.data)){\n            for (const card of set.cards){\n                if (card.identifiers?.scryfallId === scryfallCard.scryfallId) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: 1.0,\n                        matchMethod: 'direct',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    /**\r\n   * Strategy 2: Match by exact name and set code\r\n   */ findByNameAndSet(scryfallCard) {\n        const normalizedName = this.normalizeCardName(scryfallCard.name);\n        const setCode = scryfallCard.setCode.toLowerCase();\n        for (const set of Object.values(this.allPrintingsData.data)){\n            if (set.code.toLowerCase() !== setCode) continue;\n            for (const card of set.cards){\n                const cardNormalizedName = this.normalizeCardName(card.name);\n                if (cardNormalizedName === normalizedName) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: 0.95,\n                        matchMethod: 'name_set',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    /**\r\n   * Strategy 3: Match by collector number and set\r\n   */ findByCollectorNumber(scryfallCard) {\n        if (!scryfallCard.number) return null;\n        const setCode = scryfallCard.setCode.toLowerCase();\n        const collectorNumber = scryfallCard.number.toLowerCase();\n        for (const set of Object.values(this.allPrintingsData.data)){\n            if (set.code.toLowerCase() !== setCode) continue;\n            for (const card of set.cards){\n                if (card.number.toLowerCase() === collectorNumber) {\n                    // Also check if names are similar to avoid false positives\n                    const nameSimilarity = this.calculateNameSimilarity(scryfallCard.name, card.name);\n                    if (nameSimilarity > 0.8) {\n                        return {\n                            scryfallId: scryfallCard.id,\n                            mtgjsonUuid: card.uuid,\n                            confidence: 0.9,\n                            matchMethod: 'collector_number',\n                            lastUpdated: new Date().toISOString()\n                        };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    /**\r\n   * Strategy 4: Fuzzy name matching (least reliable)\r\n   */ findByFuzzyName(scryfallCard) {\n        const normalizedName = this.normalizeCardName(scryfallCard.name);\n        let bestMatch = null;\n        for (const set of Object.values(this.allPrintingsData.data)){\n            for (const card of set.cards){\n                const cardNormalizedName = this.normalizeCardName(card.name);\n                const similarity = this.calculateNameSimilarity(normalizedName, cardNormalizedName);\n                if (similarity > 0.9 && (!bestMatch || similarity > bestMatch.similarity)) {\n                    bestMatch = {\n                        card,\n                        similarity\n                    };\n                }\n            }\n        }\n        if (bestMatch && bestMatch.similarity > 0.9) {\n            return {\n                scryfallId: scryfallCard.id,\n                mtgjsonUuid: bestMatch.card.uuid,\n                confidence: bestMatch.similarity * 0.8,\n                matchMethod: 'name_fuzzy',\n                lastUpdated: new Date().toISOString()\n            };\n        }\n        return null;\n    }\n    /**\r\n   * Normalize card names for comparison\r\n   */ normalizeCardName(name) {\n        return name.toLowerCase().replace(/[^\\w\\s]/g, '') // Remove special characters\n        .replace(/\\s+/g, ' ') // Normalize whitespace\n        .trim();\n    }\n    /**\r\n   * Calculate similarity between two strings using Levenshtein distance\r\n   */ calculateNameSimilarity(str1, str2) {\n        const len1 = str1.length;\n        const len2 = str2.length;\n        if (len1 === 0) return len2 === 0 ? 1 : 0;\n        if (len2 === 0) return 0;\n        const matrix = [];\n        // Initialize matrix\n        for(let i = 0; i <= len1; i++){\n            matrix[i] = [\n                i\n            ];\n        }\n        for(let j = 0; j <= len2; j++){\n            matrix[0][j] = j;\n        }\n        // Fill matrix\n        for(let i = 1; i <= len1; i++){\n            for(let j = 1; j <= len2; j++){\n                const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + cost // substitution\n                );\n            }\n        }\n        const distance = matrix[len1][len2];\n        const maxLength = Math.max(len1, len2);\n        return 1 - distance / maxLength;\n    }\n    /**\r\n   * Cache AllPrintings data\r\n   */ async cacheAllPrintings(data) {\n        try {\n            // Store in IndexedDB via mtgjsonCache\n            await _lib_utils_mtgjsonCache__WEBPACK_IMPORTED_MODULE_0__.mtgjsonCache.setMetadata({\n                lastPriceUpdate: data.meta.date,\n                totalCards: this.countTotalCards(data),\n                cacheVersion: data.meta.version\n            });\n            // For now, we'll store a subset of the data to avoid storage issues\n            // In production, you might want to use a more sophisticated storage strategy\n            console.log('AllPrintings data cached successfully');\n        } catch (error) {\n            console.error('Failed to cache AllPrintings data:', error);\n        }\n    }\n    /**\r\n   * Get cached AllPrintings data\r\n   */ async getCachedAllPrintings() {\n        try {\n            // This is a placeholder - in reality, you'd need to implement\n            // efficient storage and retrieval of the large AllPrintings dataset\n            return null;\n        } catch (error) {\n            console.error('Failed to get cached AllPrintings:', error);\n            return null;\n        }\n    }\n    /**\r\n   * Load mapping cache from storage\r\n   */ async loadMappingCache() {\n        try {\n            // Load existing mappings from localStorage or IndexedDB\n            const cached = localStorage.getItem(this.MAPPING_CACHE_KEY);\n            if (cached) {\n                const mappings = JSON.parse(cached);\n                for (const mapping of mappings){\n                    this.mappingCache.set(mapping.scryfallId, mapping);\n                }\n                console.log(`Loaded ${mappings.length} cached mappings`);\n            }\n        } catch (error) {\n            console.error('Failed to load mapping cache:', error);\n        }\n    }\n    /**\r\n   * Save a single mapping to cache\r\n   */ async saveMappingToCache(mapping) {\n        try {\n            // Save to localStorage (for now)\n            const existingMappings = this.getAllCachedMappings();\n            const updatedMappings = existingMappings.filter((m)=>m.scryfallId !== mapping.scryfallId);\n            updatedMappings.push(mapping);\n            localStorage.setItem(this.MAPPING_CACHE_KEY, JSON.stringify(updatedMappings));\n        } catch (error) {\n            console.error('Failed to save mapping to cache:', error);\n        }\n    }\n    /**\r\n   * Get all cached mappings\r\n   */ getAllCachedMappings() {\n        try {\n            const cached = localStorage.getItem(this.MAPPING_CACHE_KEY);\n            return cached ? JSON.parse(cached) : [];\n        } catch (error) {\n            console.error('Failed to get cached mappings:', error);\n            return [];\n        }\n    }\n    /**\r\n   * Check if data is fresh (within 7 days)\r\n   */ isDataFresh(dateString) {\n        const dataDate = new Date(dateString);\n        const now = new Date();\n        const daysDiff = (now.getTime() - dataDate.getTime()) / (1000 * 60 * 60 * 24);\n        return daysDiff < 7;\n    }\n    /**\r\n   * Count total cards in AllPrintings data\r\n   */ countTotalCards(data) {\n        return Object.values(data.data).reduce((total, set)=>total + set.cards.length, 0);\n    }\n    /**\r\n   * Get mapping statistics\r\n   */ async getMappingStats() {\n        const cachedMappings = this.getAllCachedMappings();\n        return {\n            totalMappings: cachedMappings.length,\n            directMatches: cachedMappings.filter((m)=>m.matchMethod === 'direct').length,\n            fuzzyMatches: cachedMappings.filter((m)=>m.matchMethod === 'name_fuzzy').length,\n            unmappedCards: 0,\n            lastUpdate: cachedMappings.length > 0 ? Math.max(...cachedMappings.map((m)=>new Date(m.lastUpdated).getTime())).toString() : new Date().toISOString()\n        };\n    }\n    /**\r\n   * Clear all cached mappings\r\n   */ async clearMappingCache() {\n        this.mappingCache.clear();\n        localStorage.removeItem(this.MAPPING_CACHE_KEY);\n        console.log('Mapping cache cleared');\n    }\n    /**\r\n   * Batch process multiple cards for mapping\r\n   */ async batchGetMappings(scryfallCards) {\n        await this.initialize();\n        const results = new Map();\n        for (const card of scryfallCards){\n            try {\n                const uuid = await this.getMapping(card);\n                if (uuid) {\n                    results.set(card.id, uuid);\n                }\n            } catch (error) {\n                console.error(`Failed to map card ${card.name}:`, error);\n            }\n        }\n        return results;\n    }\n    constructor(){\n        this.allPrintingsData = null;\n        this.mappingCache = new Map();\n        this.loadingPromise = null;\n        // MTGJSON AllPrintings.json URL\n        this.MTGJSON_ALL_PRINTINGS_URL = 'https://mtgjson.com/api/v5/AllPrintings.json';\n        this.CACHE_KEY = 'mtgjson-all-printings';\n        this.MAPPING_CACHE_KEY = 'card-mappings';\n    }\n}\n// Export singleton instance\nconst cardMappingService = new CardMappingService();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvbGliL3NlcnZpY2VzL2NhcmRNYXBwaW5nU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUN3RDtBQXNEeEQsTUFBTUM7SUFVSjs7R0FFQyxHQUNELE1BQU1DLGFBQTRCO1FBQ2hDLElBQUksSUFBSSxDQUFDQyxjQUFjLEVBQUU7WUFDdkIsT0FBTyxJQUFJLENBQUNBLGNBQWM7UUFDNUI7UUFFQSxJQUFJLENBQUNBLGNBQWMsR0FBRyxJQUFJLENBQUNDLG9CQUFvQjtRQUMvQyxPQUFPLElBQUksQ0FBQ0QsY0FBYztJQUM1QjtJQUVBOztHQUVDLEdBQ0QsTUFBY0MsdUJBQXNDO1FBQ2xELElBQUk7WUFDRkMsUUFBUUMsR0FBRyxDQUFDO1lBRVosK0JBQStCO1lBQy9CLE1BQU1DLFNBQVMsTUFBTSxJQUFJLENBQUNDLHFCQUFxQjtZQUMvQyxJQUFJRCxVQUFVLElBQUksQ0FBQ0UsV0FBVyxDQUFDRixPQUFPRyxJQUFJLENBQUNDLElBQUksR0FBRztnQkFDaEQsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0w7Z0JBQ3hCRixRQUFRQyxHQUFHLENBQUM7Z0JBQ1osTUFBTSxJQUFJLENBQUNPLGdCQUFnQjtnQkFDM0I7WUFDRjtZQUVBLGdDQUFnQztZQUNoQ1IsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTVEsV0FBVyxNQUFNQyxNQUFNLElBQUksQ0FBQ0MseUJBQXlCO1lBRTNELElBQUksQ0FBQ0YsU0FBU0csRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUlDLE1BQU0sQ0FBQyw4QkFBOEIsRUFBRUosU0FBU0ssTUFBTSxDQUFDLENBQUMsRUFBRUwsU0FBU00sVUFBVSxFQUFFO1lBQzNGO1lBRUEscUJBQXFCO1lBQ3JCLE1BQU1DLE9BQTRCLE1BQU1QLFNBQVNRLElBQUk7WUFFckQsSUFBSSxDQUFDRCxLQUFLQSxJQUFJLElBQUksQ0FBQ0EsS0FBS1gsSUFBSSxFQUFFO2dCQUM1QixNQUFNLElBQUlRLE1BQU07WUFDbEI7WUFFQSxJQUFJLENBQUNO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QkFBb0I7O0FBb2Z2QztBQUVBLDRCQUE0QjtBQUNyQixNQUFNb0MscUJBQXFCLElBQUl4SSxxQkFBcUIiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcbXRnLWluZGV4XFxzcmNcXGxpYlxcc2VydmljZXNcXGNhcmRNYXBwaW5nU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNVEdDYXJkLCBNVEdKU09OQ2FyZCB9IGZyb20gJ0AvbGliL3R5cGVzJztcclxuaW1wb3J0IHsgbXRnanNvbkNhY2hlIH0gZnJvbSAnQC9saWIvdXRpbHMvbXRnanNvbkNhY2hlJztcclxuXHJcbi8vIE1UR0pTT04gQWxsUHJpbnRpbmdzIGRhdGEgc3RydWN0dXJlXHJcbmludGVyZmFjZSBNVEdKU09OU2V0IHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgY29kZTogc3RyaW5nO1xyXG4gIGNhcmRzOiBNVEdKU09OQ2FyZERhdGFbXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIE1UR0pTT05DYXJkRGF0YSB7XHJcbiAgdXVpZDogc3RyaW5nO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBzZXRDb2RlOiBzdHJpbmc7XHJcbiAgbnVtYmVyOiBzdHJpbmc7XHJcbiAgcmFyaXR5OiBzdHJpbmc7XHJcbiAgY29sb3JzPzogc3RyaW5nW107XHJcbiAgY29sb3JJZGVudGl0eT86IHN0cmluZ1tdO1xyXG4gIG1hbmFDb3N0Pzogc3RyaW5nO1xyXG4gIGNvbnZlcnRlZE1hbmFDb3N0PzogbnVtYmVyO1xyXG4gIHR5cGU/OiBzdHJpbmc7XHJcbiAgc3VidHlwZXM/OiBzdHJpbmdbXTtcclxuICBzdXBlcnR5cGVzPzogc3RyaW5nW107XHJcbiAgYXJ0aXN0Pzogc3RyaW5nO1xyXG4gIGlkZW50aWZpZXJzPzoge1xyXG4gICAgc2NyeWZhbGxJZD86IHN0cmluZztcclxuICAgIG11bHRpdmVyc2VJZD86IG51bWJlcjtcclxuICAgIG10Z2pzb25WNElkPzogc3RyaW5nO1xyXG4gIH07XHJcbn1cclxuXHJcbmludGVyZmFjZSBNVEdKU09OQWxsUHJpbnRpbmdzIHtcclxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBNVEdKU09OU2V0PjtcclxuICBtZXRhOiB7XHJcbiAgICBkYXRlOiBzdHJpbmc7XHJcbiAgICB2ZXJzaW9uOiBzdHJpbmc7XHJcbiAgfTtcclxufVxyXG5cclxuaW50ZXJmYWNlIENhcmRNYXBwaW5nIHtcclxuICBzY3J5ZmFsbElkOiBzdHJpbmc7XHJcbiAgbXRnanNvblV1aWQ6IHN0cmluZztcclxuICBjb25maWRlbmNlOiBudW1iZXI7IC8vIDAtMSBzY29yZSBvZiBtYXBwaW5nIGNvbmZpZGVuY2VcclxuICBtYXRjaE1ldGhvZDogJ2RpcmVjdCcgfCAnbmFtZV9zZXQnIHwgJ25hbWVfZnV6enknIHwgJ2NvbGxlY3Rvcl9udW1iZXInIHwgJ21hbnVhbCc7XHJcbiAgbGFzdFVwZGF0ZWQ6IHN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIE1hcHBpbmdTdGF0cyB7XHJcbiAgdG90YWxNYXBwaW5nczogbnVtYmVyO1xyXG4gIGRpcmVjdE1hdGNoZXM6IG51bWJlcjtcclxuICBmdXp6eU1hdGNoZXM6IG51bWJlcjtcclxuICB1bm1hcHBlZENhcmRzOiBudW1iZXI7XHJcbiAgbGFzdFVwZGF0ZTogc3RyaW5nO1xyXG59XHJcblxyXG5jbGFzcyBDYXJkTWFwcGluZ1NlcnZpY2Uge1xyXG4gIHByaXZhdGUgYWxsUHJpbnRpbmdzRGF0YTogTVRHSlNPTkFsbFByaW50aW5ncyB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgbWFwcGluZ0NhY2hlID0gbmV3IE1hcDxzdHJpbmcsIENhcmRNYXBwaW5nPigpO1xyXG4gIHByaXZhdGUgbG9hZGluZ1Byb21pc2U6IFByb21pc2U8dm9pZD4gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgLy8gTVRHSlNPTiBBbGxQcmludGluZ3MuanNvbiBVUkxcclxuICBwcml2YXRlIHJlYWRvbmx5IE1UR0pTT05fQUxMX1BSSU5USU5HU19VUkwgPSAnaHR0cHM6Ly9tdGdqc29uLmNvbS9hcGkvdjUvQWxsUHJpbnRpbmdzLmpzb24nO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgQ0FDSEVfS0VZID0gJ210Z2pzb24tYWxsLXByaW50aW5ncyc7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBNQVBQSU5HX0NBQ0hFX0tFWSA9ICdjYXJkLW1hcHBpbmdzJztcclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBzZXJ2aWNlIGJ5IGxvYWRpbmcgQWxsUHJpbnRpbmdzIGRhdGFcclxuICAgKi9cclxuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKHRoaXMubG9hZGluZ1Byb21pc2UpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubG9hZGluZ1Byb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5sb2FkaW5nUHJvbWlzZSA9IHRoaXMubG9hZEFsbFByaW50aW5nc0RhdGEoKTtcclxuICAgIHJldHVybiB0aGlzLmxvYWRpbmdQcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZCBhbmQgY2FjaGUgQWxsUHJpbnRpbmdzLmpzb24gZGF0YVxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgbG9hZEFsbFByaW50aW5nc0RhdGEoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnTG9hZGluZyBNVEdKU09OIEFsbFByaW50aW5ncyBkYXRhLi4uJyk7XHJcblxyXG4gICAgICAvLyBUcnkgdG8gbG9hZCBmcm9tIGNhY2hlIGZpcnN0XHJcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGF3YWl0IHRoaXMuZ2V0Q2FjaGVkQWxsUHJpbnRpbmdzKCk7XHJcbiAgICAgIGlmIChjYWNoZWQgJiYgdGhpcy5pc0RhdGFGcmVzaChjYWNoZWQubWV0YS5kYXRlKSkge1xyXG4gICAgICAgIHRoaXMuYWxsUHJpbnRpbmdzRGF0YSA9IGNhY2hlZDtcclxuICAgICAgICBjb25zb2xlLmxvZygnTG9hZGVkIEFsbFByaW50aW5ncyBmcm9tIGNhY2hlJyk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFwcGluZ0NhY2hlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGZXRjaCBmcmVzaCBkYXRhIGZyb20gTVRHSlNPTlxyXG4gICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgZnJlc2ggQWxsUHJpbnRpbmdzIGRhdGEgZnJvbSBNVEdKU09OLi4uJyk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5NVEdKU09OX0FMTF9QUklOVElOR1NfVVJMKTtcclxuICAgICAgXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBBbGxQcmludGluZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFBhcnNlIHRoZSByZXNwb25zZVxyXG4gICAgICBjb25zdCBkYXRhOiBNVEdKU09OQWxsUHJpbnRpbmdzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFkYXRhLmRhdGEgfHwgIWRhdGEubWV0YSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBBbGxQcmludGluZ3MgcmVzcG9uc2UgZm9ybWF0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHRoaXMuYWxsUHJpbnRpbmdzRGF0YSA9IGRhdGE7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdG9yZSB1c2luZyB0aGUgb3B0aW1pemVkIHN0b3JhZ2Ugc3lzdGVtXHJcbiAgICAgIGNvbnN0IHsgYWxsUHJpbnRpbmdzU3RvcmFnZSB9ID0gYXdhaXQgaW1wb3J0KCdAL2xpYi91dGlscy9hbGxQcmludGluZ3NTdG9yYWdlJyk7XHJcbiAgICAgIGF3YWl0IGFsbFByaW50aW5nc1N0b3JhZ2Uuc3RvcmVBbGxQcmludGluZ3MoZGF0YSk7XHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCB0aGlzLmxvYWRNYXBwaW5nQ2FjaGUoKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGBMb2FkZWQgJHtPYmplY3Qua2V5cyhkYXRhLmRhdGEpLmxlbmd0aH0gc2V0cyBmcm9tIE1UR0pTT05gKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIEFsbFByaW50aW5ncyBkYXRhOicsIGVycm9yKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFRyeSB0byB1c2Ugb3B0aW1pemVkIHN0b3JhZ2UgYXMgZmFsbGJhY2tcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGFsbFByaW50aW5nc1N0b3JhZ2UgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvdXRpbHMvYWxsUHJpbnRpbmdzU3RvcmFnZScpO1xyXG4gICAgICAgIGNvbnN0IGlzQXZhaWxhYmxlID0gYXdhaXQgYWxsUHJpbnRpbmdzU3RvcmFnZS5pc0RhdGFBdmFpbGFibGUoKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoaXNBdmFpbGFibGUpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBzdG9yZWQgQWxsUHJpbnRpbmdzIGRhdGEgYXMgZmFsbGJhY2snKTtcclxuICAgICAgICAgIC8vIFdlJ2xsIHdvcmsgd2l0aCB0aGUgc3RvcmVkIGRhdGEgd2l0aG91dCBsb2FkaW5nIGV2ZXJ5dGhpbmcgaW50byBtZW1vcnlcclxuICAgICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcHBpbmdDYWNoZSgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoc3RvcmFnZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGFjY2VzcyBzdG9yZWQgQWxsUHJpbnRpbmdzIGRhdGE6Jywgc3RvcmFnZUVycm9yKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBBbGxQcmludGluZ3MgZGF0YSBhbmQgbm8gY2FjaGUgYXZhaWxhYmxlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIE1UR0pTT04gVVVJRCBmb3IgYSBTY3J5ZmFsbCBjYXJkXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0TWFwcGluZyhzY3J5ZmFsbENhcmQ6IE1UR0NhcmQpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XHJcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLm1hcHBpbmdDYWNoZS5nZXQoc2NyeWZhbGxDYXJkLmlkKTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgcmV0dXJuIGNhY2hlZC5tdGdqc29uVXVpZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcnkgdG8gZmluZCBtYXBwaW5nXHJcbiAgICBjb25zdCBtYXBwaW5nID0gYXdhaXQgdGhpcy5maW5kQ2FyZE1hcHBpbmcoc2NyeWZhbGxDYXJkKTtcclxuICAgIGlmIChtYXBwaW5nKSB7XHJcbiAgICAgIC8vIENhY2hlIHRoZSBtYXBwaW5nXHJcbiAgICAgIHRoaXMubWFwcGluZ0NhY2hlLnNldChzY3J5ZmFsbENhcmQuaWQsIG1hcHBpbmcpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNhdmVNYXBwaW5nVG9DYWNoZShtYXBwaW5nKTtcclxuICAgICAgcmV0dXJuIG1hcHBpbmcubXRnanNvblV1aWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kIG1hcHBpbmcgZm9yIGEgU2NyeWZhbGwgY2FyZCB1c2luZyBtdWx0aXBsZSBzdHJhdGVnaWVzXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBmaW5kQ2FyZE1hcHBpbmcoc2NyeWZhbGxDYXJkOiBNVEdDYXJkKTogUHJvbWlzZTxDYXJkTWFwcGluZyB8IG51bGw+IHtcclxuICAgIC8vIEZpcnN0IHRyeSB3aXRoIGluLW1lbW9yeSBBbGxQcmludGluZ3MgZGF0YSBpZiBhdmFpbGFibGVcclxuICAgIGlmICh0aGlzLmFsbFByaW50aW5nc0RhdGEpIHtcclxuICAgICAgY29uc3Qgc3RyYXRlZ2llcyA9IFtcclxuICAgICAgICAoKSA9PiB0aGlzLmZpbmRCeURpcmVjdFNjcnlmYWxsSWQoc2NyeWZhbGxDYXJkKSxcclxuICAgICAgICAoKSA9PiB0aGlzLmZpbmRCeU5hbWVBbmRTZXQoc2NyeWZhbGxDYXJkKSxcclxuICAgICAgICAoKSA9PiB0aGlzLmZpbmRCeUNvbGxlY3Rvck51bWJlcihzY3J5ZmFsbENhcmQpLFxyXG4gICAgICAgICgpID0+IHRoaXMuZmluZEJ5RnV6enlOYW1lKHNjcnlmYWxsQ2FyZCksXHJcbiAgICAgIF07XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IHN0cmF0ZWd5IG9mIHN0cmF0ZWdpZXMpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdHJhdGVneSgpO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmFsbGJhY2sgdG8gb3B0aW1pemVkIHN0b3JhZ2Ugc2VhcmNoXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGFsbFByaW50aW5nc1N0b3JhZ2UgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvdXRpbHMvYWxsUHJpbnRpbmdzU3RvcmFnZScpO1xyXG4gICAgICBcclxuICAgICAgLy8gU3RyYXRlZ3kgMTogRGlyZWN0IFNjcnlmYWxsIElEIHNlYXJjaFxyXG4gICAgICBpZiAoc2NyeWZhbGxDYXJkLnNjcnlmYWxsSWQpIHtcclxuICAgICAgICBjb25zdCBjYXJkID0gYXdhaXQgYWxsUHJpbnRpbmdzU3RvcmFnZS5maW5kQ2FyZEJ5U2NyeWZhbGxJZChzY3J5ZmFsbENhcmQuc2NyeWZhbGxJZCk7XHJcbiAgICAgICAgaWYgKGNhcmQpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNjcnlmYWxsSWQ6IHNjcnlmYWxsQ2FyZC5pZCxcclxuICAgICAgICAgICAgbXRnanNvblV1aWQ6IGNhcmQudXVpZCxcclxuICAgICAgICAgICAgY29uZmlkZW5jZTogMS4wLFxyXG4gICAgICAgICAgICBtYXRjaE1ldGhvZDogJ2RpcmVjdCcsXHJcbiAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU3RyYXRlZ3kgMjogU2VhcmNoIGJ5IG5hbWUgYW5kIHRyeSB0byBtYXRjaCB3aXRoIHNldFxyXG4gICAgICBjb25zdCBzZWFyY2hSZXN1bHRzID0gYXdhaXQgYWxsUHJpbnRpbmdzU3RvcmFnZS5zZWFyY2hDYXJkcyhzY3J5ZmFsbENhcmQubmFtZSwgMjApO1xyXG4gICAgICBcclxuICAgICAgZm9yIChjb25zdCBjYXJkIG9mIHNlYXJjaFJlc3VsdHMpIHtcclxuICAgICAgICAvLyBFeGFjdCBuYW1lIGFuZCBzZXQgbWF0Y2hcclxuICAgICAgICBpZiAodGhpcy5ub3JtYWxpemVDYXJkTmFtZShjYXJkLm5hbWUpID09PSB0aGlzLm5vcm1hbGl6ZUNhcmROYW1lKHNjcnlmYWxsQ2FyZC5uYW1lKSAmJlxyXG4gICAgICAgICAgICBjYXJkLnNldENvZGUudG9Mb3dlckNhc2UoKSA9PT0gc2NyeWZhbGxDYXJkLnNldENvZGUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2NyeWZhbGxJZDogc2NyeWZhbGxDYXJkLmlkLFxyXG4gICAgICAgICAgICBtdGdqc29uVXVpZDogY2FyZC51dWlkLFxyXG4gICAgICAgICAgICBjb25maWRlbmNlOiAwLjk1LFxyXG4gICAgICAgICAgICBtYXRjaE1ldGhvZDogJ25hbWVfc2V0JyxcclxuICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb2xsZWN0b3IgbnVtYmVyIG1hdGNoIHdpdGhpbiBzYW1lIHNldFxyXG4gICAgICAgIGlmIChjYXJkLnNldENvZGUudG9Mb3dlckNhc2UoKSA9PT0gc2NyeWZhbGxDYXJkLnNldENvZGUudG9Mb3dlckNhc2UoKSAmJlxyXG4gICAgICAgICAgICBjYXJkLm51bWJlci50b0xvd2VyQ2FzZSgpID09PSAoc2NyeWZhbGxDYXJkLm51bWJlciB8fCAnJykudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgY29uc3QgbmFtZVNpbWlsYXJpdHkgPSB0aGlzLmNhbGN1bGF0ZU5hbWVTaW1pbGFyaXR5KHNjcnlmYWxsQ2FyZC5uYW1lLCBjYXJkLm5hbWUpO1xyXG4gICAgICAgICAgaWYgKG5hbWVTaW1pbGFyaXR5ID4gMC44KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgc2NyeWZhbGxJZDogc2NyeWZhbGxDYXJkLmlkLFxyXG4gICAgICAgICAgICAgIG10Z2pzb25VdWlkOiBjYXJkLnV1aWQsXHJcbiAgICAgICAgICAgICAgY29uZmlkZW5jZTogMC45LFxyXG4gICAgICAgICAgICAgIG1hdGNoTWV0aG9kOiAnY29sbGVjdG9yX251bWJlcicsXHJcbiAgICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZ1enp5IG5hbWUgbWF0Y2hcclxuICAgICAgICBjb25zdCBzaW1pbGFyaXR5ID0gdGhpcy5jYWxjdWxhdGVOYW1lU2ltaWxhcml0eShzY3J5ZmFsbENhcmQubmFtZSwgY2FyZC5uYW1lKTtcclxuICAgICAgICBpZiAoc2ltaWxhcml0eSA+IDAuOSkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2NyeWZhbGxJZDogc2NyeWZhbGxDYXJkLmlkLFxyXG4gICAgICAgICAgICBtdGdqc29uVXVpZDogY2FyZC51dWlkLFxyXG4gICAgICAgICAgICBjb25maWRlbmNlOiBzaW1pbGFyaXR5ICogMC44LFxyXG4gICAgICAgICAgICBtYXRjaE1ldGhvZDogJ25hbWVfZnV6enknLFxyXG4gICAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNlYXJjaGluZyBvcHRpbWl6ZWQgc3RvcmFnZTonLCBlcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS53YXJuKGBObyBtYXBwaW5nIGZvdW5kIGZvciBjYXJkOiAke3NjcnlmYWxsQ2FyZC5uYW1lfSAoJHtzY3J5ZmFsbENhcmQuc2V0Q29kZX0pYCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0cmF0ZWd5IDE6IERpcmVjdCBTY3J5ZmFsbCBJRCBtYXRjaCAobW9zdCByZWxpYWJsZSlcclxuICAgKi9cclxuICBwcml2YXRlIGZpbmRCeURpcmVjdFNjcnlmYWxsSWQoc2NyeWZhbGxDYXJkOiBNVEdDYXJkKTogQ2FyZE1hcHBpbmcgfCBudWxsIHtcclxuICAgIGlmICghc2NyeWZhbGxDYXJkLnNjcnlmYWxsSWQpIHJldHVybiBudWxsO1xyXG5cclxuICAgIGZvciAoY29uc3Qgc2V0IG9mIE9iamVjdC52YWx1ZXModGhpcy5hbGxQcmludGluZ3NEYXRhIS5kYXRhKSkge1xyXG4gICAgICBmb3IgKGNvbnN0IGNhcmQgb2Ygc2V0LmNhcmRzKSB7XHJcbiAgICAgICAgaWYgKGNhcmQuaWRlbnRpZmllcnM/LnNjcnlmYWxsSWQgPT09IHNjcnlmYWxsQ2FyZC5zY3J5ZmFsbElkKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzY3J5ZmFsbElkOiBzY3J5ZmFsbENhcmQuaWQsXHJcbiAgICAgICAgICAgIG10Z2pzb25VdWlkOiBjYXJkLnV1aWQsXHJcbiAgICAgICAgICAgIGNvbmZpZGVuY2U6IDEuMCxcclxuICAgICAgICAgICAgbWF0Y2hNZXRob2Q6ICdkaXJlY3QnLFxyXG4gICAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0cmF0ZWd5IDI6IE1hdGNoIGJ5IGV4YWN0IG5hbWUgYW5kIHNldCBjb2RlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBmaW5kQnlOYW1lQW5kU2V0KHNjcnlmYWxsQ2FyZDogTVRHQ2FyZCk6IENhcmRNYXBwaW5nIHwgbnVsbCB7XHJcbiAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IHRoaXMubm9ybWFsaXplQ2FyZE5hbWUoc2NyeWZhbGxDYXJkLm5hbWUpO1xyXG4gICAgY29uc3Qgc2V0Q29kZSA9IHNjcnlmYWxsQ2FyZC5zZXRDb2RlLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgZm9yIChjb25zdCBzZXQgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmFsbFByaW50aW5nc0RhdGEhLmRhdGEpKSB7XHJcbiAgICAgIGlmIChzZXQuY29kZS50b0xvd2VyQ2FzZSgpICE9PSBzZXRDb2RlKSBjb250aW51ZTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY2FyZCBvZiBzZXQuY2FyZHMpIHtcclxuICAgICAgICBjb25zdCBjYXJkTm9ybWFsaXplZE5hbWUgPSB0aGlzLm5vcm1hbGl6ZUNhcmROYW1lKGNhcmQubmFtZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNhcmROb3JtYWxpemVkTmFtZSA9PT0gbm9ybWFsaXplZE5hbWUpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNjcnlmYWxsSWQ6IHNjcnlmYWxsQ2FyZC5pZCxcclxuICAgICAgICAgICAgbXRnanNvblV1aWQ6IGNhcmQudXVpZCxcclxuICAgICAgICAgICAgY29uZmlkZW5jZTogMC45NSxcclxuICAgICAgICAgICAgbWF0Y2hNZXRob2Q6ICduYW1lX3NldCcsXHJcbiAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RyYXRlZ3kgMzogTWF0Y2ggYnkgY29sbGVjdG9yIG51bWJlciBhbmQgc2V0XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBmaW5kQnlDb2xsZWN0b3JOdW1iZXIoc2NyeWZhbGxDYXJkOiBNVEdDYXJkKTogQ2FyZE1hcHBpbmcgfCBudWxsIHtcclxuICAgIGlmICghc2NyeWZhbGxDYXJkLm51bWJlcikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgY29uc3Qgc2V0Q29kZSA9IHNjcnlmYWxsQ2FyZC5zZXRDb2RlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBjb25zdCBjb2xsZWN0b3JOdW1iZXIgPSBzY3J5ZmFsbENhcmQubnVtYmVyLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgZm9yIChjb25zdCBzZXQgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmFsbFByaW50aW5nc0RhdGEhLmRhdGEpKSB7XHJcbiAgICAgIGlmIChzZXQuY29kZS50b0xvd2VyQ2FzZSgpICE9PSBzZXRDb2RlKSBjb250aW51ZTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY2FyZCBvZiBzZXQuY2FyZHMpIHtcclxuICAgICAgICBpZiAoY2FyZC5udW1iZXIudG9Mb3dlckNhc2UoKSA9PT0gY29sbGVjdG9yTnVtYmVyKSB7XHJcbiAgICAgICAgICAvLyBBbHNvIGNoZWNrIGlmIG5hbWVzIGFyZSBzaW1pbGFyIHRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlc1xyXG4gICAgICAgICAgY29uc3QgbmFtZVNpbWlsYXJpdHkgPSB0aGlzLmNhbGN1bGF0ZU5hbWVTaW1pbGFyaXR5KHNjcnlmYWxsQ2FyZC5uYW1lLCBjYXJkLm5hbWUpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAobmFtZVNpbWlsYXJpdHkgPiAwLjgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICBzY3J5ZmFsbElkOiBzY3J5ZmFsbENhcmQuaWQsXHJcbiAgICAgICAgICAgICAgbXRnanNvblV1aWQ6IGNhcmQudXVpZCxcclxuICAgICAgICAgICAgICBjb25maWRlbmNlOiAwLjksXHJcbiAgICAgICAgICAgICAgbWF0Y2hNZXRob2Q6ICdjb2xsZWN0b3JfbnVtYmVyJyxcclxuICAgICAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RyYXRlZ3kgNDogRnV6enkgbmFtZSBtYXRjaGluZyAobGVhc3QgcmVsaWFibGUpXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBmaW5kQnlGdXp6eU5hbWUoc2NyeWZhbGxDYXJkOiBNVEdDYXJkKTogQ2FyZE1hcHBpbmcgfCBudWxsIHtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gdGhpcy5ub3JtYWxpemVDYXJkTmFtZShzY3J5ZmFsbENhcmQubmFtZSk7XHJcbiAgICBsZXQgYmVzdE1hdGNoOiB7IGNhcmQ6IE1UR0pTT05DYXJkRGF0YTsgc2ltaWxhcml0eTogbnVtYmVyIH0gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHNldCBvZiBPYmplY3QudmFsdWVzKHRoaXMuYWxsUHJpbnRpbmdzRGF0YSEuZGF0YSkpIHtcclxuICAgICAgZm9yIChjb25zdCBjYXJkIG9mIHNldC5jYXJkcykge1xyXG4gICAgICAgIGNvbnN0IGNhcmROb3JtYWxpemVkTmFtZSA9IHRoaXMubm9ybWFsaXplQ2FyZE5hbWUoY2FyZC5uYW1lKTtcclxuICAgICAgICBjb25zdCBzaW1pbGFyaXR5ID0gdGhpcy5jYWxjdWxhdGVOYW1lU2ltaWxhcml0eShub3JtYWxpemVkTmFtZSwgY2FyZE5vcm1hbGl6ZWROYW1lKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoc2ltaWxhcml0eSA+IDAuOSAmJiAoIWJlc3RNYXRjaCB8fCBzaW1pbGFyaXR5ID4gYmVzdE1hdGNoLnNpbWlsYXJpdHkpKSB7XHJcbiAgICAgICAgICBiZXN0TWF0Y2ggPSB7IGNhcmQsIHNpbWlsYXJpdHkgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoYmVzdE1hdGNoICYmIGJlc3RNYXRjaC5zaW1pbGFyaXR5ID4gMC45KSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc2NyeWZhbGxJZDogc2NyeWZhbGxDYXJkLmlkLFxyXG4gICAgICAgIG10Z2pzb25VdWlkOiBiZXN0TWF0Y2guY2FyZC51dWlkLFxyXG4gICAgICAgIGNvbmZpZGVuY2U6IGJlc3RNYXRjaC5zaW1pbGFyaXR5ICogMC44LCAvLyBSZWR1Y2UgY29uZmlkZW5jZSBmb3IgZnV6enkgbWF0Y2hlc1xyXG4gICAgICAgIG1hdGNoTWV0aG9kOiAnbmFtZV9mdXp6eScsXHJcbiAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZSBjYXJkIG5hbWVzIGZvciBjb21wYXJpc29uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBub3JtYWxpemVDYXJkTmFtZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIG5hbWVcclxuICAgICAgLnRvTG93ZXJDYXNlKClcclxuICAgICAgLnJlcGxhY2UoL1teXFx3XFxzXS9nLCAnJykgLy8gUmVtb3ZlIHNwZWNpYWwgY2hhcmFjdGVyc1xyXG4gICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpIC8vIE5vcm1hbGl6ZSB3aGl0ZXNwYWNlXHJcbiAgICAgIC50cmltKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgc2ltaWxhcml0eSBiZXR3ZWVuIHR3byBzdHJpbmdzIHVzaW5nIExldmVuc2h0ZWluIGRpc3RhbmNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVOYW1lU2ltaWxhcml0eShzdHIxOiBzdHJpbmcsIHN0cjI6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICBjb25zdCBsZW4xID0gc3RyMS5sZW5ndGg7XHJcbiAgICBjb25zdCBsZW4yID0gc3RyMi5sZW5ndGg7XHJcbiAgICBcclxuICAgIGlmIChsZW4xID09PSAwKSByZXR1cm4gbGVuMiA9PT0gMCA/IDEgOiAwO1xyXG4gICAgaWYgKGxlbjIgPT09IDApIHJldHVybiAwO1xyXG5cclxuICAgIGNvbnN0IG1hdHJpeDogbnVtYmVyW11bXSA9IFtdO1xyXG4gICAgXHJcbiAgICAvLyBJbml0aWFsaXplIG1hdHJpeFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGVuMTsgaSsrKSB7XHJcbiAgICAgIG1hdHJpeFtpXSA9IFtpXTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGogPSAwOyBqIDw9IGxlbjI7IGorKykge1xyXG4gICAgICBtYXRyaXhbMF1bal0gPSBqO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbGwgbWF0cml4XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBsZW4xOyBpKyspIHtcclxuICAgICAgZm9yIChsZXQgaiA9IDE7IGogPD0gbGVuMjsgaisrKSB7XHJcbiAgICAgICAgY29uc3QgY29zdCA9IHN0cjFbaSAtIDFdID09PSBzdHIyW2ogLSAxXSA/IDAgOiAxO1xyXG4gICAgICAgIG1hdHJpeFtpXVtqXSA9IE1hdGgubWluKFxyXG4gICAgICAgICAgbWF0cml4W2kgLSAxXVtqXSArIDEsICAgICAvLyBkZWxldGlvblxyXG4gICAgICAgICAgbWF0cml4W2ldW2ogLSAxXSArIDEsICAgICAvLyBpbnNlcnRpb25cclxuICAgICAgICAgIG1hdHJpeFtpIC0gMV1baiAtIDFdICsgY29zdCAvLyBzdWJzdGl0dXRpb25cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGlzdGFuY2UgPSBtYXRyaXhbbGVuMV1bbGVuMl07XHJcbiAgICBjb25zdCBtYXhMZW5ndGggPSBNYXRoLm1heChsZW4xLCBsZW4yKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIDEgLSAoZGlzdGFuY2UgLyBtYXhMZW5ndGgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FjaGUgQWxsUHJpbnRpbmdzIGRhdGFcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGNhY2hlQWxsUHJpbnRpbmdzKGRhdGE6IE1UR0pTT05BbGxQcmludGluZ3MpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFN0b3JlIGluIEluZGV4ZWREQiB2aWEgbXRnanNvbkNhY2hlXHJcbiAgICAgIGF3YWl0IG10Z2pzb25DYWNoZS5zZXRNZXRhZGF0YSh7XHJcbiAgICAgICAgbGFzdFByaWNlVXBkYXRlOiBkYXRhLm1ldGEuZGF0ZSxcclxuICAgICAgICB0b3RhbENhcmRzOiB0aGlzLmNvdW50VG90YWxDYXJkcyhkYXRhKSxcclxuICAgICAgICBjYWNoZVZlcnNpb246IGRhdGEubWV0YS52ZXJzaW9uLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIHN0b3JlIGEgc3Vic2V0IG9mIHRoZSBkYXRhIHRvIGF2b2lkIHN0b3JhZ2UgaXNzdWVzXHJcbiAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHlvdSBtaWdodCB3YW50IHRvIHVzZSBhIG1vcmUgc29waGlzdGljYXRlZCBzdG9yYWdlIHN0cmF0ZWd5XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBbGxQcmludGluZ3MgZGF0YSBjYWNoZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2FjaGUgQWxsUHJpbnRpbmdzIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGNhY2hlZCBBbGxQcmludGluZ3MgZGF0YVxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgZ2V0Q2FjaGVkQWxsUHJpbnRpbmdzKCk6IFByb21pc2U8TVRHSlNPTkFsbFByaW50aW5ncyB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFRoaXMgaXMgYSBwbGFjZWhvbGRlciAtIGluIHJlYWxpdHksIHlvdSdkIG5lZWQgdG8gaW1wbGVtZW50XHJcbiAgICAgIC8vIGVmZmljaWVudCBzdG9yYWdlIGFuZCByZXRyaWV2YWwgb2YgdGhlIGxhcmdlIEFsbFByaW50aW5ncyBkYXRhc2V0XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBjYWNoZWQgQWxsUHJpbnRpbmdzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIG1hcHBpbmcgY2FjaGUgZnJvbSBzdG9yYWdlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBsb2FkTWFwcGluZ0NhY2hlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gTG9hZCBleGlzdGluZyBtYXBwaW5ncyBmcm9tIGxvY2FsU3RvcmFnZSBvciBJbmRleGVkREJcclxuICAgICAgY29uc3QgY2FjaGVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5NQVBQSU5HX0NBQ0hFX0tFWSk7XHJcbiAgICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICBjb25zdCBtYXBwaW5nczogQ2FyZE1hcHBpbmdbXSA9IEpTT04ucGFyc2UoY2FjaGVkKTtcclxuICAgICAgICBmb3IgKGNvbnN0IG1hcHBpbmcgb2YgbWFwcGluZ3MpIHtcclxuICAgICAgICAgIHRoaXMubWFwcGluZ0NhY2hlLnNldChtYXBwaW5nLnNjcnlmYWxsSWQsIG1hcHBpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyhgTG9hZGVkICR7bWFwcGluZ3MubGVuZ3RofSBjYWNoZWQgbWFwcGluZ3NgKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgbWFwcGluZyBjYWNoZTonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTYXZlIGEgc2luZ2xlIG1hcHBpbmcgdG8gY2FjaGVcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIHNhdmVNYXBwaW5nVG9DYWNoZShtYXBwaW5nOiBDYXJkTWFwcGluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2UgKGZvciBub3cpXHJcbiAgICAgIGNvbnN0IGV4aXN0aW5nTWFwcGluZ3MgPSB0aGlzLmdldEFsbENhY2hlZE1hcHBpbmdzKCk7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRNYXBwaW5ncyA9IGV4aXN0aW5nTWFwcGluZ3MuZmlsdGVyKG0gPT4gbS5zY3J5ZmFsbElkICE9PSBtYXBwaW5nLnNjcnlmYWxsSWQpO1xyXG4gICAgICB1cGRhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcclxuICAgICAgXHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuTUFQUElOR19DQUNIRV9LRVksIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRNYXBwaW5ncykpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgbWFwcGluZyB0byBjYWNoZTonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYWxsIGNhY2hlZCBtYXBwaW5nc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0QWxsQ2FjaGVkTWFwcGluZ3MoKTogQ2FyZE1hcHBpbmdbXSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjYWNoZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLk1BUFBJTkdfQ0FDSEVfS0VZKTtcclxuICAgICAgcmV0dXJuIGNhY2hlZCA/IEpTT04ucGFyc2UoY2FjaGVkKSA6IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBjYWNoZWQgbWFwcGluZ3M6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBkYXRhIGlzIGZyZXNoICh3aXRoaW4gNyBkYXlzKVxyXG4gICAqL1xyXG4gIHByaXZhdGUgaXNEYXRhRnJlc2goZGF0ZVN0cmluZzogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBkYXRhRGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHJpbmcpO1xyXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgIGNvbnN0IGRheXNEaWZmID0gKG5vdy5nZXRUaW1lKCkgLSBkYXRhRGF0ZS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xyXG4gICAgcmV0dXJuIGRheXNEaWZmIDwgNztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvdW50IHRvdGFsIGNhcmRzIGluIEFsbFByaW50aW5ncyBkYXRhXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjb3VudFRvdGFsQ2FyZHMoZGF0YTogTVRHSlNPTkFsbFByaW50aW5ncyk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhkYXRhLmRhdGEpLnJlZHVjZSgodG90YWwsIHNldCkgPT4gdG90YWwgKyBzZXQuY2FyZHMubGVuZ3RoLCAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBtYXBwaW5nIHN0YXRpc3RpY3NcclxuICAgKi9cclxuICBhc3luYyBnZXRNYXBwaW5nU3RhdHMoKTogUHJvbWlzZTxNYXBwaW5nU3RhdHM+IHtcclxuICAgIGNvbnN0IGNhY2hlZE1hcHBpbmdzID0gdGhpcy5nZXRBbGxDYWNoZWRNYXBwaW5ncygpO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbE1hcHBpbmdzOiBjYWNoZWRNYXBwaW5ncy5sZW5ndGgsXHJcbiAgICAgIGRpcmVjdE1hdGNoZXM6IGNhY2hlZE1hcHBpbmdzLmZpbHRlcihtID0+IG0ubWF0Y2hNZXRob2QgPT09ICdkaXJlY3QnKS5sZW5ndGgsXHJcbiAgICAgIGZ1enp5TWF0Y2hlczogY2FjaGVkTWFwcGluZ3MuZmlsdGVyKG0gPT4gbS5tYXRjaE1ldGhvZCA9PT0gJ25hbWVfZnV6enknKS5sZW5ndGgsXHJcbiAgICAgIHVubWFwcGVkQ2FyZHM6IDAsIC8vIFdvdWxkIG5lZWQgdG8gdHJhY2sgdGhpcyBzZXBhcmF0ZWx5XHJcbiAgICAgIGxhc3RVcGRhdGU6IGNhY2hlZE1hcHBpbmdzLmxlbmd0aCA+IDAgXHJcbiAgICAgICAgPyBNYXRoLm1heCguLi5jYWNoZWRNYXBwaW5ncy5tYXAobSA9PiBuZXcgRGF0ZShtLmxhc3RVcGRhdGVkKS5nZXRUaW1lKCkpKS50b1N0cmluZygpXHJcbiAgICAgICAgOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYXIgYWxsIGNhY2hlZCBtYXBwaW5nc1xyXG4gICAqL1xyXG4gIGFzeW5jIGNsZWFyTWFwcGluZ0NhY2hlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdGhpcy5tYXBwaW5nQ2FjaGUuY2xlYXIoKTtcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuTUFQUElOR19DQUNIRV9LRVkpO1xyXG4gICAgY29uc29sZS5sb2coJ01hcHBpbmcgY2FjaGUgY2xlYXJlZCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmF0Y2ggcHJvY2VzcyBtdWx0aXBsZSBjYXJkcyBmb3IgbWFwcGluZ1xyXG4gICAqL1xyXG4gIGFzeW5jIGJhdGNoR2V0TWFwcGluZ3Moc2NyeWZhbGxDYXJkczogTVRHQ2FyZFtdKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBzdHJpbmc+PiB7XHJcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgIFxyXG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XHJcbiAgICBcclxuICAgIGZvciAoY29uc3QgY2FyZCBvZiBzY3J5ZmFsbENhcmRzKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdXVpZCA9IGF3YWl0IHRoaXMuZ2V0TWFwcGluZyhjYXJkKTtcclxuICAgICAgICBpZiAodXVpZCkge1xyXG4gICAgICAgICAgcmVzdWx0cy5zZXQoY2FyZC5pZCwgdXVpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBtYXAgY2FyZCAke2NhcmQubmFtZX06YCwgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxyXG5leHBvcnQgY29uc3QgY2FyZE1hcHBpbmdTZXJ2aWNlID0gbmV3IENhcmRNYXBwaW5nU2VydmljZSgpO1xyXG5cclxuLy8gRXhwb3J0IHR5cGVzIGZvciBleHRlcm5hbCB1c2VcclxuZXhwb3J0IHR5cGUgeyBDYXJkTWFwcGluZywgTWFwcGluZ1N0YXRzIH07XHJcbiJdLCJuYW1lcyI6WyJtdGdqc29uQ2FjaGUiLCJDYXJkTWFwcGluZ1NlcnZpY2UiLCJpbml0aWFsaXplIiwibG9hZGluZ1Byb21pc2UiLCJsb2FkQWxsUHJpbnRpbmdzRGF0YSIsImNvbnNvbGUiLCJsb2ciLCJjYWNoZWQiLCJnZXRDYWNoZWRBbGxQcmludGluZ3MiLCJpc0RhdGFGcmVzaCIsIm1ldGEiLCJkYXRlIiwiYWxsUHJpbnRpbmdzRGF0YSIsImxvYWRNYXBwaW5nQ2FjaGUiLCJyZXNwb25zZSIsImZldGNoIiwiTVRHSlNPTl9BTExfUFJJTlRJTkdTX1VSTCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImpzb24iLCJhbGxQcmludGluZ3NTdG9yYWdlIiwic3RvcmVBbGxQcmludGluZ3MiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiZXJyb3IiLCJpc0F2YWlsYWJsZSIsImlzRGF0YUF2YWlsYWJsZSIsInN0b3JhZ2VFcnJvciIsImdldE1hcHBpbmciLCJzY3J5ZmFsbENhcmQiLCJtYXBwaW5nQ2FjaGUiLCJnZXQiLCJpZCIsIm10Z2pzb25VdWlkIiwibWFwcGluZyIsImZpbmRDYXJkTWFwcGluZyIsInNldCIsInNhdmVNYXBwaW5nVG9DYWNoZSIsInN0cmF0ZWdpZXMiLCJmaW5kQnlEaXJlY3RTY3J5ZmFsbElkIiwiZmluZEJ5TmFtZUFuZFNldCIsImZpbmRCeUNvbGxlY3Rvck51bWJlciIsImZpbmRCeUZ1enp5TmFtZSIsInN0cmF0ZWd5IiwicmVzdWx0Iiwic2NyeWZhbGxJZCIsImNhcmQiLCJmaW5kQ2FyZEJ5U2NyeWZhbGxJZCIsInV1aWQiLCJjb25maWRlbmNlIiwibWF0Y2hNZXRob2QiLCJsYXN0VXBkYXRlZCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNlYXJjaFJlc3VsdHMiLCJzZWFyY2hDYXJkcyIsIm5hbWUiLCJub3JtYWxpemVDYXJkTmFtZSIsInNldENvZGUiLCJ0b0xvd2VyQ2FzZSIsIm51bWJlciIsIm5hbWVTaW1pbGFyaXR5IiwiY2FsY3VsYXRlTmFtZVNpbWlsYXJpdHkiLCJzaW1pbGFyaXR5Iiwid2FybiIsInZhbHVlcyIsImNhcmRzIiwiaWRlbnRpZmllcnMiLCJub3JtYWxpemVkTmFtZSIsImNvZGUiLCJjYXJkTm9ybWFsaXplZE5hbWUiLCJjb2xsZWN0b3JOdW1iZXIiLCJiZXN0TWF0Y2giLCJyZXBsYWNlIiwidHJpbSIsInN0cjEiLCJzdHIyIiwibGVuMSIsImxlbjIiLCJtYXRyaXgiLCJpIiwiaiIsImNvc3QiLCJNYXRoIiwibWluIiwiZGlzdGFuY2UiLCJtYXhMZW5ndGgiLCJtYXgiLCJjYWNoZUFsbFByaW50aW5ncyIsInNldE1ldGFkYXRhIiwibGFzdFByaWNlVXBkYXRlIiwidG90YWxDYXJkcyIsImNvdW50VG90YWxDYXJkcyIsImNhY2hlVmVyc2lvbiIsInZlcnNpb24iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiTUFQUElOR19DQUNIRV9LRVkiLCJtYXBwaW5ncyIsIkpTT04iLCJwYXJzZSIsImV4aXN0aW5nTWFwcGluZ3MiLCJnZXRBbGxDYWNoZWRNYXBwaW5ncyIsInVwZGF0ZWRNYXBwaW5ncyIsImZpbHRlciIsIm0iLCJwdXNoIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImRhdGVTdHJpbmciLCJkYXRhRGF0ZSIsIm5vdyIsImRheXNEaWZmIiwiZ2V0VGltZSIsInJlZHVjZSIsInRvdGFsIiwiZ2V0TWFwcGluZ1N0YXRzIiwiY2FjaGVkTWFwcGluZ3MiLCJ0b3RhbE1hcHBpbmdzIiwiZGlyZWN0TWF0Y2hlcyIsImZ1enp5TWF0Y2hlcyIsInVubWFwcGVkQ2FyZHMiLCJsYXN0VXBkYXRlIiwibWFwIiwidG9TdHJpbmciLCJjbGVhck1hcHBpbmdDYWNoZSIsImNsZWFyIiwicmVtb3ZlSXRlbSIsImJhdGNoR2V0TWFwcGluZ3MiLCJzY3J5ZmFsbENhcmRzIiwicmVzdWx0cyIsIk1hcCIsIkNBQ0hFX0tFWSIsImNhcmRNYXBwaW5nU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./src/lib/services/cardMappingService.ts\n");

/***/ }),

/***/ "(ssr)/./src/lib/utils/mtgjsonCache.ts":
/*!***************************************!*\
  !*** ./src/lib/utils/mtgjsonCache.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   mtgjsonCache: () => (/* binding */ mtgjsonCache)\n/* harmony export */ });\n// IndexedDB configuration for MTGJSON data\nconst DB_NAME = 'MTGJSONCache';\nconst DB_VERSION = 1;\nconst STORES = {\n    PRICE_HISTORY: 'priceHistory',\n    CARD_MAPPINGS: 'cardMappings',\n    METADATA: 'metadata'\n};\n// Cache expiry times\nconst CACHE_EXPIRY = {\n    PRICE_HISTORY: 24 * 60 * 60 * 1000,\n    CARD_MAPPINGS: 7 * 24 * 60 * 60 * 1000,\n    METADATA: 60 * 60 * 1000\n};\nclass MTGJSONCache {\n    async init() {\n        if (this.db) return;\n        if (this.initPromise) return this.initPromise;\n        this.initPromise = new Promise((resolve, reject)=>{\n            if (true) {\n                reject(new Error('IndexedDB not available in server environment'));\n                return;\n            }\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n            request.onerror = ()=>{\n                reject(new Error('Failed to open IndexedDB'));\n            };\n            request.onsuccess = ()=>{\n                this.db = request.result;\n                resolve();\n            };\n            request.onupgradeneeded = (event)=>{\n                const db = event.target.result;\n                // Create price history store\n                if (!db.objectStoreNames.contains(STORES.PRICE_HISTORY)) {\n                    const priceStore = db.createObjectStore(STORES.PRICE_HISTORY, {\n                        keyPath: 'uuid'\n                    });\n                    priceStore.createIndex('cardId', 'cardId', {\n                        unique: false\n                    });\n                    priceStore.createIndex('lastUpdated', 'lastUpdated', {\n                        unique: false\n                    });\n                }\n                // Create card mappings store\n                if (!db.objectStoreNames.contains(STORES.CARD_MAPPINGS)) {\n                    const mappingStore = db.createObjectStore(STORES.CARD_MAPPINGS, {\n                        keyPath: 'scryfallId'\n                    });\n                    mappingStore.createIndex('uuid', 'uuid', {\n                        unique: false\n                    });\n                    mappingStore.createIndex('name', 'name', {\n                        unique: false\n                    });\n                }\n                // Create metadata store\n                if (!db.objectStoreNames.contains(STORES.METADATA)) {\n                    db.createObjectStore(STORES.METADATA, {\n                        keyPath: 'key'\n                    });\n                }\n            };\n        });\n        return this.initPromise;\n    }\n    async getStore(storeName, mode = 'readonly') {\n        await this.init();\n        if (!this.db) throw new Error('Database not initialized');\n        const transaction = this.db.transaction([\n            storeName\n        ], mode);\n        return transaction.objectStore(storeName);\n    }\n    // Price History Cache Methods\n    async getPriceHistory(uuid) {\n        try {\n            const store = await this.getStore(STORES.PRICE_HISTORY);\n            const request = store.get(uuid);\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>{\n                    const result = request.result;\n                    if (!result) {\n                        resolve(null);\n                        return;\n                    }\n                    // Check if cache entry is expired\n                    if (Date.now() > result.expiresAt) {\n                        // Remove expired entry\n                        this.removePriceHistory(uuid);\n                        resolve(null);\n                        return;\n                    }\n                    resolve(result.data);\n                };\n                request.onerror = ()=>{\n                    reject(new Error('Failed to get price history from cache'));\n                };\n            });\n        } catch (error) {\n            console.error('Error getting price history from cache:', error);\n            return null;\n        }\n    }\n    async setPriceHistory(uuid, priceHistory) {\n        try {\n            const store = await this.getStore(STORES.PRICE_HISTORY, 'readwrite');\n            const cacheEntry = {\n                data: priceHistory,\n                timestamp: Date.now(),\n                expiresAt: Date.now() + CACHE_EXPIRY.PRICE_HISTORY\n            };\n            const request = store.put({\n                uuid,\n                ...cacheEntry\n            });\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to cache price history'));\n            });\n        } catch (error) {\n            console.error('Error caching price history:', error);\n            throw error;\n        }\n    }\n    async removePriceHistory(uuid) {\n        try {\n            const store = await this.getStore(STORES.PRICE_HISTORY, 'readwrite');\n            const request = store.delete(uuid);\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to remove price history'));\n            });\n        } catch (error) {\n            console.error('Error removing price history:', error);\n        }\n    }\n    // Card Mapping Cache Methods\n    async getCardMapping(scryfallId) {\n        try {\n            const store = await this.getStore(STORES.CARD_MAPPINGS);\n            const request = store.get(scryfallId);\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>{\n                    const result = request.result;\n                    if (!result) {\n                        resolve(null);\n                        return;\n                    }\n                    // Check if cache entry is expired\n                    if (Date.now() > result.expiresAt) {\n                        this.removeCardMapping(scryfallId);\n                        resolve(null);\n                        return;\n                    }\n                    resolve(result.data);\n                };\n                request.onerror = ()=>{\n                    reject(new Error('Failed to get card mapping from cache'));\n                };\n            });\n        } catch (error) {\n            console.error('Error getting card mapping from cache:', error);\n            return null;\n        }\n    }\n    async setCardMapping(scryfallId, mtgjsonCard) {\n        try {\n            const store = await this.getStore(STORES.CARD_MAPPINGS, 'readwrite');\n            const cacheEntry = {\n                data: mtgjsonCard,\n                timestamp: Date.now(),\n                expiresAt: Date.now() + CACHE_EXPIRY.CARD_MAPPINGS\n            };\n            const request = store.put({\n                scryfallId,\n                ...cacheEntry\n            });\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to cache card mapping'));\n            });\n        } catch (error) {\n            console.error('Error caching card mapping:', error);\n            throw error;\n        }\n    }\n    async removeCardMapping(scryfallId) {\n        try {\n            const store = await this.getStore(STORES.CARD_MAPPINGS, 'readwrite');\n            const request = store.delete(scryfallId);\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to remove card mapping'));\n            });\n        } catch (error) {\n            console.error('Error removing card mapping:', error);\n        }\n    }\n    // Metadata Methods\n    async getMetadata() {\n        try {\n            const store = await this.getStore(STORES.METADATA);\n            const request = store.get('metadata');\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>{\n                    const result = request.result;\n                    if (!result) {\n                        resolve(null);\n                        return;\n                    }\n                    // Check if metadata is expired\n                    if (Date.now() > result.expiresAt) {\n                        this.setMetadata({\n                            lastPriceUpdate: '',\n                            totalCards: 0,\n                            cacheVersion: '1.0'\n                        });\n                        resolve(null);\n                        return;\n                    }\n                    resolve(result.data);\n                };\n                request.onerror = ()=>{\n                    reject(new Error('Failed to get metadata from cache'));\n                };\n            });\n        } catch (error) {\n            console.error('Error getting metadata from cache:', error);\n            return null;\n        }\n    }\n    async setMetadata(metadata) {\n        try {\n            const store = await this.getStore(STORES.METADATA, 'readwrite');\n            const cacheEntry = {\n                data: metadata,\n                timestamp: Date.now(),\n                expiresAt: Date.now() + CACHE_EXPIRY.METADATA\n            };\n            const request = store.put({\n                key: 'metadata',\n                ...cacheEntry\n            });\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to cache metadata'));\n            });\n        } catch (error) {\n            console.error('Error caching metadata:', error);\n            throw error;\n        }\n    }\n    // Bulk Operations\n    async batchSetPriceHistories(priceHistories) {\n        try {\n            const store = await this.getStore(STORES.PRICE_HISTORY, 'readwrite');\n            const transaction = store.transaction;\n            const promises = priceHistories.map(({ uuid, data })=>{\n                const cacheEntry = {\n                    data,\n                    timestamp: Date.now(),\n                    expiresAt: Date.now() + CACHE_EXPIRY.PRICE_HISTORY\n                };\n                const request = store.put({\n                    uuid,\n                    ...cacheEntry\n                });\n                return new Promise((resolve, reject)=>{\n                    request.onsuccess = ()=>resolve();\n                    request.onerror = ()=>reject(new Error(`Failed to cache price history for ${uuid}`));\n                });\n            });\n            await Promise.all(promises);\n            return new Promise((resolve, reject)=>{\n                transaction.oncomplete = ()=>resolve();\n                transaction.onerror = ()=>reject(new Error('Batch price history caching failed'));\n            });\n        } catch (error) {\n            console.error('Error batch caching price histories:', error);\n            throw error;\n        }\n    }\n    // Cache Management\n    async clearExpiredEntries() {\n        try {\n            const now = Date.now();\n            const stores = [\n                STORES.PRICE_HISTORY,\n                STORES.CARD_MAPPINGS,\n                STORES.METADATA\n            ];\n            for (const storeName of stores){\n                const store = await this.getStore(storeName, 'readwrite');\n                const request = store.openCursor();\n                await new Promise((resolve, reject)=>{\n                    request.onsuccess = ()=>{\n                        const cursor = request.result;\n                        if (cursor) {\n                            const entry = cursor.value;\n                            if (now > entry.expiresAt) {\n                                cursor.delete();\n                            }\n                            cursor.continue();\n                        } else {\n                            resolve();\n                        }\n                    };\n                    request.onerror = ()=>{\n                        reject(new Error(`Failed to clear expired entries from ${storeName}`));\n                    };\n                });\n            }\n        } catch (error) {\n            console.error('Error clearing expired cache entries:', error);\n        }\n    }\n    async clearAllCache() {\n        try {\n            const stores = [\n                STORES.PRICE_HISTORY,\n                STORES.CARD_MAPPINGS,\n                STORES.METADATA\n            ];\n            for (const storeName of stores){\n                const store = await this.getStore(storeName, 'readwrite');\n                const request = store.clear();\n                await new Promise((resolve, reject)=>{\n                    request.onsuccess = ()=>resolve();\n                    request.onerror = ()=>reject(new Error(`Failed to clear ${storeName}`));\n                });\n            }\n        } catch (error) {\n            console.error('Error clearing cache:', error);\n            throw error;\n        }\n    }\n    async getCacheStats() {\n        try {\n            const [priceCount, mappingCount] = await Promise.all([\n                this.getStoreCount(STORES.PRICE_HISTORY),\n                this.getStoreCount(STORES.CARD_MAPPINGS)\n            ]);\n            return {\n                priceHistoryCount: priceCount,\n                cardMappingCount: mappingCount,\n                totalSize: 0,\n                lastCleanup: null\n            };\n        } catch (error) {\n            console.error('Error getting cache stats:', error);\n            return {\n                priceHistoryCount: 0,\n                cardMappingCount: 0,\n                totalSize: 0,\n                lastCleanup: null\n            };\n        }\n    }\n    async getStoreCount(storeName) {\n        const store = await this.getStore(storeName);\n        const request = store.count();\n        return new Promise((resolve, reject)=>{\n            request.onsuccess = ()=>resolve(request.result);\n            request.onerror = ()=>reject(new Error(`Failed to get count for ${storeName}`));\n        });\n    }\n    // Cleanup\n    async close() {\n        if (this.db) {\n            this.db.close();\n            this.db = null;\n            this.initPromise = null;\n        }\n    }\n    constructor(){\n        this.db = null;\n        this.initPromise = null;\n    }\n}\n// Export singleton instance\nconst mtgjsonCache = new MTGJSONCache();\n// Initialize cache on import (client-side only)\nif (false) {}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mtgjsonCache);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFLO1lBQ2IsSUFBSSxDQUFDakYsRUFBRSxHQUFHO1lBQ1YsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDckI7SUFDRjs7YUEzWVFELEtBQXlCO2FBQ3pCQyxjQUFvQzs7QUEyWTlDO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1pRixlQUFlLElBQUlwRixlQUFlO0FBRS9DLGdEQUFnRDtBQUNoRCxJQUFJLEtBQTZCLEVBQUUsRUFPbEM7QUFFRCxpRUFBZW9GLFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcbXRnLWluZGV4XFxzcmNcXGxpYlxcdXRpbHNcXG10Z2pzb25DYWNoZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNVEdKU09OQ2FyZFByaWNlcywgTVRHSlNPTkNhcmQsIFByaWNlSGlzdG9yeSB9IGZyb20gJ0AvbGliL3R5cGVzJztcclxuXHJcbi8vIEluZGV4ZWREQiBjb25maWd1cmF0aW9uIGZvciBNVEdKU09OIGRhdGFcclxuY29uc3QgREJfTkFNRSA9ICdNVEdKU09OQ2FjaGUnO1xyXG5jb25zdCBEQl9WRVJTSU9OID0gMTtcclxuY29uc3QgU1RPUkVTID0ge1xyXG4gIFBSSUNFX0hJU1RPUlk6ICdwcmljZUhpc3RvcnknLFxyXG4gIENBUkRfTUFQUElOR1M6ICdjYXJkTWFwcGluZ3MnLFxyXG4gIE1FVEFEQVRBOiAnbWV0YWRhdGEnLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuLy8gQ2FjaGUgZXhwaXJ5IHRpbWVzXHJcbmNvbnN0IENBQ0hFX0VYUElSWSA9IHtcclxuICBQUklDRV9ISVNUT1JZOiAyNCAqIDYwICogNjAgKiAxMDAwLCAvLyAyNCBob3Vyc1xyXG4gIENBUkRfTUFQUElOR1M6IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwLCAvLyA3IGRheXNcclxuICBNRVRBREFUQTogNjAgKiA2MCAqIDEwMDAsIC8vIDEgaG91clxyXG59IGFzIGNvbnN0O1xyXG5cclxuaW50ZXJmYWNlIENhY2hlRW50cnk8VD4ge1xyXG4gIGRhdGE6IFQ7XHJcbiAgdGltZXN0YW1wOiBudW1iZXI7XHJcbiAgZXhwaXJlc0F0OiBudW1iZXI7XHJcbn1cclxuXHJcbmludGVyZmFjZSBDYWNoZU1ldGFkYXRhIHtcclxuICBsYXN0UHJpY2VVcGRhdGU6IHN0cmluZztcclxuICB0b3RhbENhcmRzOiBudW1iZXI7XHJcbiAgY2FjaGVWZXJzaW9uOiBzdHJpbmc7XHJcbn1cclxuXHJcbmNsYXNzIE1UR0pTT05DYWNoZSB7XHJcbiAgcHJpdmF0ZSBkYjogSURCRGF0YWJhc2UgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIGluaXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIGFzeW5jIGluaXQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAodGhpcy5kYikgcmV0dXJuO1xyXG4gICAgaWYgKHRoaXMuaW5pdFByb21pc2UpIHJldHVybiB0aGlzLmluaXRQcm9taXNlO1xyXG5cclxuICAgIHRoaXMuaW5pdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0luZGV4ZWREQiBub3QgYXZhaWxhYmxlIGluIHNlcnZlciBlbnZpcm9ubWVudCcpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihEQl9OQU1FLCBEQl9WRVJTSU9OKTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gb3BlbiBJbmRleGVkREInKSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLmRiID0gcmVxdWVzdC5yZXN1bHQ7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCBkYiA9IChldmVudC50YXJnZXQgYXMgSURCT3BlbkRCUmVxdWVzdCkucmVzdWx0O1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgcHJpY2UgaGlzdG9yeSBzdG9yZVxyXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhTVE9SRVMuUFJJQ0VfSElTVE9SWSkpIHtcclxuICAgICAgICAgIGNvbnN0IHByaWNlU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShTVE9SRVMuUFJJQ0VfSElTVE9SWSwgeyBrZXlQYXRoOiAndXVpZCcgfSk7XHJcbiAgICAgICAgICBwcmljZVN0b3JlLmNyZWF0ZUluZGV4KCdjYXJkSWQnLCAnY2FyZElkJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgcHJpY2VTdG9yZS5jcmVhdGVJbmRleCgnbGFzdFVwZGF0ZWQnLCAnbGFzdFVwZGF0ZWQnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgY2FyZCBtYXBwaW5ncyBzdG9yZVxyXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhTVE9SRVMuQ0FSRF9NQVBQSU5HUykpIHtcclxuICAgICAgICAgIGNvbnN0IG1hcHBpbmdTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFUy5DQVJEX01BUFBJTkdTLCB7IGtleVBhdGg6ICdzY3J5ZmFsbElkJyB9KTtcclxuICAgICAgICAgIG1hcHBpbmdTdG9yZS5jcmVhdGVJbmRleCgndXVpZCcsICd1dWlkJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgbWFwcGluZ1N0b3JlLmNyZWF0ZUluZGV4KCduYW1lJywgJ25hbWUnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgbWV0YWRhdGEgc3RvcmVcclxuICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoU1RPUkVTLk1FVEFEQVRBKSkge1xyXG4gICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoU1RPUkVTLk1FVEFEQVRBLCB7IGtleVBhdGg6ICdrZXknIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRTdG9yZShzdG9yZU5hbWU6IHN0cmluZywgbW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlID0gJ3JlYWRvbmx5Jyk6IFByb21pc2U8SURCT2JqZWN0U3RvcmU+IHtcclxuICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG4gICAgaWYgKCF0aGlzLmRiKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIG5vdCBpbml0aWFsaXplZCcpO1xyXG5cclxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbc3RvcmVOYW1lXSwgbW9kZSk7XHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcclxuICB9XHJcblxyXG4gIC8vIFByaWNlIEhpc3RvcnkgQ2FjaGUgTWV0aG9kc1xyXG4gIGFzeW5jIGdldFByaWNlSGlzdG9yeSh1dWlkOiBzdHJpbmcpOiBQcm9taXNlPFByaWNlSGlzdG9yeSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuUFJJQ0VfSElTVE9SWSk7XHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXQodXVpZCk7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVxdWVzdC5yZXN1bHQgYXMgQ2FjaGVFbnRyeTxQcmljZUhpc3Rvcnk+IHwgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgY2FjaGUgZW50cnkgaXMgZXhwaXJlZFxyXG4gICAgICAgICAgaWYgKERhdGUubm93KCkgPiByZXN1bHQuZXhwaXJlc0F0KSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBleHBpcmVkIGVudHJ5XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUHJpY2VIaXN0b3J5KHV1aWQpO1xyXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBwcmljZSBoaXN0b3J5IGZyb20gY2FjaGUnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHByaWNlIGhpc3RvcnkgZnJvbSBjYWNoZTonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2V0UHJpY2VIaXN0b3J5KHV1aWQ6IHN0cmluZywgcHJpY2VIaXN0b3J5OiBQcmljZUhpc3RvcnkpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuUFJJQ0VfSElTVE9SWSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgY2FjaGVFbnRyeTogQ2FjaGVFbnRyeTxQcmljZUhpc3Rvcnk+ID0ge1xyXG4gICAgICAgIGRhdGE6IHByaWNlSGlzdG9yeSxcclxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgZXhwaXJlc0F0OiBEYXRlLm5vdygpICsgQ0FDSEVfRVhQSVJZLlBSSUNFX0hJU1RPUlksXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUucHV0KHsgdXVpZCwgLi4uY2FjaGVFbnRyeSB9KTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGNhY2hlIHByaWNlIGhpc3RvcnknKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FjaGluZyBwcmljZSBoaXN0b3J5OicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyByZW1vdmVQcmljZUhpc3RvcnkodXVpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuZ2V0U3RvcmUoU1RPUkVTLlBSSUNFX0hJU1RPUlksICdyZWFkd3JpdGUnKTtcclxuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmRlbGV0ZSh1dWlkKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHJlbW92ZSBwcmljZSBoaXN0b3J5JykpO1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHByaWNlIGhpc3Rvcnk6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2FyZCBNYXBwaW5nIENhY2hlIE1ldGhvZHNcclxuICBhc3luYyBnZXRDYXJkTWFwcGluZyhzY3J5ZmFsbElkOiBzdHJpbmcpOiBQcm9taXNlPE1UR0pTT05DYXJkIHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RvcmUgPSBhd2FpdCB0aGlzLmdldFN0b3JlKFNUT1JFUy5DQVJEX01BUFBJTkdTKTtcclxuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldChzY3J5ZmFsbElkKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXF1ZXN0LnJlc3VsdCBhcyBDYWNoZUVudHJ5PE1UR0pTT05DYXJkPiB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENoZWNrIGlmIGNhY2hlIGVudHJ5IGlzIGV4cGlyZWRcclxuICAgICAgICAgIGlmIChEYXRlLm5vdygpID4gcmVzdWx0LmV4cGlyZXNBdCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNhcmRNYXBwaW5nKHNjcnlmYWxsSWQpO1xyXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBjYXJkIG1hcHBpbmcgZnJvbSBjYWNoZScpKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY2FyZCBtYXBwaW5nIGZyb20gY2FjaGU6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHNldENhcmRNYXBwaW5nKHNjcnlmYWxsSWQ6IHN0cmluZywgbXRnanNvbkNhcmQ6IE1UR0pTT05DYXJkKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuZ2V0U3RvcmUoU1RPUkVTLkNBUkRfTUFQUElOR1MsICdyZWFkd3JpdGUnKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGNhY2hlRW50cnk6IENhY2hlRW50cnk8TVRHSlNPTkNhcmQ+ID0ge1xyXG4gICAgICAgIGRhdGE6IG10Z2pzb25DYXJkLFxyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICBleHBpcmVzQXQ6IERhdGUubm93KCkgKyBDQUNIRV9FWFBJUlkuQ0FSRF9NQVBQSU5HUyxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoeyBzY3J5ZmFsbElkLCAuLi5jYWNoZUVudHJ5IH0pO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gY2FjaGUgY2FyZCBtYXBwaW5nJykpO1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhY2hpbmcgY2FyZCBtYXBwaW5nOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyByZW1vdmVDYXJkTWFwcGluZyhzY3J5ZmFsbElkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuQ0FSRF9NQVBQSU5HUywgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZGVsZXRlKHNjcnlmYWxsSWQpO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVtb3ZlIGNhcmQgbWFwcGluZycpKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBjYXJkIG1hcHBpbmc6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTWV0YWRhdGEgTWV0aG9kc1xyXG4gIGFzeW5jIGdldE1ldGFkYXRhKCk6IFByb21pc2U8Q2FjaGVNZXRhZGF0YSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuTUVUQURBVEEpO1xyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KCdtZXRhZGF0YScpO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlcXVlc3QucmVzdWx0IGFzIENhY2hlRW50cnk8Q2FjaGVNZXRhZGF0YT4gfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDaGVjayBpZiBtZXRhZGF0YSBpcyBleHBpcmVkXHJcbiAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IHJlc3VsdC5leHBpcmVzQXQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRNZXRhZGF0YSh7XHJcbiAgICAgICAgICAgICAgbGFzdFByaWNlVXBkYXRlOiAnJyxcclxuICAgICAgICAgICAgICB0b3RhbENhcmRzOiAwLFxyXG4gICAgICAgICAgICAgIGNhY2hlVmVyc2lvbjogJzEuMCcsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBtZXRhZGF0YSBmcm9tIGNhY2hlJykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBtZXRhZGF0YSBmcm9tIGNhY2hlOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzZXRNZXRhZGF0YShtZXRhZGF0YTogQ2FjaGVNZXRhZGF0YSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RvcmUgPSBhd2FpdCB0aGlzLmdldFN0b3JlKFNUT1JFUy5NRVRBREFUQSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgY2FjaGVFbnRyeTogQ2FjaGVFbnRyeTxDYWNoZU1ldGFkYXRhPiA9IHtcclxuICAgICAgICBkYXRhOiBtZXRhZGF0YSxcclxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgZXhwaXJlc0F0OiBEYXRlLm5vdygpICsgQ0FDSEVfRVhQSVJZLk1FVEFEQVRBLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLnB1dCh7IGtleTogJ21ldGFkYXRhJywgLi4uY2FjaGVFbnRyeSB9KTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGNhY2hlIG1ldGFkYXRhJykpO1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhY2hpbmcgbWV0YWRhdGE6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJ1bGsgT3BlcmF0aW9uc1xyXG4gIGFzeW5jIGJhdGNoU2V0UHJpY2VIaXN0b3JpZXMocHJpY2VIaXN0b3JpZXM6IEFycmF5PHsgdXVpZDogc3RyaW5nOyBkYXRhOiBQcmljZUhpc3RvcnkgfT4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuUFJJQ0VfSElTVE9SWSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHN0b3JlLnRyYW5zYWN0aW9uO1xyXG5cclxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBwcmljZUhpc3Rvcmllcy5tYXAoKHsgdXVpZCwgZGF0YSB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2FjaGVFbnRyeTogQ2FjaGVFbnRyeTxQcmljZUhpc3Rvcnk+ID0ge1xyXG4gICAgICAgICAgZGF0YSxcclxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIGV4cGlyZXNBdDogRGF0ZS5ub3coKSArIENBQ0hFX0VYUElSWS5QUklDRV9ISVNUT1JZLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoeyB1dWlkLCAuLi5jYWNoZUVudHJ5IH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gY2FjaGUgcHJpY2UgaGlzdG9yeSBmb3IgJHt1dWlkfWApKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0JhdGNoIHByaWNlIGhpc3RvcnkgY2FjaGluZyBmYWlsZWQnKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYmF0Y2ggY2FjaGluZyBwcmljZSBoaXN0b3JpZXM6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENhY2hlIE1hbmFnZW1lbnRcclxuICBhc3luYyBjbGVhckV4cGlyZWRFbnRyaWVzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgY29uc3Qgc3RvcmVzID0gW1NUT1JFUy5QUklDRV9ISVNUT1JZLCBTVE9SRVMuQ0FSRF9NQVBQSU5HUywgU1RPUkVTLk1FVEFEQVRBXTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgc3RvcmVOYW1lIG9mIHN0b3Jlcykge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShzdG9yZU5hbWUsICdyZWFkd3JpdGUnKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUub3BlbkN1cnNvcigpO1xyXG5cclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVxdWVzdC5yZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcclxuICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGN1cnNvci52YWx1ZSBhcyBDYWNoZUVudHJ5PGFueT47XHJcbiAgICAgICAgICAgICAgaWYgKG5vdyA+IGVudHJ5LmV4cGlyZXNBdCkge1xyXG4gICAgICAgICAgICAgICAgY3Vyc29yLmRlbGV0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gY2xlYXIgZXhwaXJlZCBlbnRyaWVzIGZyb20gJHtzdG9yZU5hbWV9YCkpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2xlYXJpbmcgZXhwaXJlZCBjYWNoZSBlbnRyaWVzOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGNsZWFyQWxsQ2FjaGUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdG9yZXMgPSBbU1RPUkVTLlBSSUNFX0hJU1RPUlksIFNUT1JFUy5DQVJEX01BUFBJTkdTLCBTVE9SRVMuTUVUQURBVEFdO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBzdG9yZU5hbWUgb2Ygc3RvcmVzKSB7XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBhd2FpdCB0aGlzLmdldFN0b3JlKHN0b3JlTmFtZSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5jbGVhcigpO1xyXG5cclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBjbGVhciAke3N0b3JlTmFtZX1gKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFyaW5nIGNhY2hlOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZVN0YXRzKCk6IFByb21pc2U8e1xyXG4gICAgcHJpY2VIaXN0b3J5Q291bnQ6IG51bWJlcjtcclxuICAgIGNhcmRNYXBwaW5nQ291bnQ6IG51bWJlcjtcclxuICAgIHRvdGFsU2l6ZTogbnVtYmVyO1xyXG4gICAgbGFzdENsZWFudXA6IERhdGUgfCBudWxsO1xyXG4gIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IFtwcmljZUNvdW50LCBtYXBwaW5nQ291bnRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgIHRoaXMuZ2V0U3RvcmVDb3VudChTVE9SRVMuUFJJQ0VfSElTVE9SWSksXHJcbiAgICAgICAgdGhpcy5nZXRTdG9yZUNvdW50KFNUT1JFUy5DQVJEX01BUFBJTkdTKSxcclxuICAgICAgXSk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHByaWNlSGlzdG9yeUNvdW50OiBwcmljZUNvdW50LFxyXG4gICAgICAgIGNhcmRNYXBwaW5nQ291bnQ6IG1hcHBpbmdDb3VudCxcclxuICAgICAgICB0b3RhbFNpemU6IDAsIC8vIEluZGV4ZWREQiBkb2Vzbid0IHByb3ZpZGUgZWFzeSBzaXplIGNhbGN1bGF0aW9uXHJcbiAgICAgICAgbGFzdENsZWFudXA6IG51bGwsIC8vIFdvdWxkIG5lZWQgdG8gdHJhY2sgdGhpcyBzZXBhcmF0ZWx5XHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGNhY2hlIHN0YXRzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwcmljZUhpc3RvcnlDb3VudDogMCxcclxuICAgICAgICBjYXJkTWFwcGluZ0NvdW50OiAwLFxyXG4gICAgICAgIHRvdGFsU2l6ZTogMCxcclxuICAgICAgICBsYXN0Q2xlYW51cDogbnVsbCxcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0U3RvcmVDb3VudChzdG9yZU5hbWU6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuZ2V0U3RvcmUoc3RvcmVOYW1lKTtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5jb3VudCgpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCk7XHJcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgY291bnQgZm9yICR7c3RvcmVOYW1lfWApKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2xlYW51cFxyXG4gIGFzeW5jIGNsb3NlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKHRoaXMuZGIpIHtcclxuICAgICAgdGhpcy5kYi5jbG9zZSgpO1xyXG4gICAgICB0aGlzLmRiID0gbnVsbDtcclxuICAgICAgdGhpcy5pbml0UHJvbWlzZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBtdGdqc29uQ2FjaGUgPSBuZXcgTVRHSlNPTkNhY2hlKCk7XHJcblxyXG4vLyBJbml0aWFsaXplIGNhY2hlIG9uIGltcG9ydCAoY2xpZW50LXNpZGUgb25seSlcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbXRnanNvbkNhY2hlLmluaXQoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICBcclxuICAvLyBDbGVhbiB1cCBleHBpcmVkIGVudHJpZXMgb24gcGFnZSBsb2FkXHJcbiAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICBtdGdqc29uQ2FjaGUuY2xlYXJFeHBpcmVkRW50cmllcygpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gIH0sIDUwMDApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtdGdqc29uQ2FjaGU7XHJcbiJdLCJuYW1lcyI6WyJEQl9OQU1FIiwiREJfVkVSU0lPTiIsIlNUT1JFUyIsIlBSSUNFX0hJU1RPUlkiLCJDQVJEX01BUFBJTkdTIiwiTUVUQURBVEEiLCJDQUNIRV9FWFBJUlkiLCJNVEdKU09OQ2FjaGUiLCJpbml0IiwiZGIiLCJpbml0UHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiRXJyb3IiLCJyZXF1ZXN0IiwiaW5kZXhlZERCIiwib3BlbiIsIm9uZXJyb3IiLCJvbnN1Y2Nlc3MiLCJyZXN1bHQiLCJvbnVwZ3JhZGVuZWVkZWQiLCJldmVudCIsInRhcmdldCIsIm9iamVjdFN0b3JlTmFtZXMiLCJjb250YWlucyIsInByaWNlU3RvcmUiLCJjcmVhdGVPYmplY3RTdG9yZSIsImtleVBhdGgiLCJjcmVhdGVJbmRleCIsInVuaXF1ZSIsIm1hcHBpbmdTdG9yZSIsImdldFN0b3JlIiwic3RvcmVOYW1lIiwibW9kZSIsInRyYW5zYWN0aW9uIiwib2JqZWN0U3RvcmUiLCJnZXRQcmljZUhpc3RvcnkiLCJ1dWlkIiwic3RvcmUiLCJnZXQiLCJEYXRlIiwibm93IiwiZXhwaXJlc0F0IiwicmVtb3ZlUHJpY2VIaXN0b3J5IiwiZGF0YSIsImVycm9yIiwiY29uc29sZSIsInNldFByaWNlSGlzdG9yeSIsInByaWNlSGlzdG9yeSIsImNhY2hlRW50cnkiLCJ0aW1lc3RhbXAiLCJwdXQiLCJkZWxldGUiLCJnZXRDYXJkTWFwcGluZyIsInNjcnlmYWxsSWQiLCJyZW1vdmVDYXJkTWFwcGluZyIsInNldENhcmRNYXBwaW5nIiwibXRnanNvbkNhcmQiLCJnZXRNZXRhZGF0YSIsInNldE1ldGFkYXRhIiwibGFzdFByaWNlVXBkYXRlIiwidG90YWxDYXJkcyIsImNhY2hlVmVyc2lvbiIsIm1ldGFkYXRhIiwia2V5IiwiYmF0Y2hTZXRQcmljZUhpc3RvcmllcyIsInByaWNlSGlzdG9yaWVzIiwicHJvbWlzZXMiLCJtYXAiLCJhbGwiLCJvbmNvbXBsZXRlIiwiY2xlYXJFeHBpcmVkRW50cmllcyIsInN0b3JlcyIsIm9wZW5DdXJzb3IiLCJjdXJzb3IiLCJlbnRyeSIsInZhbHVlIiwiY29udGludWUiLCJjbGVhckFsbENhY2hlIiwiY2xlYXIiLCJnZXRDYWNoZVN0YXRzIiwicHJpY2VDb3VudCIsIm1hcHBpbmdDb3VudCIsImdldFN0b3JlQ291bnQiLCJwcmljZUhpc3RvcnlDb3VudCIsImNhcmRNYXBwaW5nQ291bnQiLCJ0b3RhbFNpemUiLCJsYXN0Q2xlYW51cCIsImNvdW50IiwiY2xvc2UiLCJtdGdqc29uQ2FjaGUiLCJjYXRjaCIsInNldFRpbWVvdXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/lib/utils/mtgjsonCache.ts\n");

/***/ })

};
;