"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_api_mtgjson_ts"],{

/***/ "(app-pages-browser)/./src/lib/api/mtgjson.ts":
/*!********************************!*\
  !*** ./src/lib/api/mtgjson.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MTGJSON_CONFIG: () => (/* binding */ MTGJSON_CONFIG),\n/* harmony export */   batchGetPriceHistories: () => (/* binding */ batchGetPriceHistories),\n/* harmony export */   clearMTGJSONCache: () => (/* binding */ clearMTGJSONCache),\n/* harmony export */   convertMTGJSONPrices: () => (/* binding */ convertMTGJSONPrices),\n/* harmony export */   fetchPriceHistoryByUUID: () => (/* binding */ fetchPriceHistoryByUUID),\n/* harmony export */   getCardMapping: () => (/* binding */ getCardMapping),\n/* harmony export */   getMTGJSONCacheStats: () => (/* binding */ getMTGJSONCacheStats),\n/* harmony export */   getPriceHistoryForCard: () => (/* binding */ getPriceHistoryForCard)\n/* harmony export */ });\n/* harmony import */ var _lib_services_cardMappingService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/services/cardMappingService */ \"(app-pages-browser)/./src/lib/services/cardMappingService.ts\");\n// MTGJSON Configuration\nconst MTGJSON_CONFIG = {\n    baseUrl: 'https://mtgjson.com/api/v5',\n    cacheExpiry: 24 * 60 * 60 * 1000,\n    preferredProvider: 'tcgplayer',\n    enableCaching: true\n};\n// Cache management\nconst CACHE_KEYS = {\n    ALL_PRICES: 'mtgjson-all-prices',\n    CARD_MAPPINGS: 'mtgjson-card-mappings',\n    PRICE_HISTORY: 'mtgjson-price-history-'\n};\n// Rate limiting: MTGJSON doesn't specify limits, but we'll be conservative\nconst RATE_LIMIT_DELAY = 200; // 200ms between requests\nlet lastRequestTime = 0;\nasync function rateLimitedFetch(url) {\n    const now = Date.now();\n    const timeSinceLastRequest = now - lastRequestTime;\n    if (timeSinceLastRequest < RATE_LIMIT_DELAY) {\n        await new Promise((resolve)=>setTimeout(resolve, RATE_LIMIT_DELAY - timeSinceLastRequest));\n    }\n    lastRequestTime = Date.now();\n    try {\n        console.log(\"Fetching MTGJSON data: \".concat(url));\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\"MTGJSON API Error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        return response;\n    } catch (error) {\n        console.error('MTGJSON API request failed:', {\n            url,\n            error: error instanceof Error ? error.message : 'Unknown error',\n            timestamp: new Date().toISOString()\n        });\n        if (error instanceof Error) {\n            if (error.message.includes('Failed to fetch')) {\n                throw new Error('Network error: Unable to connect to MTGJSON API. Please check your internet connection.');\n            }\n        }\n        throw error;\n    }\n}\n// Cache utilities\nfunction getCachedData(key) {\n    if (!MTGJSON_CONFIG.enableCaching || \"object\" === 'undefined') {\n        return null;\n    }\n    try {\n        const cached = localStorage.getItem(key);\n        if (!cached) return null;\n        const parsed = JSON.parse(cached);\n        const now = Date.now();\n        if (parsed.expiresAt && now > parsed.expiresAt) {\n            localStorage.removeItem(key);\n            return null;\n        }\n        return parsed.data;\n    } catch (error) {\n        console.error(\"Error reading cache for key \".concat(key, \":\"), error);\n        return null;\n    }\n}\nfunction setCachedData(key, data, customExpiry) {\n    if (!MTGJSON_CONFIG.enableCaching || \"object\" === 'undefined') {\n        return;\n    }\n    try {\n        const expiry = customExpiry || MTGJSON_CONFIG.cacheExpiry;\n        const cacheEntry = {\n            data,\n            expiresAt: Date.now() + expiry,\n            cachedAt: Date.now()\n        };\n        localStorage.setItem(key, JSON.stringify(cacheEntry));\n    } catch (error) {\n        console.error(\"Error setting cache for key \".concat(key, \":\"), error);\n    }\n}\n// Import the card mapping service\n\n// Map Scryfall card to MTGJSON UUID\nasync function getCardMapping(scryfallCard) {\n    try {\n        // Use the card mapping service\n        const uuid = await _lib_services_cardMappingService__WEBPACK_IMPORTED_MODULE_0__.cardMappingService.getMapping(scryfallCard);\n        if (uuid) {\n            // Cache the successful mapping\n            const cacheKey = \"\".concat(CACHE_KEYS.CARD_MAPPINGS).concat(scryfallCard.id);\n            setCachedData(cacheKey, uuid);\n        }\n        return uuid;\n    } catch (error) {\n        console.error(\"Error getting card mapping for \".concat(scryfallCard.name, \":\"), error);\n        return null;\n    }\n}\n// Fetch price history for a specific UUID\nasync function fetchPriceHistoryByUUID(uuid) {\n    try {\n        // Check cache first\n        const cacheKey = \"\".concat(CACHE_KEYS.PRICE_HISTORY).concat(uuid);\n        const cached = getCachedData(cacheKey);\n        if (cached) return cached;\n        // Try to get from AllPrices data\n        const priceData = await getAllPricesData();\n        if (priceData && priceData[uuid]) {\n            const cardPrices = priceData[uuid];\n            // Cache the result\n            setCachedData(cacheKey, cardPrices);\n            return cardPrices;\n        }\n        console.log(\"No price history found for UUID \".concat(uuid));\n        return null;\n    } catch (error) {\n        console.error('Error fetching price history:', error);\n        return null;\n    }\n}\n// Fetch and cache AllPrices.json data\nlet allPricesCache = null;\nlet allPricesLoadingPromise = null;\nasync function getAllPricesData() {\n    // Return cached data if available\n    if (allPricesCache) {\n        return allPricesCache;\n    }\n    // Return existing loading promise if in progress\n    if (allPricesLoadingPromise) {\n        return allPricesLoadingPromise;\n    }\n    // Start loading AllPrices data\n    allPricesLoadingPromise = loadAllPricesData();\n    return allPricesLoadingPromise;\n}\nasync function loadAllPricesData() {\n    try {\n        console.log('Loading MTGJSON AllPrices data...');\n        // Check if we have cached AllPrices data\n        const cachedAllPrices = getCachedData('mtgjson-all-prices-data');\n        // Use cached data if it's less than 24 hours old\n        if (cachedAllPrices && Date.now() - cachedAllPrices.timestamp < 24 * 60 * 60 * 1000) {\n            console.log('Using cached AllPrices data');\n            allPricesCache = cachedAllPrices.data;\n            return allPricesCache;\n        }\n        // Check if data was manually initialized via Admin panel\n        if (cachedAllPrices) {\n            console.log('Using manually initialized MTGJSON data');\n            allPricesCache = cachedAllPrices.data;\n            return allPricesCache;\n        }\n        // The AllPrices.json file is very large (200+ MB) and can cause issues\n        // Data should be initialized via Admin panel for better user experience\n        console.warn('AllPrices.json not found - use Admin panel to initialize MTGJSON data');\n        console.log('Price history features will use trend-based simulation until MTGJSON data is loaded');\n        return null;\n    // TODO: Re-enable when we have proper chunked downloading\n    // console.log('Fetching fresh AllPrices data from MTGJSON...');\n    // const response = await rateLimitedFetch('https://mtgjson.com/api/v5/AllPrices.json');\n    // \n    // if (!response.ok) {\n    //   throw new Error(`Failed to fetch AllPrices: ${response.status} ${response.statusText}`);\n    // }\n    //\n    // // Parse the JSON response with better error handling\n    // let allPricesResponse;\n    // try {\n    //   allPricesResponse = await response.json();\n    // } catch (jsonError) {\n    //   throw new Error(`Failed to parse AllPrices JSON: ${jsonError.message}. The file may be corrupted or incomplete.`);\n    // }\n    } catch (error) {\n        console.error('Failed to load AllPrices data:', error);\n        // Try to use stale cached data as fallback\n        const staleCache = getCachedData('mtgjson-all-prices-data');\n        if (staleCache) {\n            console.warn('Using stale AllPrices cache due to fetch failure');\n            allPricesCache = staleCache.data;\n            return allPricesCache;\n        }\n        return null;\n    } finally{\n        allPricesLoadingPromise = null;\n    }\n}\n// Convert MTGJSON price data to our internal format\nfunction convertMTGJSONPrices(uuid, mtgjsonPrices, cardName) {\n    const processedPrices = [];\n    try {\n        var _mtgjsonPrices_paper;\n        // Get the preferred provider's data\n        const provider = MTGJSON_CONFIG.preferredProvider;\n        const paperPrices = (_mtgjsonPrices_paper = mtgjsonPrices.paper) === null || _mtgjsonPrices_paper === void 0 ? void 0 : _mtgjsonPrices_paper[provider];\n        if (paperPrices === null || paperPrices === void 0 ? void 0 : paperPrices.normal) {\n            paperPrices.normal.forEach((pricePoint)=>{\n                processedPrices.push({\n                    cardId: uuid,\n                    date: pricePoint.date,\n                    price: pricePoint.price,\n                    priceType: 'usd'\n                });\n            });\n        }\n        if (paperPrices === null || paperPrices === void 0 ? void 0 : paperPrices.foil) {\n            paperPrices.foil.forEach((pricePoint)=>{\n                processedPrices.push({\n                    cardId: uuid,\n                    date: pricePoint.date,\n                    price: pricePoint.price,\n                    priceType: 'usdFoil'\n                });\n            });\n        }\n    } catch (error) {\n        console.error(\"Error converting MTGJSON prices for \".concat(cardName, \":\"), error);\n    }\n    return processedPrices.sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n}\n// Get price history for a Scryfall card\nasync function getPriceHistoryForCard(scryfallCard) {\n    try {\n        // First, get the MTGJSON UUID mapping\n        const uuid = await getCardMapping(scryfallCard);\n        if (!uuid) {\n            console.log(\"No MTGJSON mapping found for \".concat(scryfallCard.name));\n            return null;\n        }\n        // Fetch the price history\n        const mtgjsonPrices = await fetchPriceHistoryByUUID(uuid);\n        if (!mtgjsonPrices) {\n            return null;\n        }\n        // Convert to our internal format\n        const processedPrices = convertMTGJSONPrices(uuid, mtgjsonPrices, scryfallCard.name);\n        if (processedPrices.length === 0) {\n            return null;\n        }\n        // Calculate trend and volatility\n        const prices = processedPrices.map((p)=>p.price);\n        const averagePrice = prices.reduce((sum, price)=>sum + price, 0) / prices.length;\n        // Simple trend calculation (last 7 days vs previous 7 days)\n        const recent = prices.slice(-7);\n        const previous = prices.slice(-14, -7);\n        const recentAvg = recent.reduce((sum, p)=>sum + p, 0) / recent.length;\n        const previousAvg = previous.reduce((sum, p)=>sum + p, 0) / previous.length;\n        const trend = recentAvg > previousAvg * 1.05 ? 'up' : recentAvg < previousAvg * 0.95 ? 'down' : 'stable';\n        // Calculate volatility (standard deviation)\n        const variance = prices.reduce((sum, price)=>sum + Math.pow(price - averagePrice, 2), 0) / prices.length;\n        const volatility = Math.sqrt(variance);\n        // Calculate percentage changes\n        const percentChange24h = prices.length >= 2 ? (prices[prices.length - 1] - prices[prices.length - 2]) / prices[prices.length - 2] * 100 : undefined;\n        const percentChange7d = recent.length > 0 && previous.length > 0 ? (recentAvg - previousAvg) / previousAvg * 100 : undefined;\n        return {\n            cardId: scryfallCard.id,\n            uuid,\n            prices: processedPrices,\n            trend,\n            volatility,\n            averagePrice,\n            percentChange24h,\n            percentChange7d,\n            lastUpdated: new Date().toISOString(),\n            provider: 'mtgjson'\n        };\n    } catch (error) {\n        // Don't spam console with AllPrices errors - this is expected until data is loaded\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        if (!errorMessage.includes('AllPrices')) {\n            console.error(\"Error getting price history for \".concat(scryfallCard.name, \":\"), error);\n        }\n        return null;\n    }\n}\n// Batch fetch price histories for multiple cards\nasync function batchGetPriceHistories(cards) {\n    const results = new Map();\n    // Process cards in batches to avoid overwhelming the system\n    const batchSize = 10;\n    for(let i = 0; i < cards.length; i += batchSize){\n        const batch = cards.slice(i, i + batchSize);\n        const batchPromises = batch.map(async (card)=>{\n            const history = await getPriceHistoryForCard(card);\n            if (history) {\n                results.set(card.id, history);\n            }\n        });\n        await Promise.all(batchPromises);\n        // Add a small delay between batches\n        if (i + batchSize < cards.length) {\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n        }\n    }\n    return results;\n}\n// Utility function to clear MTGJSON cache\nfunction clearMTGJSONCache() {\n    if (false) {}\n    try {\n        const keys = Object.keys(localStorage);\n        keys.forEach((key)=>{\n            if (key.startsWith('mtgjson-')) {\n                localStorage.removeItem(key);\n            }\n        });\n        console.log('MTGJSON cache cleared');\n    } catch (error) {\n        console.error('Error clearing MTGJSON cache:', error);\n    }\n}\n// Get cache statistics\nfunction getMTGJSONCacheStats() {\n    if (false) {}\n    try {\n        const keys = Object.keys(localStorage);\n        const mtgjsonKeys = keys.filter((key)=>key.startsWith('mtgjson-'));\n        let totalSize = 0;\n        const cacheEntries = mtgjsonKeys.map((key)=>{\n            const data = localStorage.getItem(key);\n            const size = data ? data.length : 0;\n            totalSize += size;\n            return {\n                key,\n                size,\n                sizeFormatted: \"\".concat((size / 1024).toFixed(2), \" KB\")\n            };\n        });\n        return {\n            totalEntries: mtgjsonKeys.length,\n            totalSize,\n            totalSizeFormatted: \"\".concat((totalSize / 1024 / 1024).toFixed(2), \" MB\"),\n            entries: cacheEntries\n        };\n    } catch (error) {\n        console.error('Error getting cache stats:', error);\n        return null;\n    }\n}\n// Export configuration for external use\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpL210Z2pzb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBV0Esd0JBQXdCO0FBQ3hCLE1BQU1BLGlCQUFnQztJQUNwQ0MsU0FBUztJQUNUQyxhQUFhLEtBQUssS0FBSyxLQUFLO0lBQzVCQyxtQkFBbUI7SUFDbkJDLGVBQWU7QUFDakI7QUFFQSxtQkFBbUI7QUFDbkIsTUFBTUMsYUFBYTtJQUNqQkMsWUFBWTtJQUNaQyxlQUFlO0lBQ2ZDLGVBQWU7QUFDakI7QUFFQSwyRUFBMkU7QUFDM0UsTUFBTUMsbUJBQW1CLEtBQUsseUJBQXlCO0FBQ3ZELElBQUlDLGtCQUFrQjtBQUV0QixlQUFlQyxpQkFBaUJDLEdBQVc7SUFDekMsTUFBTUMsTUFBTUMsS0FBS0QsR0FBRztJQUNwQixNQUFNRSx1QkFBdUJGLE1BQU1IO0lBRW5DLElBQUlLLHVCQUF1Qk4sa0JBQWtCO1FBQzNDLE1BQU0sSUFBSU8sUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBU1IsbUJBQW1CTTtJQUN0RTtJQUVBTCxrQkFBa0JJLEtBQUtELEdBQUc7SUFFMUIsSUFBSTtRQUNGTSxRQUFRQyxHQUFHLENBQUMsMEJBQThCLE9BQUpSO1FBQ3RDLE1BQU1TLFdBQVcsTUFBTUMsTUFBTVY7UUFFN0IsSUFBSSxDQUFDUyxTQUFTRSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJQyxNQUFNLHNCQUF5Q0gsT0FBbkJBLFNBQVNJLE1BQU0sRUFBQyxLQUF1QixPQUFwQkosU0FBU0ssVUFBVTtRQUM5RTtRQUVBLE9BQU9MO0lBQ1QsRUFBRSxPQUFPTSxPQUFPO1FBQ2RSLFFBQVFRLEtBQUssQ0FBQywrQkFBK0I7WUFDM0NmO1lBQ0FlLE9BQU9BLGlCQUFpQkgsUUFBUUcsTUFBTUMsT0FBTyxHQUFHO1lBQ2hEQyxXQUFXLElBQUlmLE9BQU9nQixXQUFXO1FBQ25DO1FBRUEsSUFBSUgsaUJBQWlCSCxPQUFPO1lBQzFCLElBQUlHLE1BQU1DLE9BQU8s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YUU7WUFFYixPQUFPO2dCQUNMcEc7Z0JBQ0FvRztnQkFDQUMsZUFBZSxHQUE0QixPQUF6QixDQUFDRCxPQUFPLElBQUcsRUFBR0UsT0FBTyxDQUFDLElBQUc7WUFDN0M7UUFDRjtRQUVBLE9BQU87WUFDTEMsY0FBY1AsWUFBWXhDLE1BQU07WUFDaEMwQztZQUNBTSxvQkFBb0IsR0FBd0MsT0FBckMsQ0FBQ04sWUFBWSxPQUFPLElBQUcsRUFBR0ksT0FBTyxDQUFDLElBQUc7WUFDNURHLFNBQVNOO1FBQ1g7SUFDRixFQUFFLE9BQU96RyxPQUFPO1FBQ2RSLFFBQVFRLEtBQUssQ0FBQyw4QkFBOEJBO1FBQzVDLE9BQU87SUFDVDtBQUNGO0FBRUEsd0NBQXdDO0FBQ2QiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcbXRnLWluZGV4XFxzcmNcXGxpYlxcYXBpXFxtdGdqc29uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBNVEdKU09OQ2FyZCwgXG4gIE1UR0pTT05DYXJkUHJpY2VzLCBcbiAgTVRHSlNPTlByaWNlUG9pbnQsIFxuICBNVEdKU09OQ29uZmlnLCBcbiAgTVRHSlNPTkNhY2hlLFxuICBQcmljZUhpc3RvcnksXG4gIFByb2Nlc3NlZENhcmRQcmljZSxcbiAgTVRHQ2FyZCBcbn0gZnJvbSAnQC9saWIvdHlwZXMnO1xuXG4vLyBNVEdKU09OIENvbmZpZ3VyYXRpb25cbmNvbnN0IE1UR0pTT05fQ09ORklHOiBNVEdKU09OQ29uZmlnID0ge1xuICBiYXNlVXJsOiAnaHR0cHM6Ly9tdGdqc29uLmNvbS9hcGkvdjUnLFxuICBjYWNoZUV4cGlyeTogMjQgKiA2MCAqIDYwICogMTAwMCwgLy8gMjQgaG91cnNcbiAgcHJlZmVycmVkUHJvdmlkZXI6ICd0Y2dwbGF5ZXInLFxuICBlbmFibGVDYWNoaW5nOiB0cnVlLFxufTtcblxuLy8gQ2FjaGUgbWFuYWdlbWVudFxuY29uc3QgQ0FDSEVfS0VZUyA9IHtcbiAgQUxMX1BSSUNFUzogJ210Z2pzb24tYWxsLXByaWNlcycsXG4gIENBUkRfTUFQUElOR1M6ICdtdGdqc29uLWNhcmQtbWFwcGluZ3MnLFxuICBQUklDRV9ISVNUT1JZOiAnbXRnanNvbi1wcmljZS1oaXN0b3J5LScsXG59IGFzIGNvbnN0O1xuXG4vLyBSYXRlIGxpbWl0aW5nOiBNVEdKU09OIGRvZXNuJ3Qgc3BlY2lmeSBsaW1pdHMsIGJ1dCB3ZSdsbCBiZSBjb25zZXJ2YXRpdmVcbmNvbnN0IFJBVEVfTElNSVRfREVMQVkgPSAyMDA7IC8vIDIwMG1zIGJldHdlZW4gcmVxdWVzdHNcbmxldCBsYXN0UmVxdWVzdFRpbWUgPSAwO1xuXG5hc3luYyBmdW5jdGlvbiByYXRlTGltaXRlZEZldGNoKHVybDogc3RyaW5nKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICBjb25zdCB0aW1lU2luY2VMYXN0UmVxdWVzdCA9IG5vdyAtIGxhc3RSZXF1ZXN0VGltZTtcbiAgXG4gIGlmICh0aW1lU2luY2VMYXN0UmVxdWVzdCA8IFJBVEVfTElNSVRfREVMQVkpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgUkFURV9MSU1JVF9ERUxBWSAtIHRpbWVTaW5jZUxhc3RSZXF1ZXN0KSk7XG4gIH1cbiAgXG4gIGxhc3RSZXF1ZXN0VGltZSA9IERhdGUubm93KCk7XG4gIFxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBNVEdKU09OIGRhdGE6ICR7dXJsfWApO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1UR0pTT04gQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignTVRHSlNPTiBBUEkgcmVxdWVzdCBmYWlsZWQ6Jywge1xuICAgICAgdXJsLFxuICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0ZhaWxlZCB0byBmZXRjaCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayBlcnJvcjogVW5hYmxlIHRvIGNvbm5lY3QgdG8gTVRHSlNPTiBBUEkuIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24uJyk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIENhY2hlIHV0aWxpdGllc1xuZnVuY3Rpb24gZ2V0Q2FjaGVkRGF0YTxUPihrZXk6IHN0cmluZyk6IFQgfCBudWxsIHtcbiAgaWYgKCFNVEdKU09OX0NPTkZJRy5lbmFibGVDYWNoaW5nIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGNhY2hlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgaWYgKCFjYWNoZWQpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShjYWNoZWQpO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgXG4gICAgaWYgKHBhcnNlZC5leHBpcmVzQXQgJiYgbm93ID4gcGFyc2VkLmV4cGlyZXNBdCkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZWFkaW5nIGNhY2hlIGZvciBrZXkgJHtrZXl9OmAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDYWNoZWREYXRhPFQ+KGtleTogc3RyaW5nLCBkYXRhOiBULCBjdXN0b21FeHBpcnk/OiBudW1iZXIpOiB2b2lkIHtcbiAgaWYgKCFNVEdKU09OX0NPTkZJRy5lbmFibGVDYWNoaW5nIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBleHBpcnkgPSBjdXN0b21FeHBpcnkgfHwgTVRHSlNPTl9DT05GSUcuY2FjaGVFeHBpcnk7XG4gICAgY29uc3QgY2FjaGVFbnRyeSA9IHtcbiAgICAgIGRhdGEsXG4gICAgICBleHBpcmVzQXQ6IERhdGUubm93KCkgKyBleHBpcnksXG4gICAgICBjYWNoZWRBdDogRGF0ZS5ub3coKSxcbiAgICB9O1xuXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShjYWNoZUVudHJ5KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2V0dGluZyBjYWNoZSBmb3Iga2V5ICR7a2V5fTpgLCBlcnJvcik7XG4gIH1cbn1cblxuLy8gSW1wb3J0IHRoZSBjYXJkIG1hcHBpbmcgc2VydmljZVxuaW1wb3J0IHsgY2FyZE1hcHBpbmdTZXJ2aWNlIH0gZnJvbSAnQC9saWIvc2VydmljZXMvY2FyZE1hcHBpbmdTZXJ2aWNlJztcblxuLy8gTWFwIFNjcnlmYWxsIGNhcmQgdG8gTVRHSlNPTiBVVUlEXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FyZE1hcHBpbmcoc2NyeWZhbGxDYXJkOiBNVEdDYXJkKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIHRoZSBjYXJkIG1hcHBpbmcgc2VydmljZVxuICAgIGNvbnN0IHV1aWQgPSBhd2FpdCBjYXJkTWFwcGluZ1NlcnZpY2UuZ2V0TWFwcGluZyhzY3J5ZmFsbENhcmQpO1xuICAgIFxuICAgIGlmICh1dWlkKSB7XG4gICAgICAvLyBDYWNoZSB0aGUgc3VjY2Vzc2Z1bCBtYXBwaW5nXG4gICAgICBjb25zdCBjYWNoZUtleSA9IGAke0NBQ0hFX0tFWVMuQ0FSRF9NQVBQSU5HU30ke3NjcnlmYWxsQ2FyZC5pZH1gO1xuICAgICAgc2V0Q2FjaGVkRGF0YShjYWNoZUtleSwgdXVpZCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB1dWlkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGdldHRpbmcgY2FyZCBtYXBwaW5nIGZvciAke3NjcnlmYWxsQ2FyZC5uYW1lfTpgLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gRmV0Y2ggcHJpY2UgaGlzdG9yeSBmb3IgYSBzcGVjaWZpYyBVVUlEXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQcmljZUhpc3RvcnlCeVVVSUQodXVpZDogc3RyaW5nKTogUHJvbWlzZTxNVEdKU09OQ2FyZFByaWNlcyB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7Q0FDSEVfS0VZUy5QUklDRV9ISVNUT1JZfSR7dXVpZH1gO1xuICAgIGNvbnN0IGNhY2hlZCA9IGdldENhY2hlZERhdGE8TVRHSlNPTkNhcmRQcmljZXM+KGNhY2hlS2V5KTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuXG4gICAgLy8gVHJ5IHRvIGdldCBmcm9tIEFsbFByaWNlcyBkYXRhXG4gICAgY29uc3QgcHJpY2VEYXRhID0gYXdhaXQgZ2V0QWxsUHJpY2VzRGF0YSgpO1xuICAgIGlmIChwcmljZURhdGEgJiYgcHJpY2VEYXRhW3V1aWRdKSB7XG4gICAgICBjb25zdCBjYXJkUHJpY2VzID0gcHJpY2VEYXRhW3V1aWRdO1xuICAgICAgXG4gICAgICAvLyBDYWNoZSB0aGUgcmVzdWx0XG4gICAgICBzZXRDYWNoZWREYXRhKGNhY2hlS2V5LCBjYXJkUHJpY2VzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGNhcmRQcmljZXM7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYE5vIHByaWNlIGhpc3RvcnkgZm91bmQgZm9yIFVVSUQgJHt1dWlkfWApO1xuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByaWNlIGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIEZldGNoIGFuZCBjYWNoZSBBbGxQcmljZXMuanNvbiBkYXRhXG5sZXQgYWxsUHJpY2VzQ2FjaGU6IFJlY29yZDxzdHJpbmcsIE1UR0pTT05DYXJkUHJpY2VzPiB8IG51bGwgPSBudWxsO1xubGV0IGFsbFByaWNlc0xvYWRpbmdQcm9taXNlOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIE1UR0pTT05DYXJkUHJpY2VzPiB8IG51bGw+IHwgbnVsbCA9IG51bGw7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEFsbFByaWNlc0RhdGEoKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBNVEdKU09OQ2FyZFByaWNlcz4gfCBudWxsPiB7XG4gIC8vIFJldHVybiBjYWNoZWQgZGF0YSBpZiBhdmFpbGFibGVcbiAgaWYgKGFsbFByaWNlc0NhY2hlKSB7XG4gICAgcmV0dXJuIGFsbFByaWNlc0NhY2hlO1xuICB9XG5cbiAgLy8gUmV0dXJuIGV4aXN0aW5nIGxvYWRpbmcgcHJvbWlzZSBpZiBpbiBwcm9ncmVzc1xuICBpZiAoYWxsUHJpY2VzTG9hZGluZ1Byb21pc2UpIHtcbiAgICByZXR1cm4gYWxsUHJpY2VzTG9hZGluZ1Byb21pc2U7XG4gIH1cblxuICAvLyBTdGFydCBsb2FkaW5nIEFsbFByaWNlcyBkYXRhXG4gIGFsbFByaWNlc0xvYWRpbmdQcm9taXNlID0gbG9hZEFsbFByaWNlc0RhdGEoKTtcbiAgcmV0dXJuIGFsbFByaWNlc0xvYWRpbmdQcm9taXNlO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkQWxsUHJpY2VzRGF0YSgpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIE1UR0pTT05DYXJkUHJpY2VzPiB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnTG9hZGluZyBNVEdKU09OIEFsbFByaWNlcyBkYXRhLi4uJyk7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGNhY2hlZCBBbGxQcmljZXMgZGF0YVxuICAgIGNvbnN0IGNhY2hlZEFsbFByaWNlcyA9IGdldENhY2hlZERhdGE8e1xuICAgICAgZGF0YTogUmVjb3JkPHN0cmluZywgTVRHSlNPTkNhcmRQcmljZXM+O1xuICAgICAgdGltZXN0YW1wOiBudW1iZXI7XG4gICAgICB2ZXJzaW9uOiBzdHJpbmc7XG4gICAgfT4oJ210Z2pzb24tYWxsLXByaWNlcy1kYXRhJyk7XG5cbiAgICAvLyBVc2UgY2FjaGVkIGRhdGEgaWYgaXQncyBsZXNzIHRoYW4gMjQgaG91cnMgb2xkXG4gICAgaWYgKGNhY2hlZEFsbFByaWNlcyAmJiAoRGF0ZS5ub3coKSAtIGNhY2hlZEFsbFByaWNlcy50aW1lc3RhbXApIDwgMjQgKiA2MCAqIDYwICogMTAwMCkge1xuICAgICAgY29uc29sZS5sb2coJ1VzaW5nIGNhY2hlZCBBbGxQcmljZXMgZGF0YScpO1xuICAgICAgYWxsUHJpY2VzQ2FjaGUgPSBjYWNoZWRBbGxQcmljZXMuZGF0YTtcbiAgICAgIHJldHVybiBhbGxQcmljZXNDYWNoZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBkYXRhIHdhcyBtYW51YWxseSBpbml0aWFsaXplZCB2aWEgQWRtaW4gcGFuZWxcbiAgICBpZiAoY2FjaGVkQWxsUHJpY2VzKSB7XG4gICAgICBjb25zb2xlLmxvZygnVXNpbmcgbWFudWFsbHkgaW5pdGlhbGl6ZWQgTVRHSlNPTiBkYXRhJyk7XG4gICAgICBhbGxQcmljZXNDYWNoZSA9IGNhY2hlZEFsbFByaWNlcy5kYXRhO1xuICAgICAgcmV0dXJuIGFsbFByaWNlc0NhY2hlO1xuICAgIH1cblxuICAgIC8vIFRoZSBBbGxQcmljZXMuanNvbiBmaWxlIGlzIHZlcnkgbGFyZ2UgKDIwMCsgTUIpIGFuZCBjYW4gY2F1c2UgaXNzdWVzXG4gICAgLy8gRGF0YSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgdmlhIEFkbWluIHBhbmVsIGZvciBiZXR0ZXIgdXNlciBleHBlcmllbmNlXG4gICAgY29uc29sZS53YXJuKCdBbGxQcmljZXMuanNvbiBub3QgZm91bmQgLSB1c2UgQWRtaW4gcGFuZWwgdG8gaW5pdGlhbGl6ZSBNVEdKU09OIGRhdGEnKTtcbiAgICBjb25zb2xlLmxvZygnUHJpY2UgaGlzdG9yeSBmZWF0dXJlcyB3aWxsIHVzZSB0cmVuZC1iYXNlZCBzaW11bGF0aW9uIHVudGlsIE1UR0pTT04gZGF0YSBpcyBsb2FkZWQnKTtcbiAgICBcbiAgICByZXR1cm4gbnVsbDtcblxuICAgIC8vIFRPRE86IFJlLWVuYWJsZSB3aGVuIHdlIGhhdmUgcHJvcGVyIGNodW5rZWQgZG93bmxvYWRpbmdcbiAgICAvLyBjb25zb2xlLmxvZygnRmV0Y2hpbmcgZnJlc2ggQWxsUHJpY2VzIGRhdGEgZnJvbSBNVEdKU09OLi4uJyk7XG4gICAgLy8gY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByYXRlTGltaXRlZEZldGNoKCdodHRwczovL210Z2pzb24uY29tL2FwaS92NS9BbGxQcmljZXMuanNvbicpO1xuICAgIC8vIFxuICAgIC8vIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAvLyAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIEFsbFByaWNlczogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAvLyB9XG4gICAgLy9cbiAgICAvLyAvLyBQYXJzZSB0aGUgSlNPTiByZXNwb25zZSB3aXRoIGJldHRlciBlcnJvciBoYW5kbGluZ1xuICAgIC8vIGxldCBhbGxQcmljZXNSZXNwb25zZTtcbiAgICAvLyB0cnkge1xuICAgIC8vICAgYWxsUHJpY2VzUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgLy8gfSBjYXRjaCAoanNvbkVycm9yKSB7XG4gICAgLy8gICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBBbGxQcmljZXMgSlNPTjogJHtqc29uRXJyb3IubWVzc2FnZX0uIFRoZSBmaWxlIG1heSBiZSBjb3JydXB0ZWQgb3IgaW5jb21wbGV0ZS5gKTtcbiAgICAvLyB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgQWxsUHJpY2VzIGRhdGE6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIFRyeSB0byB1c2Ugc3RhbGUgY2FjaGVkIGRhdGEgYXMgZmFsbGJhY2tcbiAgICBjb25zdCBzdGFsZUNhY2hlID0gZ2V0Q2FjaGVkRGF0YTx7XG4gICAgICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBNVEdKU09OQ2FyZFByaWNlcz47XG4gICAgICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgICB9PignbXRnanNvbi1hbGwtcHJpY2VzLWRhdGEnKTtcblxuICAgIGlmIChzdGFsZUNhY2hlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1VzaW5nIHN0YWxlIEFsbFByaWNlcyBjYWNoZSBkdWUgdG8gZmV0Y2ggZmFpbHVyZScpO1xuICAgICAgYWxsUHJpY2VzQ2FjaGUgPSBzdGFsZUNhY2hlLmRhdGE7XG4gICAgICByZXR1cm4gYWxsUHJpY2VzQ2FjaGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZmluYWxseSB7XG4gICAgYWxsUHJpY2VzTG9hZGluZ1Byb21pc2UgPSBudWxsO1xuICB9XG59XG5cbi8vIENvbnZlcnQgTVRHSlNPTiBwcmljZSBkYXRhIHRvIG91ciBpbnRlcm5hbCBmb3JtYXRcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0TVRHSlNPTlByaWNlcyhcbiAgdXVpZDogc3RyaW5nLFxuICBtdGdqc29uUHJpY2VzOiBNVEdKU09OQ2FyZFByaWNlcyxcbiAgY2FyZE5hbWU6IHN0cmluZ1xuKTogUHJvY2Vzc2VkQ2FyZFByaWNlW10ge1xuICBjb25zdCBwcm9jZXNzZWRQcmljZXM6IFByb2Nlc3NlZENhcmRQcmljZVtdID0gW107XG4gIFxuICB0cnkge1xuICAgIC8vIEdldCB0aGUgcHJlZmVycmVkIHByb3ZpZGVyJ3MgZGF0YVxuICAgIGNvbnN0IHByb3ZpZGVyID0gTVRHSlNPTl9DT05GSUcucHJlZmVycmVkUHJvdmlkZXI7XG4gICAgY29uc3QgcGFwZXJQcmljZXMgPSBtdGdqc29uUHJpY2VzLnBhcGVyPy5bcHJvdmlkZXJdO1xuICAgIFxuICAgIGlmIChwYXBlclByaWNlcz8ubm9ybWFsKSB7XG4gICAgICBwYXBlclByaWNlcy5ub3JtYWwuZm9yRWFjaChwcmljZVBvaW50ID0+IHtcbiAgICAgICAgcHJvY2Vzc2VkUHJpY2VzLnB1c2goe1xuICAgICAgICAgIGNhcmRJZDogdXVpZCxcbiAgICAgICAgICBkYXRlOiBwcmljZVBvaW50LmRhdGUsXG4gICAgICAgICAgcHJpY2U6IHByaWNlUG9pbnQucHJpY2UsXG4gICAgICAgICAgcHJpY2VUeXBlOiAndXNkJyxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHBhcGVyUHJpY2VzPy5mb2lsKSB7XG4gICAgICBwYXBlclByaWNlcy5mb2lsLmZvckVhY2gocHJpY2VQb2ludCA9PiB7XG4gICAgICAgIHByb2Nlc3NlZFByaWNlcy5wdXNoKHtcbiAgICAgICAgICBjYXJkSWQ6IHV1aWQsXG4gICAgICAgICAgZGF0ZTogcHJpY2VQb2ludC5kYXRlLFxuICAgICAgICAgIHByaWNlOiBwcmljZVBvaW50LnByaWNlLFxuICAgICAgICAgIHByaWNlVHlwZTogJ3VzZEZvaWwnLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjb252ZXJ0aW5nIE1UR0pTT04gcHJpY2VzIGZvciAke2NhcmROYW1lfTpgLCBlcnJvcik7XG4gIH1cbiAgXG4gIHJldHVybiBwcm9jZXNzZWRQcmljZXMuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYS5kYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShiLmRhdGUpLmdldFRpbWUoKSk7XG59XG5cbi8vIEdldCBwcmljZSBoaXN0b3J5IGZvciBhIFNjcnlmYWxsIGNhcmRcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcmljZUhpc3RvcnlGb3JDYXJkKHNjcnlmYWxsQ2FyZDogTVRHQ2FyZCk6IFByb21pc2U8UHJpY2VIaXN0b3J5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIC8vIEZpcnN0LCBnZXQgdGhlIE1UR0pTT04gVVVJRCBtYXBwaW5nXG4gICAgY29uc3QgdXVpZCA9IGF3YWl0IGdldENhcmRNYXBwaW5nKHNjcnlmYWxsQ2FyZCk7XG4gICAgaWYgKCF1dWlkKSB7XG4gICAgICBjb25zb2xlLmxvZyhgTm8gTVRHSlNPTiBtYXBwaW5nIGZvdW5kIGZvciAke3NjcnlmYWxsQ2FyZC5uYW1lfWApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gRmV0Y2ggdGhlIHByaWNlIGhpc3RvcnlcbiAgICBjb25zdCBtdGdqc29uUHJpY2VzID0gYXdhaXQgZmV0Y2hQcmljZUhpc3RvcnlCeVVVSUQodXVpZCk7XG4gICAgaWYgKCFtdGdqc29uUHJpY2VzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IHRvIG91ciBpbnRlcm5hbCBmb3JtYXRcbiAgICBjb25zdCBwcm9jZXNzZWRQcmljZXMgPSBjb252ZXJ0TVRHSlNPTlByaWNlcyh1dWlkLCBtdGdqc29uUHJpY2VzLCBzY3J5ZmFsbENhcmQubmFtZSk7XG4gICAgXG4gICAgaWYgKHByb2Nlc3NlZFByaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0cmVuZCBhbmQgdm9sYXRpbGl0eVxuICAgIGNvbnN0IHByaWNlcyA9IHByb2Nlc3NlZFByaWNlcy5tYXAocCA9PiBwLnByaWNlKTtcbiAgICBjb25zdCBhdmVyYWdlUHJpY2UgPSBwcmljZXMucmVkdWNlKChzdW0sIHByaWNlKSA9PiBzdW0gKyBwcmljZSwgMCkgLyBwcmljZXMubGVuZ3RoO1xuICAgIFxuICAgIC8vIFNpbXBsZSB0cmVuZCBjYWxjdWxhdGlvbiAobGFzdCA3IGRheXMgdnMgcHJldmlvdXMgNyBkYXlzKVxuICAgIGNvbnN0IHJlY2VudCA9IHByaWNlcy5zbGljZSgtNyk7XG4gICAgY29uc3QgcHJldmlvdXMgPSBwcmljZXMuc2xpY2UoLTE0LCAtNyk7XG4gICAgY29uc3QgcmVjZW50QXZnID0gcmVjZW50LnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLCAwKSAvIHJlY2VudC5sZW5ndGg7XG4gICAgY29uc3QgcHJldmlvdXNBdmcgPSBwcmV2aW91cy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcCwgMCkgLyBwcmV2aW91cy5sZW5ndGg7XG4gICAgXG4gICAgY29uc3QgdHJlbmQ6ICd1cCcgfCAnZG93bicgfCAnc3RhYmxlJyA9IFxuICAgICAgcmVjZW50QXZnID4gcHJldmlvdXNBdmcgKiAxLjA1ID8gJ3VwJyA6XG4gICAgICByZWNlbnRBdmcgPCBwcmV2aW91c0F2ZyAqIDAuOTUgPyAnZG93bicgOiAnc3RhYmxlJztcblxuICAgIC8vIENhbGN1bGF0ZSB2b2xhdGlsaXR5IChzdGFuZGFyZCBkZXZpYXRpb24pXG4gICAgY29uc3QgdmFyaWFuY2UgPSBwcmljZXMucmVkdWNlKChzdW0sIHByaWNlKSA9PiBzdW0gKyBNYXRoLnBvdyhwcmljZSAtIGF2ZXJhZ2VQcmljZSwgMiksIDApIC8gcHJpY2VzLmxlbmd0aDtcbiAgICBjb25zdCB2b2xhdGlsaXR5ID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcblxuICAgIC8vIENhbGN1bGF0ZSBwZXJjZW50YWdlIGNoYW5nZXNcbiAgICBjb25zdCBwZXJjZW50Q2hhbmdlMjRoID0gcHJpY2VzLmxlbmd0aCA+PSAyID8gXG4gICAgICAoKHByaWNlc1twcmljZXMubGVuZ3RoIC0gMV0gLSBwcmljZXNbcHJpY2VzLmxlbmd0aCAtIDJdKSAvIHByaWNlc1twcmljZXMubGVuZ3RoIC0gMl0pICogMTAwIDogdW5kZWZpbmVkO1xuICAgIFxuICAgIGNvbnN0IHBlcmNlbnRDaGFuZ2U3ZCA9IHJlY2VudC5sZW5ndGggPiAwICYmIHByZXZpb3VzLmxlbmd0aCA+IDAgPyBcbiAgICAgICgocmVjZW50QXZnIC0gcHJldmlvdXNBdmcpIC8gcHJldmlvdXNBdmcpICogMTAwIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcmRJZDogc2NyeWZhbGxDYXJkLmlkLFxuICAgICAgdXVpZCxcbiAgICAgIHByaWNlczogcHJvY2Vzc2VkUHJpY2VzLFxuICAgICAgdHJlbmQsXG4gICAgICB2b2xhdGlsaXR5LFxuICAgICAgYXZlcmFnZVByaWNlLFxuICAgICAgcGVyY2VudENoYW5nZTI0aCxcbiAgICAgIHBlcmNlbnRDaGFuZ2U3ZCxcbiAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBwcm92aWRlcjogJ210Z2pzb24nLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gRG9uJ3Qgc3BhbSBjb25zb2xlIHdpdGggQWxsUHJpY2VzIGVycm9ycyAtIHRoaXMgaXMgZXhwZWN0ZWQgdW50aWwgZGF0YSBpcyBsb2FkZWRcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJztcbiAgICBpZiAoIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnQWxsUHJpY2VzJykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGdldHRpbmcgcHJpY2UgaGlzdG9yeSBmb3IgJHtzY3J5ZmFsbENhcmQubmFtZX06YCwgZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyBCYXRjaCBmZXRjaCBwcmljZSBoaXN0b3JpZXMgZm9yIG11bHRpcGxlIGNhcmRzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYmF0Y2hHZXRQcmljZUhpc3RvcmllcyhjYXJkczogTVRHQ2FyZFtdKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBQcmljZUhpc3Rvcnk+PiB7XG4gIGNvbnN0IHJlc3VsdHMgPSBuZXcgTWFwPHN0cmluZywgUHJpY2VIaXN0b3J5PigpO1xuICBcbiAgLy8gUHJvY2VzcyBjYXJkcyBpbiBiYXRjaGVzIHRvIGF2b2lkIG92ZXJ3aGVsbWluZyB0aGUgc3lzdGVtXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IDEwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNhcmRzLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcbiAgICBjb25zdCBiYXRjaCA9IGNhcmRzLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpO1xuICAgIFxuICAgIGNvbnN0IGJhdGNoUHJvbWlzZXMgPSBiYXRjaC5tYXAoYXN5bmMgKGNhcmQpID0+IHtcbiAgICAgIGNvbnN0IGhpc3RvcnkgPSBhd2FpdCBnZXRQcmljZUhpc3RvcnlGb3JDYXJkKGNhcmQpO1xuICAgICAgaWYgKGhpc3RvcnkpIHtcbiAgICAgICAgcmVzdWx0cy5zZXQoY2FyZC5pZCwgaGlzdG9yeSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoYmF0Y2hQcm9taXNlcyk7XG4gICAgXG4gICAgLy8gQWRkIGEgc21hbGwgZGVsYXkgYmV0d2VlbiBiYXRjaGVzXG4gICAgaWYgKGkgKyBiYXRjaFNpemUgPCBjYXJkcy5sZW5ndGgpIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuLy8gVXRpbGl0eSBmdW5jdGlvbiB0byBjbGVhciBNVEdKU09OIGNhY2hlXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJNVEdKU09OQ2FjaGUoKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgdHJ5IHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKTtcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnbXRnanNvbi0nKSkge1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCdNVEdKU09OIGNhY2hlIGNsZWFyZWQnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbGVhcmluZyBNVEdKU09OIGNhY2hlOicsIGVycm9yKTtcbiAgfVxufVxuXG4vLyBHZXQgY2FjaGUgc3RhdGlzdGljc1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1UR0pTT05DYWNoZVN0YXRzKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsO1xuICBcbiAgdHJ5IHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKTtcbiAgICBjb25zdCBtdGdqc29uS2V5cyA9IGtleXMuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aCgnbXRnanNvbi0nKSk7XG4gICAgXG4gICAgbGV0IHRvdGFsU2l6ZSA9IDA7XG4gICAgY29uc3QgY2FjaGVFbnRyaWVzID0gbXRnanNvbktleXMubWFwKGtleSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIGNvbnN0IHNpemUgPSBkYXRhID8gZGF0YS5sZW5ndGggOiAwO1xuICAgICAgdG90YWxTaXplICs9IHNpemU7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleSxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgc2l6ZUZvcm1hdHRlZDogYCR7KHNpemUgLyAxMDI0KS50b0ZpeGVkKDIpfSBLQmAsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbEVudHJpZXM6IG10Z2pzb25LZXlzLmxlbmd0aCxcbiAgICAgIHRvdGFsU2l6ZSxcbiAgICAgIHRvdGFsU2l6ZUZvcm1hdHRlZDogYCR7KHRvdGFsU2l6ZSAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDIpfSBNQmAsXG4gICAgICBlbnRyaWVzOiBjYWNoZUVudHJpZXMsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGNhY2hlIHN0YXRzOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyBFeHBvcnQgY29uZmlndXJhdGlvbiBmb3IgZXh0ZXJuYWwgdXNlXG5leHBvcnQgeyBNVEdKU09OX0NPTkZJRyB9O1xuIl0sIm5hbWVzIjpbIk1UR0pTT05fQ09ORklHIiwiYmFzZVVybCIsImNhY2hlRXhwaXJ5IiwicHJlZmVycmVkUHJvdmlkZXIiLCJlbmFibGVDYWNoaW5nIiwiQ0FDSEVfS0VZUyIsIkFMTF9QUklDRVMiLCJDQVJEX01BUFBJTkdTIiwiUFJJQ0VfSElTVE9SWSIsIlJBVEVfTElNSVRfREVMQVkiLCJsYXN0UmVxdWVzdFRpbWUiLCJyYXRlTGltaXRlZEZldGNoIiwidXJsIiwibm93IiwiRGF0ZSIsInRpbWVTaW5jZUxhc3RSZXF1ZXN0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiY29uc29sZSIsImxvZyIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImVycm9yIiwibWVzc2FnZSIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwiaW5jbHVkZXMiLCJnZXRDYWNoZWREYXRhIiwia2V5IiwiY2FjaGVkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlZCIsIkpTT04iLCJwYXJzZSIsImV4cGlyZXNBdCIsInJlbW92ZUl0ZW0iLCJkYXRhIiwic2V0Q2FjaGVkRGF0YSIsImN1c3RvbUV4cGlyeSIsImV4cGlyeSIsImNhY2hlRW50cnkiLCJjYWNoZWRBdCIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJjYXJkTWFwcGluZ1NlcnZpY2UiLCJnZXRDYXJkTWFwcGluZyIsInNjcnlmYWxsQ2FyZCIsInV1aWQiLCJnZXRNYXBwaW5nIiwiY2FjaGVLZXkiLCJpZCIsIm5hbWUiLCJmZXRjaFByaWNlSGlzdG9yeUJ5VVVJRCIsInByaWNlRGF0YSIsImdldEFsbFByaWNlc0RhdGEiLCJjYXJkUHJpY2VzIiwiYWxsUHJpY2VzQ2FjaGUiLCJhbGxQcmljZXNMb2FkaW5nUHJvbWlzZSIsImxvYWRBbGxQcmljZXNEYXRhIiwiY2FjaGVkQWxsUHJpY2VzIiwid2FybiIsInN0YWxlQ2FjaGUiLCJjb252ZXJ0TVRHSlNPTlByaWNlcyIsIm10Z2pzb25QcmljZXMiLCJjYXJkTmFtZSIsInByb2Nlc3NlZFByaWNlcyIsInByb3ZpZGVyIiwicGFwZXJQcmljZXMiLCJwYXBlciIsIm5vcm1hbCIsImZvckVhY2giLCJwcmljZVBvaW50IiwicHVzaCIsImNhcmRJZCIsImRhdGUiLCJwcmljZSIsInByaWNlVHlwZSIsImZvaWwiLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwiZ2V0UHJpY2VIaXN0b3J5Rm9yQ2FyZCIsImxlbmd0aCIsInByaWNlcyIsIm1hcCIsInAiLCJhdmVyYWdlUHJpY2UiLCJyZWR1Y2UiLCJzdW0iLCJyZWNlbnQiLCJzbGljZSIsInByZXZpb3VzIiwicmVjZW50QXZnIiwicHJldmlvdXNBdmciLCJ0cmVuZCIsInZhcmlhbmNlIiwiTWF0aCIsInBvdyIsInZvbGF0aWxpdHkiLCJzcXJ0IiwicGVyY2VudENoYW5nZTI0aCIsInVuZGVmaW5lZCIsInBlcmNlbnRDaGFuZ2U3ZCIsImxhc3RVcGRhdGVkIiwiZXJyb3JNZXNzYWdlIiwiYmF0Y2hHZXRQcmljZUhpc3RvcmllcyIsImNhcmRzIiwicmVzdWx0cyIsIk1hcCIsImJhdGNoU2l6ZSIsImkiLCJiYXRjaCIsImJhdGNoUHJvbWlzZXMiLCJjYXJkIiwiaGlzdG9yeSIsInNldCIsImFsbCIsImNsZWFyTVRHSlNPTkNhY2hlIiwia2V5cyIsIk9iamVjdCIsInN0YXJ0c1dpdGgiLCJnZXRNVEdKU09OQ2FjaGVTdGF0cyIsIm10Z2pzb25LZXlzIiwiZmlsdGVyIiwidG90YWxTaXplIiwiY2FjaGVFbnRyaWVzIiwic2l6ZSIsInNpemVGb3JtYXR0ZWQiLCJ0b0ZpeGVkIiwidG90YWxFbnRyaWVzIiwidG90YWxTaXplRm9ybWF0dGVkIiwiZW50cmllcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api/mtgjson.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/services/cardMappingService.ts":
/*!************************************************!*\
  !*** ./src/lib/services/cardMappingService.ts ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cardMappingService: () => (/* binding */ cardMappingService)\n/* harmony export */ });\n/* harmony import */ var _lib_utils_mtgjsonCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/utils/mtgjsonCache */ \"(app-pages-browser)/./src/lib/utils/mtgjsonCache.ts\");\n\nclass CardMappingService {\n    /**\r\n   * Initialize the mapping service by loading AllPrintings data\r\n   */ async initialize() {\n        if (this.loadingPromise) {\n            return this.loadingPromise;\n        }\n        this.loadingPromise = this.loadAllPrintingsData();\n        return this.loadingPromise;\n    }\n    /**\r\n   * Load and cache AllPrintings.json data\r\n   */ async loadAllPrintingsData() {\n        try {\n            console.log('Loading MTGJSON AllPrintings data...');\n            // Try to load from cache first\n            const cached = await this.getCachedAllPrintings();\n            if (cached && this.isDataFresh(cached.meta.date)) {\n                this.allPrintingsData = cached;\n                console.log('Loaded AllPrintings from cache');\n                await this.loadMappingCache();\n                return;\n            }\n            // Fetch fresh data from MTGJSON\n            console.log('Fetching fresh AllPrintings data from MTGJSON...');\n            const response = await fetch(this.MTGJSON_ALL_PRINTINGS_URL);\n            if (!response.ok) {\n                throw new Error(\"Failed to fetch AllPrintings: \".concat(response.status, \" \").concat(response.statusText));\n            }\n            // Parse the response\n            const data = await response.json();\n            if (!data.data || !data.meta) {\n                throw new Error('Invalid AllPrintings response format');\n            }\n            this.allPrintingsData = data;\n            // Store using the optimized storage system\n            const { allPrintingsStorage } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_utils_allPrintingsStorage_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/utils/allPrintingsStorage */ \"(app-pages-browser)/./src/lib/utils/allPrintingsStorage.ts\"));\n            await allPrintingsStorage.storeAllPrintings(data);\n            await this.loadMappingCache();\n            console.log(\"Loaded \".concat(Object.keys(data.data).length, \" sets from MTGJSON\"));\n        } catch (error) {\n            console.error('Failed to load AllPrintings data:', error);\n            // Try to use optimized storage as fallback\n            try {\n                const { allPrintingsStorage } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_utils_allPrintingsStorage_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/utils/allPrintingsStorage */ \"(app-pages-browser)/./src/lib/utils/allPrintingsStorage.ts\"));\n                const isAvailable = await allPrintingsStorage.isDataAvailable();\n                if (isAvailable) {\n                    console.log('Using stored AllPrintings data as fallback');\n                    // We'll work with the stored data without loading everything into memory\n                    await this.loadMappingCache();\n                    return;\n                }\n            } catch (storageError) {\n                console.error('Failed to access stored AllPrintings data:', storageError);\n            }\n            throw new Error('Failed to load AllPrintings data and no cache available');\n        }\n    }\n    /**\r\n   * Get the MTGJSON UUID for a Scryfall card\r\n   */ async getMapping(scryfallCard) {\n        await this.initialize();\n        // Check cache first\n        const cached = this.mappingCache.get(scryfallCard.id);\n        if (cached) {\n            return cached.mtgjsonUuid;\n        }\n        // Try to find mapping\n        const mapping = await this.findCardMapping(scryfallCard);\n        if (mapping) {\n            // Cache the mapping\n            this.mappingCache.set(scryfallCard.id, mapping);\n            await this.saveMappingToCache(mapping);\n            return mapping.mtgjsonUuid;\n        }\n        return null;\n    }\n    /**\r\n   * Find mapping for a Scryfall card using multiple strategies\r\n   */ async findCardMapping(scryfallCard) {\n        // First try with in-memory AllPrintings data if available\n        if (this.allPrintingsData) {\n            const strategies = [\n                ()=>this.findByDirectScryfallId(scryfallCard),\n                ()=>this.findByNameAndSet(scryfallCard),\n                ()=>this.findByCollectorNumber(scryfallCard),\n                ()=>this.findByFuzzyName(scryfallCard)\n            ];\n            for (const strategy of strategies){\n                const result = strategy();\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        // Fallback to optimized storage search\n        try {\n            const { allPrintingsStorage } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_utils_allPrintingsStorage_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/utils/allPrintingsStorage */ \"(app-pages-browser)/./src/lib/utils/allPrintingsStorage.ts\"));\n            // Strategy 1: Direct Scryfall ID search\n            if (scryfallCard.scryfallId) {\n                const card = await allPrintingsStorage.findCardByScryfallId(scryfallCard.scryfallId);\n                if (card) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: 1.0,\n                        matchMethod: 'direct',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n            }\n            // Strategy 2: Search by name and try to match with set\n            const searchResults = await allPrintingsStorage.searchCards(scryfallCard.name, 20);\n            for (const card of searchResults){\n                // Exact name and set match\n                if (this.normalizeCardName(card.name) === this.normalizeCardName(scryfallCard.name) && card.setCode.toLowerCase() === scryfallCard.setCode.toLowerCase()) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: 0.95,\n                        matchMethod: 'name_set',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n                // Collector number match within same set\n                if (card.setCode.toLowerCase() === scryfallCard.setCode.toLowerCase() && card.number.toLowerCase() === (scryfallCard.number || '').toLowerCase()) {\n                    const nameSimilarity = this.calculateNameSimilarity(scryfallCard.name, card.name);\n                    if (nameSimilarity > 0.8) {\n                        return {\n                            scryfallId: scryfallCard.id,\n                            mtgjsonUuid: card.uuid,\n                            confidence: 0.9,\n                            matchMethod: 'collector_number',\n                            lastUpdated: new Date().toISOString()\n                        };\n                    }\n                }\n                // Fuzzy name match\n                const similarity = this.calculateNameSimilarity(scryfallCard.name, card.name);\n                if (similarity > 0.9) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: similarity * 0.8,\n                        matchMethod: 'name_fuzzy',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n            }\n        } catch (error) {\n            console.error('Error searching optimized storage:', error);\n        }\n        console.warn(\"No mapping found for card: \".concat(scryfallCard.name, \" (\").concat(scryfallCard.setCode, \")\"));\n        return null;\n    }\n    /**\r\n   * Strategy 1: Direct Scryfall ID match (most reliable)\r\n   */ findByDirectScryfallId(scryfallCard) {\n        if (!scryfallCard.scryfallId) return null;\n        for (const set of Object.values(this.allPrintingsData.data)){\n            for (const card of set.cards){\n                var _card_identifiers;\n                if (((_card_identifiers = card.identifiers) === null || _card_identifiers === void 0 ? void 0 : _card_identifiers.scryfallId) === scryfallCard.scryfallId) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: 1.0,\n                        matchMethod: 'direct',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    /**\r\n   * Strategy 2: Match by exact name and set code\r\n   */ findByNameAndSet(scryfallCard) {\n        const normalizedName = this.normalizeCardName(scryfallCard.name);\n        const setCode = scryfallCard.setCode.toLowerCase();\n        for (const set of Object.values(this.allPrintingsData.data)){\n            if (set.code.toLowerCase() !== setCode) continue;\n            for (const card of set.cards){\n                const cardNormalizedName = this.normalizeCardName(card.name);\n                if (cardNormalizedName === normalizedName) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: 0.95,\n                        matchMethod: 'name_set',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    /**\r\n   * Strategy 3: Match by collector number and set\r\n   */ findByCollectorNumber(scryfallCard) {\n        if (!scryfallCard.number) return null;\n        const setCode = scryfallCard.setCode.toLowerCase();\n        const collectorNumber = scryfallCard.number.toLowerCase();\n        for (const set of Object.values(this.allPrintingsData.data)){\n            if (set.code.toLowerCase() !== setCode) continue;\n            for (const card of set.cards){\n                if (card.number.toLowerCase() === collectorNumber) {\n                    // Also check if names are similar to avoid false positives\n                    const nameSimilarity = this.calculateNameSimilarity(scryfallCard.name, card.name);\n                    if (nameSimilarity > 0.8) {\n                        return {\n                            scryfallId: scryfallCard.id,\n                            mtgjsonUuid: card.uuid,\n                            confidence: 0.9,\n                            matchMethod: 'collector_number',\n                            lastUpdated: new Date().toISOString()\n                        };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    /**\r\n   * Strategy 4: Fuzzy name matching (least reliable)\r\n   */ findByFuzzyName(scryfallCard) {\n        const normalizedName = this.normalizeCardName(scryfallCard.name);\n        let bestMatch = null;\n        for (const set of Object.values(this.allPrintingsData.data)){\n            for (const card of set.cards){\n                const cardNormalizedName = this.normalizeCardName(card.name);\n                const similarity = this.calculateNameSimilarity(normalizedName, cardNormalizedName);\n                if (similarity > 0.9 && (!bestMatch || similarity > bestMatch.similarity)) {\n                    bestMatch = {\n                        card,\n                        similarity\n                    };\n                }\n            }\n        }\n        if (bestMatch && bestMatch.similarity > 0.9) {\n            return {\n                scryfallId: scryfallCard.id,\n                mtgjsonUuid: bestMatch.card.uuid,\n                confidence: bestMatch.similarity * 0.8,\n                matchMethod: 'name_fuzzy',\n                lastUpdated: new Date().toISOString()\n            };\n        }\n        return null;\n    }\n    /**\r\n   * Normalize card names for comparison\r\n   */ normalizeCardName(name) {\n        return name.toLowerCase().replace(/[^\\w\\s]/g, '') // Remove special characters\n        .replace(/\\s+/g, ' ') // Normalize whitespace\n        .trim();\n    }\n    /**\r\n   * Calculate similarity between two strings using Levenshtein distance\r\n   */ calculateNameSimilarity(str1, str2) {\n        const len1 = str1.length;\n        const len2 = str2.length;\n        if (len1 === 0) return len2 === 0 ? 1 : 0;\n        if (len2 === 0) return 0;\n        const matrix = [];\n        // Initialize matrix\n        for(let i = 0; i <= len1; i++){\n            matrix[i] = [\n                i\n            ];\n        }\n        for(let j = 0; j <= len2; j++){\n            matrix[0][j] = j;\n        }\n        // Fill matrix\n        for(let i = 1; i <= len1; i++){\n            for(let j = 1; j <= len2; j++){\n                const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + cost // substitution\n                );\n            }\n        }\n        const distance = matrix[len1][len2];\n        const maxLength = Math.max(len1, len2);\n        return 1 - distance / maxLength;\n    }\n    /**\r\n   * Cache AllPrintings data\r\n   */ async cacheAllPrintings(data) {\n        try {\n            // Store in IndexedDB via mtgjsonCache\n            await _lib_utils_mtgjsonCache__WEBPACK_IMPORTED_MODULE_0__.mtgjsonCache.setMetadata({\n                lastPriceUpdate: data.meta.date,\n                totalCards: this.countTotalCards(data),\n                cacheVersion: data.meta.version\n            });\n            // For now, we'll store a subset of the data to avoid storage issues\n            // In production, you might want to use a more sophisticated storage strategy\n            console.log('AllPrintings data cached successfully');\n        } catch (error) {\n            console.error('Failed to cache AllPrintings data:', error);\n        }\n    }\n    /**\r\n   * Get cached AllPrintings data\r\n   */ async getCachedAllPrintings() {\n        try {\n            // This is a placeholder - in reality, you'd need to implement\n            // efficient storage and retrieval of the large AllPrintings dataset\n            return null;\n        } catch (error) {\n            console.error('Failed to get cached AllPrintings:', error);\n            return null;\n        }\n    }\n    /**\r\n   * Load mapping cache from storage\r\n   */ async loadMappingCache() {\n        try {\n            // Load existing mappings from localStorage or IndexedDB\n            const cached = localStorage.getItem(this.MAPPING_CACHE_KEY);\n            if (cached) {\n                const mappings = JSON.parse(cached);\n                for (const mapping of mappings){\n                    this.mappingCache.set(mapping.scryfallId, mapping);\n                }\n                console.log(\"Loaded \".concat(mappings.length, \" cached mappings\"));\n            }\n        } catch (error) {\n            console.error('Failed to load mapping cache:', error);\n        }\n    }\n    /**\r\n   * Save a single mapping to cache\r\n   */ async saveMappingToCache(mapping) {\n        try {\n            // Save to localStorage (for now)\n            const existingMappings = this.getAllCachedMappings();\n            const updatedMappings = existingMappings.filter((m)=>m.scryfallId !== mapping.scryfallId);\n            updatedMappings.push(mapping);\n            localStorage.setItem(this.MAPPING_CACHE_KEY, JSON.stringify(updatedMappings));\n        } catch (error) {\n            console.error('Failed to save mapping to cache:', error);\n        }\n    }\n    /**\r\n   * Get all cached mappings\r\n   */ getAllCachedMappings() {\n        try {\n            const cached = localStorage.getItem(this.MAPPING_CACHE_KEY);\n            return cached ? JSON.parse(cached) : [];\n        } catch (error) {\n            console.error('Failed to get cached mappings:', error);\n            return [];\n        }\n    }\n    /**\r\n   * Check if data is fresh (within 7 days)\r\n   */ isDataFresh(dateString) {\n        const dataDate = new Date(dateString);\n        const now = new Date();\n        const daysDiff = (now.getTime() - dataDate.getTime()) / (1000 * 60 * 60 * 24);\n        return daysDiff < 7;\n    }\n    /**\r\n   * Count total cards in AllPrintings data\r\n   */ countTotalCards(data) {\n        return Object.values(data.data).reduce((total, set)=>total + set.cards.length, 0);\n    }\n    /**\r\n   * Get mapping statistics\r\n   */ async getMappingStats() {\n        const cachedMappings = this.getAllCachedMappings();\n        return {\n            totalMappings: cachedMappings.length,\n            directMatches: cachedMappings.filter((m)=>m.matchMethod === 'direct').length,\n            fuzzyMatches: cachedMappings.filter((m)=>m.matchMethod === 'name_fuzzy').length,\n            unmappedCards: 0,\n            lastUpdate: cachedMappings.length > 0 ? Math.max(...cachedMappings.map((m)=>new Date(m.lastUpdated).getTime())).toString() : new Date().toISOString()\n        };\n    }\n    /**\r\n   * Clear all cached mappings\r\n   */ async clearMappingCache() {\n        this.mappingCache.clear();\n        localStorage.removeItem(this.MAPPING_CACHE_KEY);\n        console.log('Mapping cache cleared');\n    }\n    /**\r\n   * Batch process multiple cards for mapping\r\n   */ async batchGetMappings(scryfallCards) {\n        await this.initialize();\n        const results = new Map();\n        for (const card of scryfallCards){\n            try {\n                const uuid = await this.getMapping(card);\n                if (uuid) {\n                    results.set(card.id, uuid);\n                }\n            } catch (error) {\n                console.error(\"Failed to map card \".concat(card.name, \":\"), error);\n            }\n        }\n        return results;\n    }\n    constructor(){\n        this.allPrintingsData = null;\n        this.mappingCache = new Map();\n        this.loadingPromise = null;\n        // MTGJSON AllPrintings.json URL\n        this.MTGJSON_ALL_PRINTINGS_URL = 'https://mtgjson.com/api/v5/AllPrintings.json';\n        this.CACHE_KEY = 'mtgjson-all-printings';\n        this.MAPPING_CACHE_KEY = 'card-mappings';\n    }\n}\n// Export singleton instance\nconst cardMappingService = new CardMappingService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvY2FyZE1hcHBpbmdTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQ3dEO0FBc0R4RCxNQUFNQztJQVVKOztHQUVDLEdBQ0QsTUFBTUMsYUFBNEI7UUFDaEMsSUFBSSxJQUFJLENBQUNDLGNBQWMsRUFBRTtZQUN2QixPQUFPLElBQUksQ0FBQ0EsY0FBYztRQUM1QjtRQUVBLElBQUksQ0FBQ0EsY0FBYyxHQUFHLElBQUksQ0FBQ0Msb0JBQW9CO1FBQy9DLE9BQU8sSUFBSSxDQUFDRCxjQUFjO0lBQzVCO0lBRUE7O0dBRUMsR0FDRCxNQUFjQyx1QkFBc0M7UUFDbEQsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFFWiwrQkFBK0I7WUFDL0IsTUFBTUMsU0FBUyxNQUFNLElBQUksQ0FBQ0MscUJBQXFCO1lBQy9DLElBQUlELFVBQVUsSUFBSSxDQUFDRSxXQUFXLENBQUNGLE9BQU9HLElBQUksQ0FBQ0MsSUFBSSxHQUFHO2dCQUNoRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHTDtnQkFDeEJGLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixNQUFNLElBQUksQ0FBQ08sZ0JBQWdCO2dCQUMzQjtZQUNGO1lBRUEsZ0NBQWdDO1lBQ2hDUixRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNUSxXQUFXLE1BQU1DLE1BQU0sSUFBSSxDQUFDQyx5QkFBeUI7WUFFM0QsSUFBSSxDQUFDRixTQUFTRyxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSUMsTUFBTSxpQ0FBb0RKLE9BQW5CQSxTQUFTSyxNQUFNLEVBQUMsS0FBdUIsT0FBcEJMLFNBQVNNLFVBQVU7WUFDekY7WUFFQSxxQkFBcUI7WUFDckIsTUFBTUMsT0FBNEIsTUFBTVAsU0FBU1EsSUFBSTtZQUVyRCxJQUFJLENBQUNELEtBQUtBLElBQUksSUFBSSxDQUFDQSxLQUFLWCxJQUFJLEVBQUU7Z0JBQzVCLE1BQU0sSUFBSVEsTUFBTTtZQUNsQjtZQUVBLElB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QUFvZnZDO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1vQyxxQkFBcUIsSUFBSXhJLHFCQUFxQiIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFxtdGctaW5kZXhcXHNyY1xcbGliXFxzZXJ2aWNlc1xcY2FyZE1hcHBpbmdTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1UR0NhcmQsIE1UR0pTT05DYXJkIH0gZnJvbSAnQC9saWIvdHlwZXMnO1xyXG5pbXBvcnQgeyBtdGdqc29uQ2FjaGUgfSBmcm9tICdAL2xpYi91dGlscy9tdGdqc29uQ2FjaGUnO1xyXG5cclxuLy8gTVRHSlNPTiBBbGxQcmludGluZ3MgZGF0YSBzdHJ1Y3R1cmVcclxuaW50ZXJmYWNlIE1UR0pTT05TZXQge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBjb2RlOiBzdHJpbmc7XHJcbiAgY2FyZHM6IE1UR0pTT05DYXJkRGF0YVtdO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgTVRHSlNPTkNhcmREYXRhIHtcclxuICB1dWlkOiBzdHJpbmc7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIHNldENvZGU6IHN0cmluZztcclxuICBudW1iZXI6IHN0cmluZztcclxuICByYXJpdHk6IHN0cmluZztcclxuICBjb2xvcnM/OiBzdHJpbmdbXTtcclxuICBjb2xvcklkZW50aXR5Pzogc3RyaW5nW107XHJcbiAgbWFuYUNvc3Q/OiBzdHJpbmc7XHJcbiAgY29udmVydGVkTWFuYUNvc3Q/OiBudW1iZXI7XHJcbiAgdHlwZT86IHN0cmluZztcclxuICBzdWJ0eXBlcz86IHN0cmluZ1tdO1xyXG4gIHN1cGVydHlwZXM/OiBzdHJpbmdbXTtcclxuICBhcnRpc3Q/OiBzdHJpbmc7XHJcbiAgaWRlbnRpZmllcnM/OiB7XHJcbiAgICBzY3J5ZmFsbElkPzogc3RyaW5nO1xyXG4gICAgbXVsdGl2ZXJzZUlkPzogbnVtYmVyO1xyXG4gICAgbXRnanNvblY0SWQ/OiBzdHJpbmc7XHJcbiAgfTtcclxufVxyXG5cclxuaW50ZXJmYWNlIE1UR0pTT05BbGxQcmludGluZ3Mge1xyXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIE1UR0pTT05TZXQ+O1xyXG4gIG1ldGE6IHtcclxuICAgIGRhdGU6IHN0cmluZztcclxuICAgIHZlcnNpb246IHN0cmluZztcclxuICB9O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQ2FyZE1hcHBpbmcge1xyXG4gIHNjcnlmYWxsSWQ6IHN0cmluZztcclxuICBtdGdqc29uVXVpZDogc3RyaW5nO1xyXG4gIGNvbmZpZGVuY2U6IG51bWJlcjsgLy8gMC0xIHNjb3JlIG9mIG1hcHBpbmcgY29uZmlkZW5jZVxyXG4gIG1hdGNoTWV0aG9kOiAnZGlyZWN0JyB8ICduYW1lX3NldCcgfCAnbmFtZV9mdXp6eScgfCAnY29sbGVjdG9yX251bWJlcicgfCAnbWFudWFsJztcclxuICBsYXN0VXBkYXRlZDogc3RyaW5nO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgTWFwcGluZ1N0YXRzIHtcclxuICB0b3RhbE1hcHBpbmdzOiBudW1iZXI7XHJcbiAgZGlyZWN0TWF0Y2hlczogbnVtYmVyO1xyXG4gIGZ1enp5TWF0Y2hlczogbnVtYmVyO1xyXG4gIHVubWFwcGVkQ2FyZHM6IG51bWJlcjtcclxuICBsYXN0VXBkYXRlOiBzdHJpbmc7XHJcbn1cclxuXHJcbmNsYXNzIENhcmRNYXBwaW5nU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBhbGxQcmludGluZ3NEYXRhOiBNVEdKU09OQWxsUHJpbnRpbmdzIHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBtYXBwaW5nQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgQ2FyZE1hcHBpbmc+KCk7XHJcbiAgcHJpdmF0ZSBsb2FkaW5nUHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsO1xyXG5cclxuICAvLyBNVEdKU09OIEFsbFByaW50aW5ncy5qc29uIFVSTFxyXG4gIHByaXZhdGUgcmVhZG9ubHkgTVRHSlNPTl9BTExfUFJJTlRJTkdTX1VSTCA9ICdodHRwczovL210Z2pzb24uY29tL2FwaS92NS9BbGxQcmludGluZ3MuanNvbic7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBDQUNIRV9LRVkgPSAnbXRnanNvbi1hbGwtcHJpbnRpbmdzJztcclxuICBwcml2YXRlIHJlYWRvbmx5IE1BUFBJTkdfQ0FDSEVfS0VZID0gJ2NhcmQtbWFwcGluZ3MnO1xyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIHNlcnZpY2UgYnkgbG9hZGluZyBBbGxQcmludGluZ3MgZGF0YVxyXG4gICAqL1xyXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAodGhpcy5sb2FkaW5nUHJvbWlzZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5sb2FkaW5nUHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxvYWRpbmdQcm9taXNlID0gdGhpcy5sb2FkQWxsUHJpbnRpbmdzRGF0YSgpO1xyXG4gICAgcmV0dXJuIHRoaXMubG9hZGluZ1Byb21pc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIGFuZCBjYWNoZSBBbGxQcmludGluZ3MuanNvbiBkYXRhXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBsb2FkQWxsUHJpbnRpbmdzRGF0YSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIE1UR0pTT04gQWxsUHJpbnRpbmdzIGRhdGEuLi4nKTtcclxuXHJcbiAgICAgIC8vIFRyeSB0byBsb2FkIGZyb20gY2FjaGUgZmlyc3RcclxuICAgICAgY29uc3QgY2FjaGVkID0gYXdhaXQgdGhpcy5nZXRDYWNoZWRBbGxQcmludGluZ3MoKTtcclxuICAgICAgaWYgKGNhY2hlZCAmJiB0aGlzLmlzRGF0YUZyZXNoKGNhY2hlZC5tZXRhLmRhdGUpKSB7XHJcbiAgICAgICAgdGhpcy5hbGxQcmludGluZ3NEYXRhID0gY2FjaGVkO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2FkZWQgQWxsUHJpbnRpbmdzIGZyb20gY2FjaGUnKTtcclxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXBwaW5nQ2FjaGUoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZldGNoIGZyZXNoIGRhdGEgZnJvbSBNVEdKU09OXHJcbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBmcmVzaCBBbGxQcmludGluZ3MgZGF0YSBmcm9tIE1UR0pTT04uLi4nKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLk1UR0pTT05fQUxMX1BSSU5USU5HU19VUkwpO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIEFsbFByaW50aW5nczogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUGFyc2UgdGhlIHJlc3BvbnNlXHJcbiAgICAgIGNvbnN0IGRhdGE6IE1UR0pTT05BbGxQcmludGluZ3MgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIWRhdGEuZGF0YSB8fCAhZGF0YS5tZXRhKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEFsbFByaW50aW5ncyByZXNwb25zZSBmb3JtYXQnKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgdGhpcy5hbGxQcmludGluZ3NEYXRhID0gZGF0YTtcclxuICAgICAgXHJcbiAgICAgIC8vIFN0b3JlIHVzaW5nIHRoZSBvcHRpbWl6ZWQgc3RvcmFnZSBzeXN0ZW1cclxuICAgICAgY29uc3QgeyBhbGxQcmludGluZ3NTdG9yYWdlIH0gPSBhd2FpdCBpbXBvcnQoJ0AvbGliL3V0aWxzL2FsbFByaW50aW5nc1N0b3JhZ2UnKTtcclxuICAgICAgYXdhaXQgYWxsUHJpbnRpbmdzU3RvcmFnZS5zdG9yZUFsbFByaW50aW5ncyhkYXRhKTtcclxuICAgICAgXHJcbiAgICAgIGF3YWl0IHRoaXMubG9hZE1hcHBpbmdDYWNoZSgpO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYExvYWRlZCAke09iamVjdC5rZXlzKGRhdGEuZGF0YSkubGVuZ3RofSBzZXRzIGZyb20gTVRHSlNPTmApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgQWxsUHJpbnRpbmdzIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICBcclxuICAgICAgLy8gVHJ5IHRvIHVzZSBvcHRpbWl6ZWQgc3RvcmFnZSBhcyBmYWxsYmFja1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHsgYWxsUHJpbnRpbmdzU3RvcmFnZSB9ID0gYXdhaXQgaW1wb3J0KCdAL2xpYi91dGlscy9hbGxQcmludGluZ3NTdG9yYWdlJyk7XHJcbiAgICAgICAgY29uc3QgaXNBdmFpbGFibGUgPSBhd2FpdCBhbGxQcmludGluZ3NTdG9yYWdlLmlzRGF0YUF2YWlsYWJsZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChpc0F2YWlsYWJsZSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIHN0b3JlZCBBbGxQcmludGluZ3MgZGF0YSBhcyBmYWxsYmFjaycpO1xyXG4gICAgICAgICAgLy8gV2UnbGwgd29yayB3aXRoIHRoZSBzdG9yZWQgZGF0YSB3aXRob3V0IGxvYWRpbmcgZXZlcnl0aGluZyBpbnRvIG1lbW9yeVxyXG4gICAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFwcGluZ0NhY2hlKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChzdG9yYWdlRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYWNjZXNzIHN0b3JlZCBBbGxQcmludGluZ3MgZGF0YTonLCBzdG9yYWdlRXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIEFsbFByaW50aW5ncyBkYXRhIGFuZCBubyBjYWNoZSBhdmFpbGFibGUnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgTVRHSlNPTiBVVUlEIGZvciBhIFNjcnlmYWxsIGNhcmRcclxuICAgKi9cclxuICBhc3luYyBnZXRNYXBwaW5nKHNjcnlmYWxsQ2FyZDogTVRHQ2FyZCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XHJcblxyXG4gICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcclxuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMubWFwcGluZ0NhY2hlLmdldChzY3J5ZmFsbENhcmQuaWQpO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICByZXR1cm4gY2FjaGVkLm10Z2pzb25VdWlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyeSB0byBmaW5kIG1hcHBpbmdcclxuICAgIGNvbnN0IG1hcHBpbmcgPSBhd2FpdCB0aGlzLmZpbmRDYXJkTWFwcGluZyhzY3J5ZmFsbENhcmQpO1xyXG4gICAgaWYgKG1hcHBpbmcpIHtcclxuICAgICAgLy8gQ2FjaGUgdGhlIG1hcHBpbmdcclxuICAgICAgdGhpcy5tYXBwaW5nQ2FjaGUuc2V0KHNjcnlmYWxsQ2FyZC5pZCwgbWFwcGluZyk7XHJcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZU1hcHBpbmdUb0NhY2hlKG1hcHBpbmcpO1xyXG4gICAgICByZXR1cm4gbWFwcGluZy5tdGdqc29uVXVpZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmQgbWFwcGluZyBmb3IgYSBTY3J5ZmFsbCBjYXJkIHVzaW5nIG11bHRpcGxlIHN0cmF0ZWdpZXNcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGZpbmRDYXJkTWFwcGluZyhzY3J5ZmFsbENhcmQ6IE1UR0NhcmQpOiBQcm9taXNlPENhcmRNYXBwaW5nIHwgbnVsbD4ge1xyXG4gICAgLy8gRmlyc3QgdHJ5IHdpdGggaW4tbWVtb3J5IEFsbFByaW50aW5ncyBkYXRhIGlmIGF2YWlsYWJsZVxyXG4gICAgaWYgKHRoaXMuYWxsUHJpbnRpbmdzRGF0YSkge1xyXG4gICAgICBjb25zdCBzdHJhdGVnaWVzID0gW1xyXG4gICAgICAgICgpID0+IHRoaXMuZmluZEJ5RGlyZWN0U2NyeWZhbGxJZChzY3J5ZmFsbENhcmQpLFxyXG4gICAgICAgICgpID0+IHRoaXMuZmluZEJ5TmFtZUFuZFNldChzY3J5ZmFsbENhcmQpLFxyXG4gICAgICAgICgpID0+IHRoaXMuZmluZEJ5Q29sbGVjdG9yTnVtYmVyKHNjcnlmYWxsQ2FyZCksXHJcbiAgICAgICAgKCkgPT4gdGhpcy5maW5kQnlGdXp6eU5hbWUoc2NyeWZhbGxDYXJkKSxcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgc3RyYXRlZ3kgb2Ygc3RyYXRlZ2llcykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN0cmF0ZWd5KCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGYWxsYmFjayB0byBvcHRpbWl6ZWQgc3RvcmFnZSBzZWFyY2hcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgYWxsUHJpbnRpbmdzU3RvcmFnZSB9ID0gYXdhaXQgaW1wb3J0KCdAL2xpYi91dGlscy9hbGxQcmludGluZ3NTdG9yYWdlJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdHJhdGVneSAxOiBEaXJlY3QgU2NyeWZhbGwgSUQgc2VhcmNoXHJcbiAgICAgIGlmIChzY3J5ZmFsbENhcmQuc2NyeWZhbGxJZCkge1xyXG4gICAgICAgIGNvbnN0IGNhcmQgPSBhd2FpdCBhbGxQcmludGluZ3NTdG9yYWdlLmZpbmRDYXJkQnlTY3J5ZmFsbElkKHNjcnlmYWxsQ2FyZC5zY3J5ZmFsbElkKTtcclxuICAgICAgICBpZiAoY2FyZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2NyeWZhbGxJZDogc2NyeWZhbGxDYXJkLmlkLFxyXG4gICAgICAgICAgICBtdGdqc29uVXVpZDogY2FyZC51dWlkLFxyXG4gICAgICAgICAgICBjb25maWRlbmNlOiAxLjAsXHJcbiAgICAgICAgICAgIG1hdGNoTWV0aG9kOiAnZGlyZWN0JyxcclxuICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTdHJhdGVneSAyOiBTZWFyY2ggYnkgbmFtZSBhbmQgdHJ5IHRvIG1hdGNoIHdpdGggc2V0XHJcbiAgICAgIGNvbnN0IHNlYXJjaFJlc3VsdHMgPSBhd2FpdCBhbGxQcmludGluZ3NTdG9yYWdlLnNlYXJjaENhcmRzKHNjcnlmYWxsQ2FyZC5uYW1lLCAyMCk7XHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGNvbnN0IGNhcmQgb2Ygc2VhcmNoUmVzdWx0cykge1xyXG4gICAgICAgIC8vIEV4YWN0IG5hbWUgYW5kIHNldCBtYXRjaFxyXG4gICAgICAgIGlmICh0aGlzLm5vcm1hbGl6ZUNhcmROYW1lKGNhcmQubmFtZSkgPT09IHRoaXMubm9ybWFsaXplQ2FyZE5hbWUoc2NyeWZhbGxDYXJkLm5hbWUpICYmXHJcbiAgICAgICAgICAgIGNhcmQuc2V0Q29kZS50b0xvd2VyQ2FzZSgpID09PSBzY3J5ZmFsbENhcmQuc2V0Q29kZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzY3J5ZmFsbElkOiBzY3J5ZmFsbENhcmQuaWQsXHJcbiAgICAgICAgICAgIG10Z2pzb25VdWlkOiBjYXJkLnV1aWQsXHJcbiAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOTUsXHJcbiAgICAgICAgICAgIG1hdGNoTWV0aG9kOiAnbmFtZV9zZXQnLFxyXG4gICAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbGxlY3RvciBudW1iZXIgbWF0Y2ggd2l0aGluIHNhbWUgc2V0XHJcbiAgICAgICAgaWYgKGNhcmQuc2V0Q29kZS50b0xvd2VyQ2FzZSgpID09PSBzY3J5ZmFsbENhcmQuc2V0Q29kZS50b0xvd2VyQ2FzZSgpICYmXHJcbiAgICAgICAgICAgIGNhcmQubnVtYmVyLnRvTG93ZXJDYXNlKCkgPT09IChzY3J5ZmFsbENhcmQubnVtYmVyIHx8ICcnKS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICBjb25zdCBuYW1lU2ltaWxhcml0eSA9IHRoaXMuY2FsY3VsYXRlTmFtZVNpbWlsYXJpdHkoc2NyeWZhbGxDYXJkLm5hbWUsIGNhcmQubmFtZSk7XHJcbiAgICAgICAgICBpZiAobmFtZVNpbWlsYXJpdHkgPiAwLjgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICBzY3J5ZmFsbElkOiBzY3J5ZmFsbENhcmQuaWQsXHJcbiAgICAgICAgICAgICAgbXRnanNvblV1aWQ6IGNhcmQudXVpZCxcclxuICAgICAgICAgICAgICBjb25maWRlbmNlOiAwLjksXHJcbiAgICAgICAgICAgICAgbWF0Y2hNZXRob2Q6ICdjb2xsZWN0b3JfbnVtYmVyJyxcclxuICAgICAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRnV6enkgbmFtZSBtYXRjaFxyXG4gICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSB0aGlzLmNhbGN1bGF0ZU5hbWVTaW1pbGFyaXR5KHNjcnlmYWxsQ2FyZC5uYW1lLCBjYXJkLm5hbWUpO1xyXG4gICAgICAgIGlmIChzaW1pbGFyaXR5ID4gMC45KSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzY3J5ZmFsbElkOiBzY3J5ZmFsbENhcmQuaWQsXHJcbiAgICAgICAgICAgIG10Z2pzb25VdWlkOiBjYXJkLnV1aWQsXHJcbiAgICAgICAgICAgIGNvbmZpZGVuY2U6IHNpbWlsYXJpdHkgKiAwLjgsXHJcbiAgICAgICAgICAgIG1hdGNoTWV0aG9kOiAnbmFtZV9mdXp6eScsXHJcbiAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VhcmNoaW5nIG9wdGltaXplZCBzdG9yYWdlOicsIGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLndhcm4oYE5vIG1hcHBpbmcgZm91bmQgZm9yIGNhcmQ6ICR7c2NyeWZhbGxDYXJkLm5hbWV9ICgke3NjcnlmYWxsQ2FyZC5zZXRDb2RlfSlgKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RyYXRlZ3kgMTogRGlyZWN0IFNjcnlmYWxsIElEIG1hdGNoIChtb3N0IHJlbGlhYmxlKVxyXG4gICAqL1xyXG4gIHByaXZhdGUgZmluZEJ5RGlyZWN0U2NyeWZhbGxJZChzY3J5ZmFsbENhcmQ6IE1UR0NhcmQpOiBDYXJkTWFwcGluZyB8IG51bGwge1xyXG4gICAgaWYgKCFzY3J5ZmFsbENhcmQuc2NyeWZhbGxJZCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgZm9yIChjb25zdCBzZXQgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmFsbFByaW50aW5nc0RhdGEhLmRhdGEpKSB7XHJcbiAgICAgIGZvciAoY29uc3QgY2FyZCBvZiBzZXQuY2FyZHMpIHtcclxuICAgICAgICBpZiAoY2FyZC5pZGVudGlmaWVycz8uc2NyeWZhbGxJZCA9PT0gc2NyeWZhbGxDYXJkLnNjcnlmYWxsSWQpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNjcnlmYWxsSWQ6IHNjcnlmYWxsQ2FyZC5pZCxcclxuICAgICAgICAgICAgbXRnanNvblV1aWQ6IGNhcmQudXVpZCxcclxuICAgICAgICAgICAgY29uZmlkZW5jZTogMS4wLFxyXG4gICAgICAgICAgICBtYXRjaE1ldGhvZDogJ2RpcmVjdCcsXHJcbiAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RyYXRlZ3kgMjogTWF0Y2ggYnkgZXhhY3QgbmFtZSBhbmQgc2V0IGNvZGVcclxuICAgKi9cclxuICBwcml2YXRlIGZpbmRCeU5hbWVBbmRTZXQoc2NyeWZhbGxDYXJkOiBNVEdDYXJkKTogQ2FyZE1hcHBpbmcgfCBudWxsIHtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gdGhpcy5ub3JtYWxpemVDYXJkTmFtZShzY3J5ZmFsbENhcmQubmFtZSk7XHJcbiAgICBjb25zdCBzZXRDb2RlID0gc2NyeWZhbGxDYXJkLnNldENvZGUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHNldCBvZiBPYmplY3QudmFsdWVzKHRoaXMuYWxsUHJpbnRpbmdzRGF0YSEuZGF0YSkpIHtcclxuICAgICAgaWYgKHNldC5jb2RlLnRvTG93ZXJDYXNlKCkgIT09IHNldENvZGUpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjYXJkIG9mIHNldC5jYXJkcykge1xyXG4gICAgICAgIGNvbnN0IGNhcmROb3JtYWxpemVkTmFtZSA9IHRoaXMubm9ybWFsaXplQ2FyZE5hbWUoY2FyZC5uYW1lKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY2FyZE5vcm1hbGl6ZWROYW1lID09PSBub3JtYWxpemVkTmFtZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2NyeWZhbGxJZDogc2NyeWZhbGxDYXJkLmlkLFxyXG4gICAgICAgICAgICBtdGdqc29uVXVpZDogY2FyZC51dWlkLFxyXG4gICAgICAgICAgICBjb25maWRlbmNlOiAwLjk1LFxyXG4gICAgICAgICAgICBtYXRjaE1ldGhvZDogJ25hbWVfc2V0JyxcclxuICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdHJhdGVneSAzOiBNYXRjaCBieSBjb2xsZWN0b3IgbnVtYmVyIGFuZCBzZXRcclxuICAgKi9cclxuICBwcml2YXRlIGZpbmRCeUNvbGxlY3Rvck51bWJlcihzY3J5ZmFsbENhcmQ6IE1UR0NhcmQpOiBDYXJkTWFwcGluZyB8IG51bGwge1xyXG4gICAgaWYgKCFzY3J5ZmFsbENhcmQubnVtYmVyKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBjb25zdCBzZXRDb2RlID0gc2NyeWZhbGxDYXJkLnNldENvZGUudG9Mb3dlckNhc2UoKTtcclxuICAgIGNvbnN0IGNvbGxlY3Rvck51bWJlciA9IHNjcnlmYWxsQ2FyZC5udW1iZXIudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHNldCBvZiBPYmplY3QudmFsdWVzKHRoaXMuYWxsUHJpbnRpbmdzRGF0YSEuZGF0YSkpIHtcclxuICAgICAgaWYgKHNldC5jb2RlLnRvTG93ZXJDYXNlKCkgIT09IHNldENvZGUpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjYXJkIG9mIHNldC5jYXJkcykge1xyXG4gICAgICAgIGlmIChjYXJkLm51bWJlci50b0xvd2VyQ2FzZSgpID09PSBjb2xsZWN0b3JOdW1iZXIpIHtcclxuICAgICAgICAgIC8vIEFsc28gY2hlY2sgaWYgbmFtZXMgYXJlIHNpbWlsYXIgdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzXHJcbiAgICAgICAgICBjb25zdCBuYW1lU2ltaWxhcml0eSA9IHRoaXMuY2FsY3VsYXRlTmFtZVNpbWlsYXJpdHkoc2NyeWZhbGxDYXJkLm5hbWUsIGNhcmQubmFtZSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChuYW1lU2ltaWxhcml0eSA+IDAuOCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIHNjcnlmYWxsSWQ6IHNjcnlmYWxsQ2FyZC5pZCxcclxuICAgICAgICAgICAgICBtdGdqc29uVXVpZDogY2FyZC51dWlkLFxyXG4gICAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcclxuICAgICAgICAgICAgICBtYXRjaE1ldGhvZDogJ2NvbGxlY3Rvcl9udW1iZXInLFxyXG4gICAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdHJhdGVneSA0OiBGdXp6eSBuYW1lIG1hdGNoaW5nIChsZWFzdCByZWxpYWJsZSlcclxuICAgKi9cclxuICBwcml2YXRlIGZpbmRCeUZ1enp5TmFtZShzY3J5ZmFsbENhcmQ6IE1UR0NhcmQpOiBDYXJkTWFwcGluZyB8IG51bGwge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSB0aGlzLm5vcm1hbGl6ZUNhcmROYW1lKHNjcnlmYWxsQ2FyZC5uYW1lKTtcclxuICAgIGxldCBiZXN0TWF0Y2g6IHsgY2FyZDogTVRHSlNPTkNhcmREYXRhOyBzaW1pbGFyaXR5OiBudW1iZXIgfSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIGZvciAoY29uc3Qgc2V0IG9mIE9iamVjdC52YWx1ZXModGhpcy5hbGxQcmludGluZ3NEYXRhIS5kYXRhKSkge1xyXG4gICAgICBmb3IgKGNvbnN0IGNhcmQgb2Ygc2V0LmNhcmRzKSB7XHJcbiAgICAgICAgY29uc3QgY2FyZE5vcm1hbGl6ZWROYW1lID0gdGhpcy5ub3JtYWxpemVDYXJkTmFtZShjYXJkLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSB0aGlzLmNhbGN1bGF0ZU5hbWVTaW1pbGFyaXR5KG5vcm1hbGl6ZWROYW1lLCBjYXJkTm9ybWFsaXplZE5hbWUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChzaW1pbGFyaXR5ID4gMC45ICYmICghYmVzdE1hdGNoIHx8IHNpbWlsYXJpdHkgPiBiZXN0TWF0Y2guc2ltaWxhcml0eSkpIHtcclxuICAgICAgICAgIGJlc3RNYXRjaCA9IHsgY2FyZCwgc2ltaWxhcml0eSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChiZXN0TWF0Y2ggJiYgYmVzdE1hdGNoLnNpbWlsYXJpdHkgPiAwLjkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzY3J5ZmFsbElkOiBzY3J5ZmFsbENhcmQuaWQsXHJcbiAgICAgICAgbXRnanNvblV1aWQ6IGJlc3RNYXRjaC5jYXJkLnV1aWQsXHJcbiAgICAgICAgY29uZmlkZW5jZTogYmVzdE1hdGNoLnNpbWlsYXJpdHkgKiAwLjgsIC8vIFJlZHVjZSBjb25maWRlbmNlIGZvciBmdXp6eSBtYXRjaGVzXHJcbiAgICAgICAgbWF0Y2hNZXRob2Q6ICduYW1lX2Z1enp5JyxcclxuICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplIGNhcmQgbmFtZXMgZm9yIGNvbXBhcmlzb25cclxuICAgKi9cclxuICBwcml2YXRlIG5vcm1hbGl6ZUNhcmROYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gbmFtZVxyXG4gICAgICAudG9Mb3dlckNhc2UoKVxyXG4gICAgICAucmVwbGFjZSgvW15cXHdcXHNdL2csICcnKSAvLyBSZW1vdmUgc3BlY2lhbCBjaGFyYWN0ZXJzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJykgLy8gTm9ybWFsaXplIHdoaXRlc3BhY2VcclxuICAgICAgLnRyaW0oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBzaW1pbGFyaXR5IGJldHdlZW4gdHdvIHN0cmluZ3MgdXNpbmcgTGV2ZW5zaHRlaW4gZGlzdGFuY2VcclxuICAgKi9cclxuICBwcml2YXRlIGNhbGN1bGF0ZU5hbWVTaW1pbGFyaXR5KHN0cjE6IHN0cmluZywgc3RyMjogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IGxlbjEgPSBzdHIxLmxlbmd0aDtcclxuICAgIGNvbnN0IGxlbjIgPSBzdHIyLmxlbmd0aDtcclxuICAgIFxyXG4gICAgaWYgKGxlbjEgPT09IDApIHJldHVybiBsZW4yID09PSAwID8gMSA6IDA7XHJcbiAgICBpZiAobGVuMiA9PT0gMCkgcmV0dXJuIDA7XHJcblxyXG4gICAgY29uc3QgbWF0cml4OiBudW1iZXJbXVtdID0gW107XHJcbiAgICBcclxuICAgIC8vIEluaXRpYWxpemUgbWF0cml4XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsZW4xOyBpKyspIHtcclxuICAgICAgbWF0cml4W2ldID0gW2ldO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPD0gbGVuMjsgaisrKSB7XHJcbiAgICAgIG1hdHJpeFswXVtqXSA9IGo7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmlsbCBtYXRyaXhcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGxlbjE7IGkrKykge1xyXG4gICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBsZW4yOyBqKyspIHtcclxuICAgICAgICBjb25zdCBjb3N0ID0gc3RyMVtpIC0gMV0gPT09IHN0cjJbaiAtIDFdID8gMCA6IDE7XHJcbiAgICAgICAgbWF0cml4W2ldW2pdID0gTWF0aC5taW4oXHJcbiAgICAgICAgICBtYXRyaXhbaSAtIDFdW2pdICsgMSwgICAgIC8vIGRlbGV0aW9uXHJcbiAgICAgICAgICBtYXRyaXhbaV1baiAtIDFdICsgMSwgICAgIC8vIGluc2VydGlvblxyXG4gICAgICAgICAgbWF0cml4W2kgLSAxXVtqIC0gMV0gKyBjb3N0IC8vIHN1YnN0aXR1dGlvblxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkaXN0YW5jZSA9IG1hdHJpeFtsZW4xXVtsZW4yXTtcclxuICAgIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWF4KGxlbjEsIGxlbjIpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gMSAtIChkaXN0YW5jZSAvIG1heExlbmd0aCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWNoZSBBbGxQcmludGluZ3MgZGF0YVxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgY2FjaGVBbGxQcmludGluZ3MoZGF0YTogTVRHSlNPTkFsbFByaW50aW5ncyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU3RvcmUgaW4gSW5kZXhlZERCIHZpYSBtdGdqc29uQ2FjaGVcclxuICAgICAgYXdhaXQgbXRnanNvbkNhY2hlLnNldE1ldGFkYXRhKHtcclxuICAgICAgICBsYXN0UHJpY2VVcGRhdGU6IGRhdGEubWV0YS5kYXRlLFxyXG4gICAgICAgIHRvdGFsQ2FyZHM6IHRoaXMuY291bnRUb3RhbENhcmRzKGRhdGEpLFxyXG4gICAgICAgIGNhY2hlVmVyc2lvbjogZGF0YS5tZXRhLnZlcnNpb24sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gRm9yIG5vdywgd2UnbGwgc3RvcmUgYSBzdWJzZXQgb2YgdGhlIGRhdGEgdG8gYXZvaWQgc3RvcmFnZSBpc3N1ZXNcclxuICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgeW91IG1pZ2h0IHdhbnQgdG8gdXNlIGEgbW9yZSBzb3BoaXN0aWNhdGVkIHN0b3JhZ2Ugc3RyYXRlZ3lcclxuICAgICAgY29uc29sZS5sb2coJ0FsbFByaW50aW5ncyBkYXRhIGNhY2hlZCBzdWNjZXNzZnVsbHknKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjYWNoZSBBbGxQcmludGluZ3MgZGF0YTonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY2FjaGVkIEFsbFByaW50aW5ncyBkYXRhXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRDYWNoZWRBbGxQcmludGluZ3MoKTogUHJvbWlzZTxNVEdKU09OQWxsUHJpbnRpbmdzIHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVGhpcyBpcyBhIHBsYWNlaG9sZGVyIC0gaW4gcmVhbGl0eSwgeW91J2QgbmVlZCB0byBpbXBsZW1lbnRcclxuICAgICAgLy8gZWZmaWNpZW50IHN0b3JhZ2UgYW5kIHJldHJpZXZhbCBvZiB0aGUgbGFyZ2UgQWxsUHJpbnRpbmdzIGRhdGFzZXRcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGNhY2hlZCBBbGxQcmludGluZ3M6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWQgbWFwcGluZyBjYWNoZSBmcm9tIHN0b3JhZ2VcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGxvYWRNYXBwaW5nQ2FjaGUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBMb2FkIGV4aXN0aW5nIG1hcHBpbmdzIGZyb20gbG9jYWxTdG9yYWdlIG9yIEluZGV4ZWREQlxyXG4gICAgICBjb25zdCBjYWNoZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLk1BUFBJTkdfQ0FDSEVfS0VZKTtcclxuICAgICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIGNvbnN0IG1hcHBpbmdzOiBDYXJkTWFwcGluZ1tdID0gSlNPTi5wYXJzZShjYWNoZWQpO1xyXG4gICAgICAgIGZvciAoY29uc3QgbWFwcGluZyBvZiBtYXBwaW5ncykge1xyXG4gICAgICAgICAgdGhpcy5tYXBwaW5nQ2FjaGUuc2V0KG1hcHBpbmcuc2NyeWZhbGxJZCwgbWFwcGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBMb2FkZWQgJHttYXBwaW5ncy5sZW5ndGh9IGNhY2hlZCBtYXBwaW5nc2ApO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBtYXBwaW5nIGNhY2hlOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNhdmUgYSBzaW5nbGUgbWFwcGluZyB0byBjYWNoZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgc2F2ZU1hcHBpbmdUb0NhY2hlKG1hcHBpbmc6IENhcmRNYXBwaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZSAoZm9yIG5vdylcclxuICAgICAgY29uc3QgZXhpc3RpbmdNYXBwaW5ncyA9IHRoaXMuZ2V0QWxsQ2FjaGVkTWFwcGluZ3MoKTtcclxuICAgICAgY29uc3QgdXBkYXRlZE1hcHBpbmdzID0gZXhpc3RpbmdNYXBwaW5ncy5maWx0ZXIobSA9PiBtLnNjcnlmYWxsSWQgIT09IG1hcHBpbmcuc2NyeWZhbGxJZCk7XHJcbiAgICAgIHVwZGF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xyXG4gICAgICBcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5NQVBQSU5HX0NBQ0hFX0tFWSwgSlNPTi5zdHJpbmdpZnkodXBkYXRlZE1hcHBpbmdzKSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBtYXBwaW5nIHRvIGNhY2hlOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbGwgY2FjaGVkIG1hcHBpbmdzXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRBbGxDYWNoZWRNYXBwaW5ncygpOiBDYXJkTWFwcGluZ1tdIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuTUFQUElOR19DQUNIRV9LRVkpO1xyXG4gICAgICByZXR1cm4gY2FjaGVkID8gSlNPTi5wYXJzZShjYWNoZWQpIDogW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGNhY2hlZCBtYXBwaW5nczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGRhdGEgaXMgZnJlc2ggKHdpdGhpbiA3IGRheXMpXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBpc0RhdGFGcmVzaChkYXRlU3RyaW5nOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGRhdGFEYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZyk7XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgY29uc3QgZGF5c0RpZmYgPSAobm93LmdldFRpbWUoKSAtIGRhdGFEYXRlLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCk7XHJcbiAgICByZXR1cm4gZGF5c0RpZmYgPCA3O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ291bnQgdG90YWwgY2FyZHMgaW4gQWxsUHJpbnRpbmdzIGRhdGFcclxuICAgKi9cclxuICBwcml2YXRlIGNvdW50VG90YWxDYXJkcyhkYXRhOiBNVEdKU09OQWxsUHJpbnRpbmdzKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGRhdGEuZGF0YSkucmVkdWNlKCh0b3RhbCwgc2V0KSA9PiB0b3RhbCArIHNldC5jYXJkcy5sZW5ndGgsIDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG1hcHBpbmcgc3RhdGlzdGljc1xyXG4gICAqL1xyXG4gIGFzeW5jIGdldE1hcHBpbmdTdGF0cygpOiBQcm9taXNlPE1hcHBpbmdTdGF0cz4ge1xyXG4gICAgY29uc3QgY2FjaGVkTWFwcGluZ3MgPSB0aGlzLmdldEFsbENhY2hlZE1hcHBpbmdzKCk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvdGFsTWFwcGluZ3M6IGNhY2hlZE1hcHBpbmdzLmxlbmd0aCxcclxuICAgICAgZGlyZWN0TWF0Y2hlczogY2FjaGVkTWFwcGluZ3MuZmlsdGVyKG0gPT4gbS5tYXRjaE1ldGhvZCA9PT0gJ2RpcmVjdCcpLmxlbmd0aCxcclxuICAgICAgZnV6enlNYXRjaGVzOiBjYWNoZWRNYXBwaW5ncy5maWx0ZXIobSA9PiBtLm1hdGNoTWV0aG9kID09PSAnbmFtZV9mdXp6eScpLmxlbmd0aCxcclxuICAgICAgdW5tYXBwZWRDYXJkczogMCwgLy8gV291bGQgbmVlZCB0byB0cmFjayB0aGlzIHNlcGFyYXRlbHlcclxuICAgICAgbGFzdFVwZGF0ZTogY2FjaGVkTWFwcGluZ3MubGVuZ3RoID4gMCBcclxuICAgICAgICA/IE1hdGgubWF4KC4uLmNhY2hlZE1hcHBpbmdzLm1hcChtID0+IG5ldyBEYXRlKG0ubGFzdFVwZGF0ZWQpLmdldFRpbWUoKSkpLnRvU3RyaW5nKClcclxuICAgICAgICA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhciBhbGwgY2FjaGVkIG1hcHBpbmdzXHJcbiAgICovXHJcbiAgYXN5bmMgY2xlYXJNYXBwaW5nQ2FjaGUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0aGlzLm1hcHBpbmdDYWNoZS5jbGVhcigpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5NQVBQSU5HX0NBQ0hFX0tFWSk7XHJcbiAgICBjb25zb2xlLmxvZygnTWFwcGluZyBjYWNoZSBjbGVhcmVkJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCYXRjaCBwcm9jZXNzIG11bHRpcGxlIGNhcmRzIGZvciBtYXBwaW5nXHJcbiAgICovXHJcbiAgYXN5bmMgYmF0Y2hHZXRNYXBwaW5ncyhzY3J5ZmFsbENhcmRzOiBNVEdDYXJkW10pOiBQcm9taXNlPE1hcDxzdHJpbmcsIHN0cmluZz4+IHtcclxuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgXHJcbiAgICBjb25zdCByZXN1bHRzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBjYXJkIG9mIHNjcnlmYWxsQ2FyZHMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB1dWlkID0gYXdhaXQgdGhpcy5nZXRNYXBwaW5nKGNhcmQpO1xyXG4gICAgICAgIGlmICh1dWlkKSB7XHJcbiAgICAgICAgICByZXN1bHRzLnNldChjYXJkLmlkLCB1dWlkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIG1hcCBjYXJkICR7Y2FyZC5uYW1lfTpgLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBjYXJkTWFwcGluZ1NlcnZpY2UgPSBuZXcgQ2FyZE1hcHBpbmdTZXJ2aWNlKCk7XHJcblxyXG4vLyBFeHBvcnQgdHlwZXMgZm9yIGV4dGVybmFsIHVzZVxyXG5leHBvcnQgdHlwZSB7IENhcmRNYXBwaW5nLCBNYXBwaW5nU3RhdHMgfTtcclxuIl0sIm5hbWVzIjpbIm10Z2pzb25DYWNoZSIsIkNhcmRNYXBwaW5nU2VydmljZSIsImluaXRpYWxpemUiLCJsb2FkaW5nUHJvbWlzZSIsImxvYWRBbGxQcmludGluZ3NEYXRhIiwiY29uc29sZSIsImxvZyIsImNhY2hlZCIsImdldENhY2hlZEFsbFByaW50aW5ncyIsImlzRGF0YUZyZXNoIiwibWV0YSIsImRhdGUiLCJhbGxQcmludGluZ3NEYXRhIiwibG9hZE1hcHBpbmdDYWNoZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJNVEdKU09OX0FMTF9QUklOVElOR1NfVVJMIiwib2siLCJFcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJkYXRhIiwianNvbiIsImFsbFByaW50aW5nc1N0b3JhZ2UiLCJzdG9yZUFsbFByaW50aW5ncyIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJlcnJvciIsImlzQXZhaWxhYmxlIiwiaXNEYXRhQXZhaWxhYmxlIiwic3RvcmFnZUVycm9yIiwiZ2V0TWFwcGluZyIsInNjcnlmYWxsQ2FyZCIsIm1hcHBpbmdDYWNoZSIsImdldCIsImlkIiwibXRnanNvblV1aWQiLCJtYXBwaW5nIiwiZmluZENhcmRNYXBwaW5nIiwic2V0Iiwic2F2ZU1hcHBpbmdUb0NhY2hlIiwic3RyYXRlZ2llcyIsImZpbmRCeURpcmVjdFNjcnlmYWxsSWQiLCJmaW5kQnlOYW1lQW5kU2V0IiwiZmluZEJ5Q29sbGVjdG9yTnVtYmVyIiwiZmluZEJ5RnV6enlOYW1lIiwic3RyYXRlZ3kiLCJyZXN1bHQiLCJzY3J5ZmFsbElkIiwiY2FyZCIsImZpbmRDYXJkQnlTY3J5ZmFsbElkIiwidXVpZCIsImNvbmZpZGVuY2UiLCJtYXRjaE1ldGhvZCIsImxhc3RVcGRhdGVkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic2VhcmNoUmVzdWx0cyIsInNlYXJjaENhcmRzIiwibmFtZSIsIm5vcm1hbGl6ZUNhcmROYW1lIiwic2V0Q29kZSIsInRvTG93ZXJDYXNlIiwibnVtYmVyIiwibmFtZVNpbWlsYXJpdHkiLCJjYWxjdWxhdGVOYW1lU2ltaWxhcml0eSIsInNpbWlsYXJpdHkiLCJ3YXJuIiwidmFsdWVzIiwiY2FyZHMiLCJpZGVudGlmaWVycyIsIm5vcm1hbGl6ZWROYW1lIiwiY29kZSIsImNhcmROb3JtYWxpemVkTmFtZSIsImNvbGxlY3Rvck51bWJlciIsImJlc3RNYXRjaCIsInJlcGxhY2UiLCJ0cmltIiwic3RyMSIsInN0cjIiLCJsZW4xIiwibGVuMiIsIm1hdHJpeCIsImkiLCJqIiwiY29zdCIsIk1hdGgiLCJtaW4iLCJkaXN0YW5jZSIsIm1heExlbmd0aCIsIm1heCIsImNhY2hlQWxsUHJpbnRpbmdzIiwic2V0TWV0YWRhdGEiLCJsYXN0UHJpY2VVcGRhdGUiLCJ0b3RhbENhcmRzIiwiY291bnRUb3RhbENhcmRzIiwiY2FjaGVWZXJzaW9uIiwidmVyc2lvbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJNQVBQSU5HX0NBQ0hFX0tFWSIsIm1hcHBpbmdzIiwiSlNPTiIsInBhcnNlIiwiZXhpc3RpbmdNYXBwaW5ncyIsImdldEFsbENhY2hlZE1hcHBpbmdzIiwidXBkYXRlZE1hcHBpbmdzIiwiZmlsdGVyIiwibSIsInB1c2giLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZGF0ZVN0cmluZyIsImRhdGFEYXRlIiwibm93IiwiZGF5c0RpZmYiLCJnZXRUaW1lIiwicmVkdWNlIiwidG90YWwiLCJnZXRNYXBwaW5nU3RhdHMiLCJjYWNoZWRNYXBwaW5ncyIsInRvdGFsTWFwcGluZ3MiLCJkaXJlY3RNYXRjaGVzIiwiZnV6enlNYXRjaGVzIiwidW5tYXBwZWRDYXJkcyIsImxhc3RVcGRhdGUiLCJtYXAiLCJ0b1N0cmluZyIsImNsZWFyTWFwcGluZ0NhY2hlIiwiY2xlYXIiLCJyZW1vdmVJdGVtIiwiYmF0Y2hHZXRNYXBwaW5ncyIsInNjcnlmYWxsQ2FyZHMiLCJyZXN1bHRzIiwiTWFwIiwiQ0FDSEVfS0VZIiwiY2FyZE1hcHBpbmdTZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/cardMappingService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/utils/mtgjsonCache.ts":
/*!***************************************!*\
  !*** ./src/lib/utils/mtgjsonCache.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   mtgjsonCache: () => (/* binding */ mtgjsonCache)\n/* harmony export */ });\n// IndexedDB configuration for MTGJSON data\nconst DB_NAME = 'MTGJSONCache';\nconst DB_VERSION = 1;\nconst STORES = {\n    PRICE_HISTORY: 'priceHistory',\n    CARD_MAPPINGS: 'cardMappings',\n    METADATA: 'metadata'\n};\n// Cache expiry times\nconst CACHE_EXPIRY = {\n    PRICE_HISTORY: 24 * 60 * 60 * 1000,\n    CARD_MAPPINGS: 7 * 24 * 60 * 60 * 1000,\n    METADATA: 60 * 60 * 1000\n};\nclass MTGJSONCache {\n    async init() {\n        if (this.db) return;\n        if (this.initPromise) return this.initPromise;\n        this.initPromise = new Promise((resolve, reject)=>{\n            if (false) {}\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n            request.onerror = ()=>{\n                reject(new Error('Failed to open IndexedDB'));\n            };\n            request.onsuccess = ()=>{\n                this.db = request.result;\n                resolve();\n            };\n            request.onupgradeneeded = (event)=>{\n                const db = event.target.result;\n                // Create price history store\n                if (!db.objectStoreNames.contains(STORES.PRICE_HISTORY)) {\n                    const priceStore = db.createObjectStore(STORES.PRICE_HISTORY, {\n                        keyPath: 'uuid'\n                    });\n                    priceStore.createIndex('cardId', 'cardId', {\n                        unique: false\n                    });\n                    priceStore.createIndex('lastUpdated', 'lastUpdated', {\n                        unique: false\n                    });\n                }\n                // Create card mappings store\n                if (!db.objectStoreNames.contains(STORES.CARD_MAPPINGS)) {\n                    const mappingStore = db.createObjectStore(STORES.CARD_MAPPINGS, {\n                        keyPath: 'scryfallId'\n                    });\n                    mappingStore.createIndex('uuid', 'uuid', {\n                        unique: false\n                    });\n                    mappingStore.createIndex('name', 'name', {\n                        unique: false\n                    });\n                }\n                // Create metadata store\n                if (!db.objectStoreNames.contains(STORES.METADATA)) {\n                    db.createObjectStore(STORES.METADATA, {\n                        keyPath: 'key'\n                    });\n                }\n            };\n        });\n        return this.initPromise;\n    }\n    async getStore(storeName) {\n        let mode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'readonly';\n        await this.init();\n        if (!this.db) throw new Error('Database not initialized');\n        const transaction = this.db.transaction([\n            storeName\n        ], mode);\n        return transaction.objectStore(storeName);\n    }\n    // Price History Cache Methods\n    async getPriceHistory(uuid) {\n        try {\n            const store = await this.getStore(STORES.PRICE_HISTORY);\n            const request = store.get(uuid);\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>{\n                    const result = request.result;\n                    if (!result) {\n                        resolve(null);\n                        return;\n                    }\n                    // Check if cache entry is expired\n                    if (Date.now() > result.expiresAt) {\n                        // Remove expired entry\n                        this.removePriceHistory(uuid);\n                        resolve(null);\n                        return;\n                    }\n                    resolve(result.data);\n                };\n                request.onerror = ()=>{\n                    reject(new Error('Failed to get price history from cache'));\n                };\n            });\n        } catch (error) {\n            console.error('Error getting price history from cache:', error);\n            return null;\n        }\n    }\n    async setPriceHistory(uuid, priceHistory) {\n        try {\n            const store = await this.getStore(STORES.PRICE_HISTORY, 'readwrite');\n            const cacheEntry = {\n                data: priceHistory,\n                timestamp: Date.now(),\n                expiresAt: Date.now() + CACHE_EXPIRY.PRICE_HISTORY\n            };\n            const request = store.put({\n                uuid,\n                ...cacheEntry\n            });\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to cache price history'));\n            });\n        } catch (error) {\n            console.error('Error caching price history:', error);\n            throw error;\n        }\n    }\n    async removePriceHistory(uuid) {\n        try {\n            const store = await this.getStore(STORES.PRICE_HISTORY, 'readwrite');\n            const request = store.delete(uuid);\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to remove price history'));\n            });\n        } catch (error) {\n            console.error('Error removing price history:', error);\n        }\n    }\n    // Card Mapping Cache Methods\n    async getCardMapping(scryfallId) {\n        try {\n            const store = await this.getStore(STORES.CARD_MAPPINGS);\n            const request = store.get(scryfallId);\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>{\n                    const result = request.result;\n                    if (!result) {\n                        resolve(null);\n                        return;\n                    }\n                    // Check if cache entry is expired\n                    if (Date.now() > result.expiresAt) {\n                        this.removeCardMapping(scryfallId);\n                        resolve(null);\n                        return;\n                    }\n                    resolve(result.data);\n                };\n                request.onerror = ()=>{\n                    reject(new Error('Failed to get card mapping from cache'));\n                };\n            });\n        } catch (error) {\n            console.error('Error getting card mapping from cache:', error);\n            return null;\n        }\n    }\n    async setCardMapping(scryfallId, mtgjsonCard) {\n        try {\n            const store = await this.getStore(STORES.CARD_MAPPINGS, 'readwrite');\n            const cacheEntry = {\n                data: mtgjsonCard,\n                timestamp: Date.now(),\n                expiresAt: Date.now() + CACHE_EXPIRY.CARD_MAPPINGS\n            };\n            const request = store.put({\n                scryfallId,\n                ...cacheEntry\n            });\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to cache card mapping'));\n            });\n        } catch (error) {\n            console.error('Error caching card mapping:', error);\n            throw error;\n        }\n    }\n    async removeCardMapping(scryfallId) {\n        try {\n            const store = await this.getStore(STORES.CARD_MAPPINGS, 'readwrite');\n            const request = store.delete(scryfallId);\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to remove card mapping'));\n            });\n        } catch (error) {\n            console.error('Error removing card mapping:', error);\n        }\n    }\n    // Metadata Methods\n    async getMetadata() {\n        try {\n            const store = await this.getStore(STORES.METADATA);\n            const request = store.get('metadata');\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>{\n                    const result = request.result;\n                    if (!result) {\n                        resolve(null);\n                        return;\n                    }\n                    // Check if metadata is expired\n                    if (Date.now() > result.expiresAt) {\n                        this.setMetadata({\n                            lastPriceUpdate: '',\n                            totalCards: 0,\n                            cacheVersion: '1.0'\n                        });\n                        resolve(null);\n                        return;\n                    }\n                    resolve(result.data);\n                };\n                request.onerror = ()=>{\n                    reject(new Error('Failed to get metadata from cache'));\n                };\n            });\n        } catch (error) {\n            console.error('Error getting metadata from cache:', error);\n            return null;\n        }\n    }\n    async setMetadata(metadata) {\n        try {\n            const store = await this.getStore(STORES.METADATA, 'readwrite');\n            const cacheEntry = {\n                data: metadata,\n                timestamp: Date.now(),\n                expiresAt: Date.now() + CACHE_EXPIRY.METADATA\n            };\n            const request = store.put({\n                key: 'metadata',\n                ...cacheEntry\n            });\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to cache metadata'));\n            });\n        } catch (error) {\n            console.error('Error caching metadata:', error);\n            throw error;\n        }\n    }\n    // Bulk Operations\n    async batchSetPriceHistories(priceHistories) {\n        try {\n            const store = await this.getStore(STORES.PRICE_HISTORY, 'readwrite');\n            const transaction = store.transaction;\n            const promises = priceHistories.map((param)=>{\n                let { uuid, data } = param;\n                const cacheEntry = {\n                    data,\n                    timestamp: Date.now(),\n                    expiresAt: Date.now() + CACHE_EXPIRY.PRICE_HISTORY\n                };\n                const request = store.put({\n                    uuid,\n                    ...cacheEntry\n                });\n                return new Promise((resolve, reject)=>{\n                    request.onsuccess = ()=>resolve();\n                    request.onerror = ()=>reject(new Error(\"Failed to cache price history for \".concat(uuid)));\n                });\n            });\n            await Promise.all(promises);\n            return new Promise((resolve, reject)=>{\n                transaction.oncomplete = ()=>resolve();\n                transaction.onerror = ()=>reject(new Error('Batch price history caching failed'));\n            });\n        } catch (error) {\n            console.error('Error batch caching price histories:', error);\n            throw error;\n        }\n    }\n    // Cache Management\n    async clearExpiredEntries() {\n        try {\n            const now = Date.now();\n            const stores = [\n                STORES.PRICE_HISTORY,\n                STORES.CARD_MAPPINGS,\n                STORES.METADATA\n            ];\n            for (const storeName of stores){\n                const store = await this.getStore(storeName, 'readwrite');\n                const request = store.openCursor();\n                await new Promise((resolve, reject)=>{\n                    request.onsuccess = ()=>{\n                        const cursor = request.result;\n                        if (cursor) {\n                            const entry = cursor.value;\n                            if (now > entry.expiresAt) {\n                                cursor.delete();\n                            }\n                            cursor.continue();\n                        } else {\n                            resolve();\n                        }\n                    };\n                    request.onerror = ()=>{\n                        reject(new Error(\"Failed to clear expired entries from \".concat(storeName)));\n                    };\n                });\n            }\n        } catch (error) {\n            console.error('Error clearing expired cache entries:', error);\n        }\n    }\n    async clearAllCache() {\n        try {\n            const stores = [\n                STORES.PRICE_HISTORY,\n                STORES.CARD_MAPPINGS,\n                STORES.METADATA\n            ];\n            for (const storeName of stores){\n                const store = await this.getStore(storeName, 'readwrite');\n                const request = store.clear();\n                await new Promise((resolve, reject)=>{\n                    request.onsuccess = ()=>resolve();\n                    request.onerror = ()=>reject(new Error(\"Failed to clear \".concat(storeName)));\n                });\n            }\n        } catch (error) {\n            console.error('Error clearing cache:', error);\n            throw error;\n        }\n    }\n    async getCacheStats() {\n        try {\n            const [priceCount, mappingCount] = await Promise.all([\n                this.getStoreCount(STORES.PRICE_HISTORY),\n                this.getStoreCount(STORES.CARD_MAPPINGS)\n            ]);\n            return {\n                priceHistoryCount: priceCount,\n                cardMappingCount: mappingCount,\n                totalSize: 0,\n                lastCleanup: null\n            };\n        } catch (error) {\n            console.error('Error getting cache stats:', error);\n            return {\n                priceHistoryCount: 0,\n                cardMappingCount: 0,\n                totalSize: 0,\n                lastCleanup: null\n            };\n        }\n    }\n    async getStoreCount(storeName) {\n        const store = await this.getStore(storeName);\n        const request = store.count();\n        return new Promise((resolve, reject)=>{\n            request.onsuccess = ()=>resolve(request.result);\n            request.onerror = ()=>reject(new Error(\"Failed to get count for \".concat(storeName)));\n        });\n    }\n    // Cleanup\n    async close() {\n        if (this.db) {\n            this.db.close();\n            this.db = null;\n            this.initPromise = null;\n        }\n    }\n    constructor(){\n        this.db = null;\n        this.initPromise = null;\n    }\n}\n// Export singleton instance\nconst mtgjsonCache = new MTGJSONCache();\n// Initialize cache on import (client-side only)\nif (true) {\n    mtgjsonCache.init().catch(console.error);\n    // Clean up expired entries on page load\n    setTimeout(()=>{\n        mtgjsonCache.clearExpiredEntries().catch(console.error);\n    }, 5000);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mtgjsonCache);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdXRpbHMvbXRnanNvbkNhY2hlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRUEsMkNBQTJDO0FBQzNDLE1BQU1BLFVBQVU7QUFDaEIsTUFBTUMsYUFBYTtBQUNuQixNQUFNQyxTQUFTO0lBQ2JDLGVBQWU7SUFDZkMsZUFBZTtJQUNmQyxVQUFVO0FBQ1o7QUFFQSxxQkFBcUI7QUFDckIsTUFBTUMsZUFBZTtJQUNuQkgsZUFBZSxLQUFLLEtBQUssS0FBSztJQUM5QkMsZUFBZSxJQUFJLEtBQUssS0FBSyxLQUFLO0lBQ2xDQyxVQUFVLEtBQUssS0FBSztBQUN0QjtBQWNBLE1BQU1FO0lBSUosTUFBTUMsT0FBc0I7UUFDMUIsSUFBSSxJQUFJLENBQUNDLEVBQUUsRUFBRTtRQUNiLElBQUksSUFBSSxDQUFDQyxXQUFXLEVBQUUsT0FBTyxJQUFJLENBQUNBLFdBQVc7UUFFN0MsSUFBSSxDQUFDQSxXQUFXLEdBQUcsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUN2QyxJQUFJLEtBQTZCLEVBQUUsRUFHbEM7WUFFRCxNQUFNRSxVQUFVQyxVQUFVQyxJQUFJLENBQUNqQixTQUFTQztZQUV4Q2MsUUFBUUcsT0FBTyxHQUFHO2dCQUNoQkwsT0FBTyxJQUFJQyxNQUFNO1lBQ25CO1lBRUFDLFFBQVFJLFNBQVMsR0FBRztnQkFDbEIsSUFBSSxDQUFDVixFQUFFLEdBQUdNLFFBQVFLLE1BQU07Z0JBQ3hCUjtZQUNGO1lBRUFHLFFBQVFNLGVBQWUsR0FBRyxDQUFDQztnQkFDekIsTUFBTWIsS0FBSyxNQUFPYyxNQUFNLENBQXNCSCxNQUFNO2dCQUVwRCw2QkFBNkI7Z0JBQzdCLElBQUksQ0FBQ1gsR0FBR2UsZ0JBQWdCLENBQUNDLFFBQVEsQ0FBQ3ZCLE9BQU9DLGFBQWEsR0FBRztvQkFDdkQsTUFBTXVCLGFBQWFqQixHQUFHa0IsaUJBQWlCLENBQUN6QixPQUFPQyxhQUFhLEVBQUU7d0JBQUV5QixTQUFTO29CQUFPO29CQUNoRkYs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R0FBRztRQUNyQjtJQUNGOzthQTNZUUQsS0FBeUI7YUFDekJDLGNBQW9DOztBQTJZOUM7QUFFQSw0QkFBNEI7QUFDckIsTUFBTWlGLGVBQWUsSUFBSXBGLGVBQWU7QUFFL0MsZ0RBQWdEO0FBQ2hELElBQUksSUFBNkIsRUFBRTtJQUNqQ29GLGFBQWFuRixJQUFJLEdBQUdvRixLQUFLLENBQUM3QyxRQUFRRCxLQUFLO0lBRXZDLHdDQUF3QztJQUN4QytDLFdBQVc7UUFDVEYsYUFBYW5CLG1CQUFtQixHQUFHb0IsS0FBSyxDQUFDN0MsUUFBUUQsS0FBSztJQUN4RCxHQUFHO0FBQ0w7QUFFQSxpRUFBZTZDLFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcbXRnLWluZGV4XFxzcmNcXGxpYlxcdXRpbHNcXG10Z2pzb25DYWNoZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNVEdKU09OQ2FyZFByaWNlcywgTVRHSlNPTkNhcmQsIFByaWNlSGlzdG9yeSB9IGZyb20gJ0AvbGliL3R5cGVzJztcclxuXHJcbi8vIEluZGV4ZWREQiBjb25maWd1cmF0aW9uIGZvciBNVEdKU09OIGRhdGFcclxuY29uc3QgREJfTkFNRSA9ICdNVEdKU09OQ2FjaGUnO1xyXG5jb25zdCBEQl9WRVJTSU9OID0gMTtcclxuY29uc3QgU1RPUkVTID0ge1xyXG4gIFBSSUNFX0hJU1RPUlk6ICdwcmljZUhpc3RvcnknLFxyXG4gIENBUkRfTUFQUElOR1M6ICdjYXJkTWFwcGluZ3MnLFxyXG4gIE1FVEFEQVRBOiAnbWV0YWRhdGEnLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuLy8gQ2FjaGUgZXhwaXJ5IHRpbWVzXHJcbmNvbnN0IENBQ0hFX0VYUElSWSA9IHtcclxuICBQUklDRV9ISVNUT1JZOiAyNCAqIDYwICogNjAgKiAxMDAwLCAvLyAyNCBob3Vyc1xyXG4gIENBUkRfTUFQUElOR1M6IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwLCAvLyA3IGRheXNcclxuICBNRVRBREFUQTogNjAgKiA2MCAqIDEwMDAsIC8vIDEgaG91clxyXG59IGFzIGNvbnN0O1xyXG5cclxuaW50ZXJmYWNlIENhY2hlRW50cnk8VD4ge1xyXG4gIGRhdGE6IFQ7XHJcbiAgdGltZXN0YW1wOiBudW1iZXI7XHJcbiAgZXhwaXJlc0F0OiBudW1iZXI7XHJcbn1cclxuXHJcbmludGVyZmFjZSBDYWNoZU1ldGFkYXRhIHtcclxuICBsYXN0UHJpY2VVcGRhdGU6IHN0cmluZztcclxuICB0b3RhbENhcmRzOiBudW1iZXI7XHJcbiAgY2FjaGVWZXJzaW9uOiBzdHJpbmc7XHJcbn1cclxuXHJcbmNsYXNzIE1UR0pTT05DYWNoZSB7XHJcbiAgcHJpdmF0ZSBkYjogSURCRGF0YWJhc2UgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIGluaXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIGFzeW5jIGluaXQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAodGhpcy5kYikgcmV0dXJuO1xyXG4gICAgaWYgKHRoaXMuaW5pdFByb21pc2UpIHJldHVybiB0aGlzLmluaXRQcm9taXNlO1xyXG5cclxuICAgIHRoaXMuaW5pdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0luZGV4ZWREQiBub3QgYXZhaWxhYmxlIGluIHNlcnZlciBlbnZpcm9ubWVudCcpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihEQl9OQU1FLCBEQl9WRVJTSU9OKTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gb3BlbiBJbmRleGVkREInKSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLmRiID0gcmVxdWVzdC5yZXN1bHQ7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCBkYiA9IChldmVudC50YXJnZXQgYXMgSURCT3BlbkRCUmVxdWVzdCkucmVzdWx0O1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgcHJpY2UgaGlzdG9yeSBzdG9yZVxyXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhTVE9SRVMuUFJJQ0VfSElTVE9SWSkpIHtcclxuICAgICAgICAgIGNvbnN0IHByaWNlU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShTVE9SRVMuUFJJQ0VfSElTVE9SWSwgeyBrZXlQYXRoOiAndXVpZCcgfSk7XHJcbiAgICAgICAgICBwcmljZVN0b3JlLmNyZWF0ZUluZGV4KCdjYXJkSWQnLCAnY2FyZElkJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgcHJpY2VTdG9yZS5jcmVhdGVJbmRleCgnbGFzdFVwZGF0ZWQnLCAnbGFzdFVwZGF0ZWQnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgY2FyZCBtYXBwaW5ncyBzdG9yZVxyXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhTVE9SRVMuQ0FSRF9NQVBQSU5HUykpIHtcclxuICAgICAgICAgIGNvbnN0IG1hcHBpbmdTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFUy5DQVJEX01BUFBJTkdTLCB7IGtleVBhdGg6ICdzY3J5ZmFsbElkJyB9KTtcclxuICAgICAgICAgIG1hcHBpbmdTdG9yZS5jcmVhdGVJbmRleCgndXVpZCcsICd1dWlkJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgbWFwcGluZ1N0b3JlLmNyZWF0ZUluZGV4KCduYW1lJywgJ25hbWUnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgbWV0YWRhdGEgc3RvcmVcclxuICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoU1RPUkVTLk1FVEFEQVRBKSkge1xyXG4gICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoU1RPUkVTLk1FVEFEQVRBLCB7IGtleVBhdGg6ICdrZXknIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRTdG9yZShzdG9yZU5hbWU6IHN0cmluZywgbW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlID0gJ3JlYWRvbmx5Jyk6IFByb21pc2U8SURCT2JqZWN0U3RvcmU+IHtcclxuICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG4gICAgaWYgKCF0aGlzLmRiKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIG5vdCBpbml0aWFsaXplZCcpO1xyXG5cclxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbc3RvcmVOYW1lXSwgbW9kZSk7XHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcclxuICB9XHJcblxyXG4gIC8vIFByaWNlIEhpc3RvcnkgQ2FjaGUgTWV0aG9kc1xyXG4gIGFzeW5jIGdldFByaWNlSGlzdG9yeSh1dWlkOiBzdHJpbmcpOiBQcm9taXNlPFByaWNlSGlzdG9yeSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuUFJJQ0VfSElTVE9SWSk7XHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXQodXVpZCk7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVxdWVzdC5yZXN1bHQgYXMgQ2FjaGVFbnRyeTxQcmljZUhpc3Rvcnk+IHwgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgY2FjaGUgZW50cnkgaXMgZXhwaXJlZFxyXG4gICAgICAgICAgaWYgKERhdGUubm93KCkgPiByZXN1bHQuZXhwaXJlc0F0KSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBleHBpcmVkIGVudHJ5XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUHJpY2VIaXN0b3J5KHV1aWQpO1xyXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBwcmljZSBoaXN0b3J5IGZyb20gY2FjaGUnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHByaWNlIGhpc3RvcnkgZnJvbSBjYWNoZTonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2V0UHJpY2VIaXN0b3J5KHV1aWQ6IHN0cmluZywgcHJpY2VIaXN0b3J5OiBQcmljZUhpc3RvcnkpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuUFJJQ0VfSElTVE9SWSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgY2FjaGVFbnRyeTogQ2FjaGVFbnRyeTxQcmljZUhpc3Rvcnk+ID0ge1xyXG4gICAgICAgIGRhdGE6IHByaWNlSGlzdG9yeSxcclxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgZXhwaXJlc0F0OiBEYXRlLm5vdygpICsgQ0FDSEVfRVhQSVJZLlBSSUNFX0hJU1RPUlksXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUucHV0KHsgdXVpZCwgLi4uY2FjaGVFbnRyeSB9KTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGNhY2hlIHByaWNlIGhpc3RvcnknKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FjaGluZyBwcmljZSBoaXN0b3J5OicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyByZW1vdmVQcmljZUhpc3RvcnkodXVpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuZ2V0U3RvcmUoU1RPUkVTLlBSSUNFX0hJU1RPUlksICdyZWFkd3JpdGUnKTtcclxuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmRlbGV0ZSh1dWlkKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHJlbW92ZSBwcmljZSBoaXN0b3J5JykpO1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHByaWNlIGhpc3Rvcnk6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2FyZCBNYXBwaW5nIENhY2hlIE1ldGhvZHNcclxuICBhc3luYyBnZXRDYXJkTWFwcGluZyhzY3J5ZmFsbElkOiBzdHJpbmcpOiBQcm9taXNlPE1UR0pTT05DYXJkIHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RvcmUgPSBhd2FpdCB0aGlzLmdldFN0b3JlKFNUT1JFUy5DQVJEX01BUFBJTkdTKTtcclxuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldChzY3J5ZmFsbElkKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXF1ZXN0LnJlc3VsdCBhcyBDYWNoZUVudHJ5PE1UR0pTT05DYXJkPiB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENoZWNrIGlmIGNhY2hlIGVudHJ5IGlzIGV4cGlyZWRcclxuICAgICAgICAgIGlmIChEYXRlLm5vdygpID4gcmVzdWx0LmV4cGlyZXNBdCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNhcmRNYXBwaW5nKHNjcnlmYWxsSWQpO1xyXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBjYXJkIG1hcHBpbmcgZnJvbSBjYWNoZScpKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY2FyZCBtYXBwaW5nIGZyb20gY2FjaGU6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHNldENhcmRNYXBwaW5nKHNjcnlmYWxsSWQ6IHN0cmluZywgbXRnanNvbkNhcmQ6IE1UR0pTT05DYXJkKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuZ2V0U3RvcmUoU1RPUkVTLkNBUkRfTUFQUElOR1MsICdyZWFkd3JpdGUnKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGNhY2hlRW50cnk6IENhY2hlRW50cnk8TVRHSlNPTkNhcmQ+ID0ge1xyXG4gICAgICAgIGRhdGE6IG10Z2pzb25DYXJkLFxyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICBleHBpcmVzQXQ6IERhdGUubm93KCkgKyBDQUNIRV9FWFBJUlkuQ0FSRF9NQVBQSU5HUyxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoeyBzY3J5ZmFsbElkLCAuLi5jYWNoZUVudHJ5IH0pO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gY2FjaGUgY2FyZCBtYXBwaW5nJykpO1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhY2hpbmcgY2FyZCBtYXBwaW5nOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyByZW1vdmVDYXJkTWFwcGluZyhzY3J5ZmFsbElkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuQ0FSRF9NQVBQSU5HUywgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZGVsZXRlKHNjcnlmYWxsSWQpO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVtb3ZlIGNhcmQgbWFwcGluZycpKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBjYXJkIG1hcHBpbmc6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTWV0YWRhdGEgTWV0aG9kc1xyXG4gIGFzeW5jIGdldE1ldGFkYXRhKCk6IFByb21pc2U8Q2FjaGVNZXRhZGF0YSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuTUVUQURBVEEpO1xyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KCdtZXRhZGF0YScpO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlcXVlc3QucmVzdWx0IGFzIENhY2hlRW50cnk8Q2FjaGVNZXRhZGF0YT4gfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDaGVjayBpZiBtZXRhZGF0YSBpcyBleHBpcmVkXHJcbiAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IHJlc3VsdC5leHBpcmVzQXQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRNZXRhZGF0YSh7XHJcbiAgICAgICAgICAgICAgbGFzdFByaWNlVXBkYXRlOiAnJyxcclxuICAgICAgICAgICAgICB0b3RhbENhcmRzOiAwLFxyXG4gICAgICAgICAgICAgIGNhY2hlVmVyc2lvbjogJzEuMCcsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBtZXRhZGF0YSBmcm9tIGNhY2hlJykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBtZXRhZGF0YSBmcm9tIGNhY2hlOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzZXRNZXRhZGF0YShtZXRhZGF0YTogQ2FjaGVNZXRhZGF0YSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RvcmUgPSBhd2FpdCB0aGlzLmdldFN0b3JlKFNUT1JFUy5NRVRBREFUQSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgY2FjaGVFbnRyeTogQ2FjaGVFbnRyeTxDYWNoZU1ldGFkYXRhPiA9IHtcclxuICAgICAgICBkYXRhOiBtZXRhZGF0YSxcclxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgZXhwaXJlc0F0OiBEYXRlLm5vdygpICsgQ0FDSEVfRVhQSVJZLk1FVEFEQVRBLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLnB1dCh7IGtleTogJ21ldGFkYXRhJywgLi4uY2FjaGVFbnRyeSB9KTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGNhY2hlIG1ldGFkYXRhJykpO1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhY2hpbmcgbWV0YWRhdGE6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJ1bGsgT3BlcmF0aW9uc1xyXG4gIGFzeW5jIGJhdGNoU2V0UHJpY2VIaXN0b3JpZXMocHJpY2VIaXN0b3JpZXM6IEFycmF5PHsgdXVpZDogc3RyaW5nOyBkYXRhOiBQcmljZUhpc3RvcnkgfT4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuUFJJQ0VfSElTVE9SWSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHN0b3JlLnRyYW5zYWN0aW9uO1xyXG5cclxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBwcmljZUhpc3Rvcmllcy5tYXAoKHsgdXVpZCwgZGF0YSB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2FjaGVFbnRyeTogQ2FjaGVFbnRyeTxQcmljZUhpc3Rvcnk+ID0ge1xyXG4gICAgICAgICAgZGF0YSxcclxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIGV4cGlyZXNBdDogRGF0ZS5ub3coKSArIENBQ0hFX0VYUElSWS5QUklDRV9ISVNUT1JZLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoeyB1dWlkLCAuLi5jYWNoZUVudHJ5IH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gY2FjaGUgcHJpY2UgaGlzdG9yeSBmb3IgJHt1dWlkfWApKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0JhdGNoIHByaWNlIGhpc3RvcnkgY2FjaGluZyBmYWlsZWQnKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYmF0Y2ggY2FjaGluZyBwcmljZSBoaXN0b3JpZXM6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENhY2hlIE1hbmFnZW1lbnRcclxuICBhc3luYyBjbGVhckV4cGlyZWRFbnRyaWVzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgY29uc3Qgc3RvcmVzID0gW1NUT1JFUy5QUklDRV9ISVNUT1JZLCBTVE9SRVMuQ0FSRF9NQVBQSU5HUywgU1RPUkVTLk1FVEFEQVRBXTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgc3RvcmVOYW1lIG9mIHN0b3Jlcykge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShzdG9yZU5hbWUsICdyZWFkd3JpdGUnKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUub3BlbkN1cnNvcigpO1xyXG5cclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVxdWVzdC5yZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcclxuICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGN1cnNvci52YWx1ZSBhcyBDYWNoZUVudHJ5PGFueT47XHJcbiAgICAgICAgICAgICAgaWYgKG5vdyA+IGVudHJ5LmV4cGlyZXNBdCkge1xyXG4gICAgICAgICAgICAgICAgY3Vyc29yLmRlbGV0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gY2xlYXIgZXhwaXJlZCBlbnRyaWVzIGZyb20gJHtzdG9yZU5hbWV9YCkpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2xlYXJpbmcgZXhwaXJlZCBjYWNoZSBlbnRyaWVzOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGNsZWFyQWxsQ2FjaGUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdG9yZXMgPSBbU1RPUkVTLlBSSUNFX0hJU1RPUlksIFNUT1JFUy5DQVJEX01BUFBJTkdTLCBTVE9SRVMuTUVUQURBVEFdO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBzdG9yZU5hbWUgb2Ygc3RvcmVzKSB7XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBhd2FpdCB0aGlzLmdldFN0b3JlKHN0b3JlTmFtZSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5jbGVhcigpO1xyXG5cclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBjbGVhciAke3N0b3JlTmFtZX1gKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFyaW5nIGNhY2hlOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZVN0YXRzKCk6IFByb21pc2U8e1xyXG4gICAgcHJpY2VIaXN0b3J5Q291bnQ6IG51bWJlcjtcclxuICAgIGNhcmRNYXBwaW5nQ291bnQ6IG51bWJlcjtcclxuICAgIHRvdGFsU2l6ZTogbnVtYmVyO1xyXG4gICAgbGFzdENsZWFudXA6IERhdGUgfCBudWxsO1xyXG4gIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IFtwcmljZUNvdW50LCBtYXBwaW5nQ291bnRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgIHRoaXMuZ2V0U3RvcmVDb3VudChTVE9SRVMuUFJJQ0VfSElTVE9SWSksXHJcbiAgICAgICAgdGhpcy5nZXRTdG9yZUNvdW50KFNUT1JFUy5DQVJEX01BUFBJTkdTKSxcclxuICAgICAgXSk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHByaWNlSGlzdG9yeUNvdW50OiBwcmljZUNvdW50LFxyXG4gICAgICAgIGNhcmRNYXBwaW5nQ291bnQ6IG1hcHBpbmdDb3VudCxcclxuICAgICAgICB0b3RhbFNpemU6IDAsIC8vIEluZGV4ZWREQiBkb2Vzbid0IHByb3ZpZGUgZWFzeSBzaXplIGNhbGN1bGF0aW9uXHJcbiAgICAgICAgbGFzdENsZWFudXA6IG51bGwsIC8vIFdvdWxkIG5lZWQgdG8gdHJhY2sgdGhpcyBzZXBhcmF0ZWx5XHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGNhY2hlIHN0YXRzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwcmljZUhpc3RvcnlDb3VudDogMCxcclxuICAgICAgICBjYXJkTWFwcGluZ0NvdW50OiAwLFxyXG4gICAgICAgIHRvdGFsU2l6ZTogMCxcclxuICAgICAgICBsYXN0Q2xlYW51cDogbnVsbCxcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0U3RvcmVDb3VudChzdG9yZU5hbWU6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuZ2V0U3RvcmUoc3RvcmVOYW1lKTtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5jb3VudCgpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCk7XHJcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgY291bnQgZm9yICR7c3RvcmVOYW1lfWApKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2xlYW51cFxyXG4gIGFzeW5jIGNsb3NlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKHRoaXMuZGIpIHtcclxuICAgICAgdGhpcy5kYi5jbG9zZSgpO1xyXG4gICAgICB0aGlzLmRiID0gbnVsbDtcclxuICAgICAgdGhpcy5pbml0UHJvbWlzZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBtdGdqc29uQ2FjaGUgPSBuZXcgTVRHSlNPTkNhY2hlKCk7XHJcblxyXG4vLyBJbml0aWFsaXplIGNhY2hlIG9uIGltcG9ydCAoY2xpZW50LXNpZGUgb25seSlcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbXRnanNvbkNhY2hlLmluaXQoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICBcclxuICAvLyBDbGVhbiB1cCBleHBpcmVkIGVudHJpZXMgb24gcGFnZSBsb2FkXHJcbiAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICBtdGdqc29uQ2FjaGUuY2xlYXJFeHBpcmVkRW50cmllcygpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gIH0sIDUwMDApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtdGdqc29uQ2FjaGU7XHJcbiJdLCJuYW1lcyI6WyJEQl9OQU1FIiwiREJfVkVSU0lPTiIsIlNUT1JFUyIsIlBSSUNFX0hJU1RPUlkiLCJDQVJEX01BUFBJTkdTIiwiTUVUQURBVEEiLCJDQUNIRV9FWFBJUlkiLCJNVEdKU09OQ2FjaGUiLCJpbml0IiwiZGIiLCJpbml0UHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiRXJyb3IiLCJyZXF1ZXN0IiwiaW5kZXhlZERCIiwib3BlbiIsIm9uZXJyb3IiLCJvbnN1Y2Nlc3MiLCJyZXN1bHQiLCJvbnVwZ3JhZGVuZWVkZWQiLCJldmVudCIsInRhcmdldCIsIm9iamVjdFN0b3JlTmFtZXMiLCJjb250YWlucyIsInByaWNlU3RvcmUiLCJjcmVhdGVPYmplY3RTdG9yZSIsImtleVBhdGgiLCJjcmVhdGVJbmRleCIsInVuaXF1ZSIsIm1hcHBpbmdTdG9yZSIsImdldFN0b3JlIiwic3RvcmVOYW1lIiwibW9kZSIsInRyYW5zYWN0aW9uIiwib2JqZWN0U3RvcmUiLCJnZXRQcmljZUhpc3RvcnkiLCJ1dWlkIiwic3RvcmUiLCJnZXQiLCJEYXRlIiwibm93IiwiZXhwaXJlc0F0IiwicmVtb3ZlUHJpY2VIaXN0b3J5IiwiZGF0YSIsImVycm9yIiwiY29uc29sZSIsInNldFByaWNlSGlzdG9yeSIsInByaWNlSGlzdG9yeSIsImNhY2hlRW50cnkiLCJ0aW1lc3RhbXAiLCJwdXQiLCJkZWxldGUiLCJnZXRDYXJkTWFwcGluZyIsInNjcnlmYWxsSWQiLCJyZW1vdmVDYXJkTWFwcGluZyIsInNldENhcmRNYXBwaW5nIiwibXRnanNvbkNhcmQiLCJnZXRNZXRhZGF0YSIsInNldE1ldGFkYXRhIiwibGFzdFByaWNlVXBkYXRlIiwidG90YWxDYXJkcyIsImNhY2hlVmVyc2lvbiIsIm1ldGFkYXRhIiwia2V5IiwiYmF0Y2hTZXRQcmljZUhpc3RvcmllcyIsInByaWNlSGlzdG9yaWVzIiwicHJvbWlzZXMiLCJtYXAiLCJhbGwiLCJvbmNvbXBsZXRlIiwiY2xlYXJFeHBpcmVkRW50cmllcyIsInN0b3JlcyIsIm9wZW5DdXJzb3IiLCJjdXJzb3IiLCJlbnRyeSIsInZhbHVlIiwiY29udGludWUiLCJjbGVhckFsbENhY2hlIiwiY2xlYXIiLCJnZXRDYWNoZVN0YXRzIiwicHJpY2VDb3VudCIsIm1hcHBpbmdDb3VudCIsImdldFN0b3JlQ291bnQiLCJwcmljZUhpc3RvcnlDb3VudCIsImNhcmRNYXBwaW5nQ291bnQiLCJ0b3RhbFNpemUiLCJsYXN0Q2xlYW51cCIsImNvdW50IiwiY2xvc2UiLCJtdGdqc29uQ2FjaGUiLCJjYXRjaCIsInNldFRpbWVvdXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/utils/mtgjsonCache.ts\n"));

/***/ })

}]);