"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_api_mtgjson_ts"],{

/***/ "(app-pages-browser)/./src/lib/api/mtgjson.ts":
/*!********************************!*\
  !*** ./src/lib/api/mtgjson.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MTGJSON_CONFIG: () => (/* binding */ MTGJSON_CONFIG),\n/* harmony export */   batchGetPriceHistories: () => (/* binding */ batchGetPriceHistories),\n/* harmony export */   clearMTGJSONCache: () => (/* binding */ clearMTGJSONCache),\n/* harmony export */   convertMTGJSONPrices: () => (/* binding */ convertMTGJSONPrices),\n/* harmony export */   fetchPriceHistoryByUUID: () => (/* binding */ fetchPriceHistoryByUUID),\n/* harmony export */   getCardMapping: () => (/* binding */ getCardMapping),\n/* harmony export */   getMTGJSONCacheStats: () => (/* binding */ getMTGJSONCacheStats),\n/* harmony export */   getPriceHistoryForCard: () => (/* binding */ getPriceHistoryForCard)\n/* harmony export */ });\n/* harmony import */ var _lib_services_cardMappingService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/services/cardMappingService */ \"(app-pages-browser)/./src/lib/services/cardMappingService.ts\");\n// MTGJSON Configuration\nconst MTGJSON_CONFIG = {\n    baseUrl: 'https://mtgjson.com/api/v5',\n    cacheExpiry: 24 * 60 * 60 * 1000,\n    preferredProvider: 'tcgplayer',\n    enableCaching: true\n};\n// Cache management\nconst CACHE_KEYS = {\n    ALL_PRICES: 'mtgjson-all-prices',\n    CARD_MAPPINGS: 'mtgjson-card-mappings',\n    PRICE_HISTORY: 'mtgjson-price-history-'\n};\n// Rate limiting: MTGJSON doesn't specify limits, but we'll be conservative\nconst RATE_LIMIT_DELAY = 200; // 200ms between requests\nlet lastRequestTime = 0;\nasync function rateLimitedFetch(url) {\n    const now = Date.now();\n    const timeSinceLastRequest = now - lastRequestTime;\n    if (timeSinceLastRequest < RATE_LIMIT_DELAY) {\n        await new Promise((resolve)=>setTimeout(resolve, RATE_LIMIT_DELAY - timeSinceLastRequest));\n    }\n    lastRequestTime = Date.now();\n    try {\n        console.log(\"Fetching MTGJSON data: \".concat(url));\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\"MTGJSON API Error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        return response;\n    } catch (error) {\n        console.error('MTGJSON API request failed:', {\n            url,\n            error: error instanceof Error ? error.message : 'Unknown error',\n            timestamp: new Date().toISOString()\n        });\n        if (error instanceof Error) {\n            if (error.message.includes('Failed to fetch')) {\n                throw new Error('Network error: Unable to connect to MTGJSON API. Please check your internet connection.');\n            }\n        }\n        throw error;\n    }\n}\n// Cache utilities\nfunction getCachedData(key) {\n    if (!MTGJSON_CONFIG.enableCaching || \"object\" === 'undefined') {\n        return null;\n    }\n    try {\n        const cached = localStorage.getItem(key);\n        if (!cached) return null;\n        const parsed = JSON.parse(cached);\n        const now = Date.now();\n        if (parsed.expiresAt && now > parsed.expiresAt) {\n            localStorage.removeItem(key);\n            return null;\n        }\n        return parsed.data;\n    } catch (error) {\n        console.error(\"Error reading cache for key \".concat(key, \":\"), error);\n        return null;\n    }\n}\nfunction setCachedData(key, data, customExpiry) {\n    if (!MTGJSON_CONFIG.enableCaching || \"object\" === 'undefined') {\n        return;\n    }\n    try {\n        const expiry = customExpiry || MTGJSON_CONFIG.cacheExpiry;\n        const cacheEntry = {\n            data,\n            expiresAt: Date.now() + expiry,\n            cachedAt: Date.now()\n        };\n        localStorage.setItem(key, JSON.stringify(cacheEntry));\n    } catch (error) {\n        console.error(\"Error setting cache for key \".concat(key, \":\"), error);\n    }\n}\n// Import the card mapping service\n\n// Map Scryfall card to MTGJSON UUID\nasync function getCardMapping(scryfallCard) {\n    try {\n        // Use the card mapping service\n        const uuid = await _lib_services_cardMappingService__WEBPACK_IMPORTED_MODULE_0__.cardMappingService.getMapping(scryfallCard);\n        if (uuid) {\n            // Cache the successful mapping\n            const cacheKey = \"\".concat(CACHE_KEYS.CARD_MAPPINGS).concat(scryfallCard.id);\n            setCachedData(cacheKey, uuid);\n        }\n        return uuid;\n    } catch (error) {\n        console.error(\"Error getting card mapping for \".concat(scryfallCard.name, \":\"), error);\n        return null;\n    }\n}\n// Fetch price history for a specific UUID\nasync function fetchPriceHistoryByUUID(uuid) {\n    try {\n        // Check cache first\n        const cacheKey = \"\".concat(CACHE_KEYS.PRICE_HISTORY).concat(uuid);\n        const cached = getCachedData(cacheKey);\n        if (cached) return cached;\n        // Try to get from AllPrices data\n        const priceData = await getAllPricesData();\n        if (priceData && priceData[uuid]) {\n            const cardPrices = priceData[uuid];\n            // Cache the result\n            setCachedData(cacheKey, cardPrices);\n            return cardPrices;\n        }\n        console.log(\"No price history found for UUID \".concat(uuid));\n        return null;\n    } catch (error) {\n        console.error('Error fetching price history:', error);\n        return null;\n    }\n}\n// Fetch and cache AllPrices.json data\nlet allPricesCache = null;\nlet allPricesLoadingPromise = null;\nasync function getAllPricesData() {\n    // Return cached data if available\n    if (allPricesCache) {\n        return allPricesCache;\n    }\n    // Return existing loading promise if in progress\n    if (allPricesLoadingPromise) {\n        return allPricesLoadingPromise;\n    }\n    // Start loading AllPrices data\n    allPricesLoadingPromise = loadAllPricesData();\n    return allPricesLoadingPromise;\n}\nasync function loadAllPricesData() {\n    try {\n        var _allPricesResponse_meta;\n        console.log('Loading MTGJSON AllPrices data...');\n        // Check if we have cached AllPrices data\n        const cachedAllPrices = getCachedData('mtgjson-all-prices-data');\n        // Use cached data if it's less than 24 hours old\n        if (cachedAllPrices && Date.now() - cachedAllPrices.timestamp < 24 * 60 * 60 * 1000) {\n            console.log('Using cached AllPrices data');\n            allPricesCache = cachedAllPrices.data;\n            return allPricesCache;\n        }\n        // Fetch fresh AllPrices data\n        console.log('Fetching fresh AllPrices data from MTGJSON...');\n        const response = await rateLimitedFetch('https://mtgjson.com/api/v5/AllPrices.json');\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch AllPrices: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        // Parse the JSON response\n        const allPricesResponse = await response.json();\n        if (!allPricesResponse.data) {\n            throw new Error('Invalid AllPrices response format');\n        }\n        // Cache the data\n        const cacheData = {\n            data: allPricesResponse.data,\n            timestamp: Date.now(),\n            version: ((_allPricesResponse_meta = allPricesResponse.meta) === null || _allPricesResponse_meta === void 0 ? void 0 : _allPricesResponse_meta.version) || 'unknown'\n        };\n        setCachedData('mtgjson-all-prices-data', cacheData);\n        allPricesCache = allPricesResponse.data;\n        console.log(\"Loaded AllPrices data for \".concat(Object.keys(allPricesCache || {}).length, \" cards\"));\n        return allPricesCache;\n    } catch (error) {\n        console.error('Failed to load AllPrices data:', error);\n        // Try to use stale cached data as fallback\n        const staleCache = getCachedData('mtgjson-all-prices-data');\n        if (staleCache) {\n            console.warn('Using stale AllPrices cache due to fetch failure');\n            allPricesCache = staleCache.data;\n            return allPricesCache;\n        }\n        return null;\n    } finally{\n        allPricesLoadingPromise = null;\n    }\n}\n// Convert MTGJSON price data to our internal format\nfunction convertMTGJSONPrices(uuid, mtgjsonPrices, cardName) {\n    const processedPrices = [];\n    try {\n        var _mtgjsonPrices_paper;\n        // Get the preferred provider's data\n        const provider = MTGJSON_CONFIG.preferredProvider;\n        const paperPrices = (_mtgjsonPrices_paper = mtgjsonPrices.paper) === null || _mtgjsonPrices_paper === void 0 ? void 0 : _mtgjsonPrices_paper[provider];\n        if (paperPrices === null || paperPrices === void 0 ? void 0 : paperPrices.normal) {\n            paperPrices.normal.forEach((pricePoint)=>{\n                processedPrices.push({\n                    cardId: uuid,\n                    date: pricePoint.date,\n                    price: pricePoint.price,\n                    priceType: 'usd'\n                });\n            });\n        }\n        if (paperPrices === null || paperPrices === void 0 ? void 0 : paperPrices.foil) {\n            paperPrices.foil.forEach((pricePoint)=>{\n                processedPrices.push({\n                    cardId: uuid,\n                    date: pricePoint.date,\n                    price: pricePoint.price,\n                    priceType: 'usdFoil'\n                });\n            });\n        }\n    } catch (error) {\n        console.error(\"Error converting MTGJSON prices for \".concat(cardName, \":\"), error);\n    }\n    return processedPrices.sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n}\n// Get price history for a Scryfall card\nasync function getPriceHistoryForCard(scryfallCard) {\n    try {\n        // First, get the MTGJSON UUID mapping\n        const uuid = await getCardMapping(scryfallCard);\n        if (!uuid) {\n            console.log(\"No MTGJSON mapping found for \".concat(scryfallCard.name));\n            return null;\n        }\n        // Fetch the price history\n        const mtgjsonPrices = await fetchPriceHistoryByUUID(uuid);\n        if (!mtgjsonPrices) {\n            return null;\n        }\n        // Convert to our internal format\n        const processedPrices = convertMTGJSONPrices(uuid, mtgjsonPrices, scryfallCard.name);\n        if (processedPrices.length === 0) {\n            return null;\n        }\n        // Calculate trend and volatility\n        const prices = processedPrices.map((p)=>p.price);\n        const averagePrice = prices.reduce((sum, price)=>sum + price, 0) / prices.length;\n        // Simple trend calculation (last 7 days vs previous 7 days)\n        const recent = prices.slice(-7);\n        const previous = prices.slice(-14, -7);\n        const recentAvg = recent.reduce((sum, p)=>sum + p, 0) / recent.length;\n        const previousAvg = previous.reduce((sum, p)=>sum + p, 0) / previous.length;\n        const trend = recentAvg > previousAvg * 1.05 ? 'up' : recentAvg < previousAvg * 0.95 ? 'down' : 'stable';\n        // Calculate volatility (standard deviation)\n        const variance = prices.reduce((sum, price)=>sum + Math.pow(price - averagePrice, 2), 0) / prices.length;\n        const volatility = Math.sqrt(variance);\n        // Calculate percentage changes\n        const percentChange24h = prices.length >= 2 ? (prices[prices.length - 1] - prices[prices.length - 2]) / prices[prices.length - 2] * 100 : undefined;\n        const percentChange7d = recent.length > 0 && previous.length > 0 ? (recentAvg - previousAvg) / previousAvg * 100 : undefined;\n        return {\n            cardId: scryfallCard.id,\n            uuid,\n            prices: processedPrices,\n            trend,\n            volatility,\n            averagePrice,\n            percentChange24h,\n            percentChange7d,\n            lastUpdated: new Date().toISOString(),\n            provider: 'mtgjson'\n        };\n    } catch (error) {\n        console.error(\"Error getting price history for \".concat(scryfallCard.name, \":\"), error);\n        return null;\n    }\n}\n// Batch fetch price histories for multiple cards\nasync function batchGetPriceHistories(cards) {\n    const results = new Map();\n    // Process cards in batches to avoid overwhelming the system\n    const batchSize = 10;\n    for(let i = 0; i < cards.length; i += batchSize){\n        const batch = cards.slice(i, i + batchSize);\n        const batchPromises = batch.map(async (card)=>{\n            const history = await getPriceHistoryForCard(card);\n            if (history) {\n                results.set(card.id, history);\n            }\n        });\n        await Promise.all(batchPromises);\n        // Add a small delay between batches\n        if (i + batchSize < cards.length) {\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n        }\n    }\n    return results;\n}\n// Utility function to clear MTGJSON cache\nfunction clearMTGJSONCache() {\n    if (false) {}\n    try {\n        const keys = Object.keys(localStorage);\n        keys.forEach((key)=>{\n            if (key.startsWith('mtgjson-')) {\n                localStorage.removeItem(key);\n            }\n        });\n        console.log('MTGJSON cache cleared');\n    } catch (error) {\n        console.error('Error clearing MTGJSON cache:', error);\n    }\n}\n// Get cache statistics\nfunction getMTGJSONCacheStats() {\n    if (false) {}\n    try {\n        const keys = Object.keys(localStorage);\n        const mtgjsonKeys = keys.filter((key)=>key.startsWith('mtgjson-'));\n        let totalSize = 0;\n        const cacheEntries = mtgjsonKeys.map((key)=>{\n            const data = localStorage.getItem(key);\n            const size = data ? data.length : 0;\n            totalSize += size;\n            return {\n                key,\n                size,\n                sizeFormatted: \"\".concat((size / 1024).toFixed(2), \" KB\")\n            };\n        });\n        return {\n            totalEntries: mtgjsonKeys.length,\n            totalSize,\n            totalSizeFormatted: \"\".concat((totalSize / 1024 / 1024).toFixed(2), \" MB\"),\n            entries: cacheEntries\n        };\n    } catch (error) {\n        console.error('Error getting cache stats:', error);\n        return null;\n    }\n}\n// Export configuration for external use\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpL210Z2pzb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBV0Esd0JBQXdCO0FBQ3hCLE1BQU1BLGlCQUFnQztJQUNwQ0MsU0FBUztJQUNUQyxhQUFhLEtBQUssS0FBSyxLQUFLO0lBQzVCQyxtQkFBbUI7SUFDbkJDLGVBQWU7QUFDakI7QUFFQSxtQkFBbUI7QUFDbkIsTUFBTUMsYUFBYTtJQUNqQkMsWUFBWTtJQUNaQyxlQUFlO0lBQ2ZDLGVBQWU7QUFDakI7QUFFQSwyRUFBMkU7QUFDM0UsTUFBTUMsbUJBQW1CLEtBQUsseUJBQXlCO0FBQ3ZELElBQUlDLGtCQUFrQjtBQUV0QixlQUFlQyxpQkFBaUJDLEdBQVc7SUFDekMsTUFBTUMsTUFBTUMsS0FBS0QsR0FBRztJQUNwQixNQUFNRSx1QkFBdUJGLE1BQU1IO0lBRW5DLElBQUlLLHVCQUF1Qk4sa0JBQWtCO1FBQzNDLE1BQU0sSUFBSU8sUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBU1IsbUJBQW1CTTtJQUN0RTtJQUVBTCxrQkFBa0JJLEtBQUtELEdBQUc7SUFFMUIsSUFBSTtRQUNGTSxRQUFRQyxHQUFHLENBQUMsMEJBQThCLE9BQUpSO1FBQ3RDLE1BQU1TLFdBQVcsTUFBTUMsTUFBTVY7UUFFN0IsSUFBSSxDQUFDUyxTQUFTRSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJQyxNQUFNLHNCQUF5Q0gsT0FBbkJBLFNBQVNJLE1BQU0sRUFBQyxLQUF1QixPQUFwQkosU0FBU0ssVUFBVTtRQUM5RTtRQUVBLE9BQU9MO0lBQ1QsRUFBRSxPQUFPTSxPQUFPO1FBQ2RSLFFBQVFRLEtBQUssQ0FBQywrQkFBK0I7WUFDM0NmO1lBQ0FlLE9BQU9BLGlCQUFpQkgsUUFBUUcsTUFBTUMsT0FBTyxHQUFHO1lBQ2hEQyxXQUFXLElBQUlmLE9BQU9nQixXQUFXO1FBQ25DO1FBRUEsSUFBSUgsaUJBQWlCSCxPQUFPO1lBQzFCLElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0csUUFBUSxDQUFDLG9CQUFvQjtnQkFDN0MsTUFBTSxJQUFJUCxNQUFNO1lBQ2xCO1FBQ0Y7UUFFQSxNQUFNRztJQUNSO0FBQ0Y7QUFFQSxrQkFBa0I7QUFDbEIsU0FBU0ssY0FBaUJDLEdBQVc7SUFDbkMsSUFBSSxDQUFDakMsZUFBZUksYUFBYSxJQUFJLGFBQWtCLGFBQWE7UUFDbEUsT0FBTztJQUNUO0lBRUEsSUFBSTtRQUNGLE1BQU04QixTQUFTQyxhQUFhQyxPQUFPLENBQUNIO1FBQ3BDLElBQUksQ0FBQ0MsUUFBUSxPQUFPO1FBRXBCLE1BQU1HLFNBQVNDLEtBQUtDLEtBQUssQ0FBQ0w7UUFDMUIsTUFBTXJCLE1BQU1DLEtBQUtELEdBQUc7UUFFcEIsSUFBSXdCLE9BQU9HLFNBQVMsSUFBSTNCLE1BQU13QixPQUFPRyxTQUFTLEVBQUU7WUFDOUNMLGFBQWFNLFVBQVUsQ0FBQ1I7WUFDeEIsT0FBTztRQUNUO1FBRUEsT0FBT0ksT0FBT0ssSUFBSTtJQUNwQixFQUFFLE9BQU9mLE9BQU87UUFDZFIsUUFBUVEsS0FBSyxDQUFDLCtCQUFtQyxPQUFKTSxLQUFJLE1BQUlOO1FBQ3JELE9BQU87SUFDVDtBQUNGO0FBRUEsU0FBU2dCLGNBQWlCVixHQUFXLEVBQUVTLElBQU8sRUFBRUUsWUFBcUI7SUFDbkUsSUFBSSxDQUFDNUMsZUFBZUksYUFBYSxJQUFJLGFBQWtCLGFBQWE7UUFDbEU7SUFDRjtJQUVBLElBQUk7UUFDRixNQUFNeUMsU0FBU0QsZ0JBQWdCNUMsZUFBZUUsV0FBVztRQUN6RCxNQUFNNEMsYUFBYTtZQUNqQko7WUFDQUYsV0FBVzFCLEtBQUtELEdBQUcsS0FBS2dDO1lBQ3hCRSxVQUFVakMsS0FBS0QsR0FBRztRQUNwQjtRQUVBc0IsYUFBYWEsT0FBTyxDQUFDZixLQUFLSyxLQUFLVyxTQUFTLENBQUNIO0lBQzNDLEVBQUUsT0FBT25CLE9BQU87UUFDZFIsUUFBUVEsS0FBSyxDQUFDLCtCQUFtQyxPQUFKTSxLQUFJLE1BQUlOO0lBQ3ZEO0FBQ0Y7QUFFQSxrQ0FBa0M7QUFDcUM7QUFFdkUsb0NBQW9DO0FBQzdCLGVBQWV3QixlQUFlQyxZQUFxQjtJQUN4RCxJQUFJO1FBQ0YsK0JBQStCO1FBQy9CLE1BQU1DLE9BQU8sTUFBTUgsZ0ZBQWtCQSxDQUFDSSxVQUFVLENBQUNGO1FBRWpELElBQUlDLE1BQU07WUFDUiwrQkFBK0I7WUFDL0IsTUFBTUUsV0FBVyxHQUE4QkgsT0FBM0IvQyxXQUFXRSxhQUFhLEVBQW1CLE9BQWhCNkMsYUFBYUksRUFBRTtZQUM5RGIsY0FBY1ksVUFBVUY7UUFDMUI7UUFFQSxPQUFPQTtJQUNULEVBQUUsT0FBTzFCLE9BQU87UUFDZFIsUUFBUVEsS0FBSyxDQUFDLGtDQUFvRCxPQUFsQnlCLGFBQWFLLElBQUksRUFBQyxNQUFJOUI7UUFDdEUsT0FBTztJQUNUO0FBQ0Y7QUFFQSwwQ0FBMEM7QUFDbkMsZUFBZStCLHdCQUF3QkwsSUFBWTtJQUN4RCxJQUFJO1FBQ0Ysb0JBQW9CO1FBQ3BCLE1BQU1FLFdBQVcsR0FBOEJGLE9BQTNCaEQsV0FBV0csYUFBYSxFQUFRLE9BQUw2QztRQUMvQyxNQUFNbkIsU0FBU0YsY0FBaUN1QjtRQUNoRCxJQUFJckIsUUFBUSxPQUFPQTtRQUVuQixpQ0FBaUM7UUFDakMsTUFBTXlCLFlBQVksTUFBTUM7UUFDeEIsSUFBSUQsYUFBYUEsU0FBUyxDQUFDTixLQUFLLEVBQUU7WUFDaEMsTUFBTVEsYUFBYUYsU0FBUyxDQUFDTixLQUFLO1lBRWxDLG1CQUFtQjtZQUNuQlYsY0FBY1ksVUFBVU07WUFFeEIsT0FBT0E7UUFDVDtRQUVBMUMsUUFBUUMsR0FBRyxDQUFDLG1DQUF3QyxPQUFMaUM7UUFDL0MsT0FBTztJQUNULEVBQUUsT0FBTzFCLE9BQU87UUFDZFIsUUFBUVEsS0FBSyxDQUFDLGlDQUFpQ0E7UUFDL0MsT0FBTztJQUNUO0FBQ0Y7QUFFQSxzQ0FBc0M7QUFDdEMsSUFBSW1DLGlCQUEyRDtBQUMvRCxJQUFJQywwQkFBb0Y7QUFFeEYsZUFBZUg7SUFDYixrQ0FBa0M7SUFDbEMsSUFBSUUsZ0JBQWdCO1FBQ2xCLE9BQU9BO0lBQ1Q7SUFFQSxpREFBaUQ7SUFDakQsSUFBSUMseUJBQXlCO1FBQzNCLE9BQU9BO0lBQ1Q7SUFFQSwrQkFBK0I7SUFDL0JBLDBCQUEwQkM7SUFDMUIsT0FBT0Q7QUFDVDtBQUVBLGVBQWVDO0lBQ2IsSUFBSTtZQW9DU0M7UUFuQ1g5QyxRQUFRQyxHQUFHLENBQUM7UUFFWix5Q0FBeUM7UUFDekMsTUFBTThDLGtCQUFrQmxDLGNBSXJCO1FBRUgsaURBQWlEO1FBQ2pELElBQUlrQyxtQkFBbUIsS0FBTXJELEdBQUcsS0FBS3FELGdCQUFnQnJDLFNBQVMsR0FBSSxLQUFLLEtBQUssS0FBSyxNQUFNO1lBQ3JGVixRQUFRQyxHQUFHLENBQUM7WUFDWjBDLGlCQUFpQkksZ0JBQWdCeEIsSUFBSTtZQUNyQyxPQUFPb0I7UUFDVDtRQUVBLDZCQUE2QjtRQUM3QjNDLFFBQVFDLEdBQUcsQ0FBQztRQUNaLE1BQU1DLFdBQVcsTUFBTVYsaUJBQWlCO1FBRXhDLElBQUksQ0FBQ1UsU0FBU0UsRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUMsTUFBTSw4QkFBaURILE9BQW5CQSxTQUFTSSxNQUFNLEVBQUMsS0FBdUIsT0FBcEJKLFNBQVNLLFVBQVU7UUFDdEY7UUFFQSwwQkFBMEI7UUFDMUIsTUFBTXVDLG9CQUFvQixNQUFNNUMsU0FBUzhDLElBQUk7UUFFN0MsSUFBSSxDQUFDRixrQkFBa0J2QixJQUFJLEVBQUU7WUFDM0IsTUFBTSxJQUFJbEIsTUFBTTtRQUNsQjtRQUVBLGlCQUFpQjtRQUNqQixNQUFNNEMsWUFBWTtZQUNoQjFCLE1BQU11QixrQkFBa0J2QixJQUFJO1lBQzVCYixXQUFXZixLQUFLRCxHQUFHO1lBQ25Cd0QsU0FBU0osRUFBQUEsMEJBQUFBLGtCQUFrQkssSUFBSSxjQUF0QkwsOENBQUFBLHdCQUF3QkksT0FBTyxLQUFJO1FBQzlDO1FBRUExQixjQUFjLDJCQUEyQnlCO1FBQ3pDTixpQkFBaUJHLGtCQUFrQnZCLElBQUk7UUFFdkN2QixRQUFRQyxHQUFHLENBQUMsNkJBQXNFLE9BQXpDbUQsT0FBT0MsSUFBSSxDQUFDVixrQkFBa0IsQ0FBQyxHQUFHVyxNQUFNLEVBQUM7UUFDbEYsT0FBT1g7SUFDVCxFQUFFLE9BQU9uQyxPQUFPO1FBQ2RSLFFBQVFRLEtBQUssQ0FBQyxrQ0FBa0NBO1FBRWhELDJDQUEyQztRQUMzQyxNQUFNK0MsYUFBYTFDLGNBR2hCO1FBRUgsSUFBSTBDLFlBQVk7WUFDZHZELFFBQVF3RCxJQUFJLENBQUM7WUFDYmIsaUJBQWlCWSxXQUFXaEMsSUFBSTtZQUNoQyxPQUFPb0I7UUFDVDtRQUVBLE9BQU87SUFDVCxTQUFVO1FBQ1JDLDBCQUEwQjtJQUM1QjtBQUNGO0FBRUEsb0RBQW9EO0FBQzdDLFNBQVNhLHFCQUNkdkIsSUFBWSxFQUNad0IsYUFBZ0MsRUFDaENDLFFBQWdCO0lBRWhCLE1BQU1DLGtCQUF3QyxFQUFFO0lBRWhELElBQUk7WUFHa0JGO1FBRnBCLG9DQUFvQztRQUNwQyxNQUFNRyxXQUFXaEYsZUFBZUcsaUJBQWlCO1FBQ2pELE1BQU04RSxlQUFjSix1QkFBQUEsY0FBY0ssS0FBSyxjQUFuQkwsMkNBQUFBLG9CQUFxQixDQUFDRyxTQUFTO1FBRW5ELElBQUlDLHdCQUFBQSxrQ0FBQUEsWUFBYUUsTUFBTSxFQUFFO1lBQ3ZCRixZQUFZRSxNQUFNLENBQUNDLE9BQU8sQ0FBQ0MsQ0FBQUE7Z0JBQ3pCTixnQkFBZ0JPLElBQUksQ0FBQztvQkFDbkJDLFFBQVFsQztvQkFDUm1DLE1BQU1ILFdBQVdHLElBQUk7b0JBQ3JCQyxPQUFPSixXQUFXSSxLQUFLO29CQUN2QkMsV0FBVztnQkFDYjtZQUNGO1FBQ0Y7UUFFQSxJQUFJVCx3QkFBQUEsa0NBQUFBLFlBQWFVLElBQUksRUFBRTtZQUNyQlYsWUFBWVUsSUFBSSxDQUFDUCxPQUFPLENBQUNDLENBQUFBO2dCQUN2Qk4sZ0JBQWdCTyxJQUFJLENBQUM7b0JBQ25CQyxRQUFRbEM7b0JBQ1JtQyxNQUFNSCxXQUFXRyxJQUFJO29CQUNyQkMsT0FBT0osV0FBV0ksS0FBSztvQkFDdkJDLFdBQVc7Z0JBQ2I7WUFDRjtRQUNGO0lBQ0YsRUFBRSxPQUFPL0QsT0FBTztRQUNkUixRQUFRUSxLQUFLLENBQUMsdUNBQWdELE9BQVRtRCxVQUFTLE1BQUluRDtJQUNwRTtJQUVBLE9BQU9vRCxnQkFBZ0JhLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNLElBQUloRixLQUFLK0UsRUFBRUwsSUFBSSxFQUFFTyxPQUFPLEtBQUssSUFBSWpGLEtBQUtnRixFQUFFTixJQUFJLEVBQUVPLE9BQU87QUFDN0Y7QUFFQSx3Q0FBd0M7QUFDakMsZUFBZUMsdUJBQXVCNUMsWUFBcUI7SUFDaEUsSUFBSTtRQUNGLHNDQUFzQztRQUN0QyxNQUFNQyxPQUFPLE1BQU1GLGVBQWVDO1FBQ2xDLElBQUksQ0FBQ0MsTUFBTTtZQUNUbEMsUUFBUUMsR0FBRyxDQUFDLGdDQUFrRCxPQUFsQmdDLGFBQWFLLElBQUk7WUFDN0QsT0FBTztRQUNUO1FBRUEsMEJBQTBCO1FBQzFCLE1BQU1vQixnQkFBZ0IsTUFBTW5CLHdCQUF3Qkw7UUFDcEQsSUFBSSxDQUFDd0IsZUFBZTtZQUNsQixPQUFPO1FBQ1Q7UUFFQSxpQ0FBaUM7UUFDakMsTUFBTUUsa0JBQWtCSCxxQkFBcUJ2QixNQUFNd0IsZUFBZXpCLGFBQWFLLElBQUk7UUFFbkYsSUFBSXNCLGdCQUFnQk4sTUFBTSxLQUFLLEdBQUc7WUFDaEMsT0FBTztRQUNUO1FBRUEsaUNBQWlDO1FBQ2pDLE1BQU13QixTQUFTbEIsZ0JBQWdCbUIsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFVixLQUFLO1FBQy9DLE1BQU1XLGVBQWVILE9BQU9JLE1BQU0sQ0FBQyxDQUFDQyxLQUFLYixRQUFVYSxNQUFNYixPQUFPLEtBQUtRLE9BQU94QixNQUFNO1FBRWxGLDREQUE0RDtRQUM1RCxNQUFNOEIsU0FBU04sT0FBT08sS0FBSyxDQUFDLENBQUM7UUFDN0IsTUFBTUMsV0FBV1IsT0FBT08sS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQ3BDLE1BQU1FLFlBQVlILE9BQU9GLE1BQU0sQ0FBQyxDQUFDQyxLQUFLSCxJQUFNRyxNQUFNSCxHQUFHLEtBQUtJLE9BQU85QixNQUFNO1FBQ3ZFLE1BQU1rQyxjQUFjRixTQUFTSixNQUFNLENBQUMsQ0FBQ0MsS0FBS0gsSUFBTUcsTUFBTUgsR0FBRyxLQUFLTSxTQUFTaEMsTUFBTTtRQUU3RSxNQUFNbUMsUUFDSkYsWUFBWUMsY0FBYyxPQUFPLE9BQ2pDRCxZQUFZQyxjQUFjLE9BQU8sU0FBUztRQUU1Qyw0Q0FBNEM7UUFDNUMsTUFBTUUsV0FBV1osT0FBT0ksTUFBTSxDQUFDLENBQUNDLEtBQUtiLFFBQVVhLE1BQU1RLEtBQUtDLEdBQUcsQ0FBQ3RCLFFBQVFXLGNBQWMsSUFBSSxLQUFLSCxPQUFPeEIsTUFBTTtRQUMxRyxNQUFNdUMsYUFBYUYsS0FBS0csSUFBSSxDQUFDSjtRQUU3QiwrQkFBK0I7UUFDL0IsTUFBTUssbUJBQW1CakIsT0FBT3hCLE1BQU0sSUFBSSxJQUN4QyxDQUFFd0IsTUFBTSxDQUFDQSxPQUFPeEIsTUFBTSxHQUFHLEVBQUUsR0FBR3dCLE1BQU0sQ0FBQ0EsT0FBT3hCLE1BQU0sR0FBRyxFQUFFLElBQUl3QixNQUFNLENBQUNBLE9BQU94QixNQUFNLEdBQUcsRUFBRSxHQUFJLE1BQU0wQztRQUVoRyxNQUFNQyxrQkFBa0JiLE9BQU85QixNQUFNLEdBQUcsS0FBS2dDLFNBQVNoQyxNQUFNLEdBQUcsSUFDN0QsQ0FBRWlDLFlBQVlDLFdBQVUsSUFBS0EsY0FBZSxNQUFNUTtRQUVwRCxPQUFPO1lBQ0w1QixRQUFRbkMsYUFBYUksRUFBRTtZQUN2Qkg7WUFDQTRDLFFBQVFsQjtZQUNSNkI7WUFDQUk7WUFDQVo7WUFDQWM7WUFDQUU7WUFDQUMsYUFBYSxJQUFJdkcsT0FBT2dCLFdBQVc7WUFDbkNrRCxVQUFVO1FBQ1o7SUFDRixFQUFFLE9BQU9yRCxPQUFPO1FBQ2RSLFFBQVFRLEtBQUssQ0FBQyxtQ0FBcUQsT0FBbEJ5QixhQUFhSyxJQUFJLEVBQUMsTUFBSTlCO1FBQ3ZFLE9BQU87SUFDVDtBQUNGO0FBRUEsaURBQWlEO0FBQzFDLGVBQWUyRix1QkFBdUJDLEtBQWdCO0lBQzNELE1BQU1DLFVBQVUsSUFBSUM7SUFFcEIsNERBQTREO0lBQzVELE1BQU1DLFlBQVk7SUFDbEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLE1BQU05QyxNQUFNLEVBQUVrRCxLQUFLRCxVQUFXO1FBQ2hELE1BQU1FLFFBQVFMLE1BQU1mLEtBQUssQ0FBQ21CLEdBQUdBLElBQUlEO1FBRWpDLE1BQU1HLGdCQUFnQkQsTUFBTTFCLEdBQUcsQ0FBQyxPQUFPNEI7WUFDckMsTUFBTUMsVUFBVSxNQUFNL0IsdUJBQXVCOEI7WUFDN0MsSUFBSUMsU0FBUztnQkFDWFAsUUFBUVEsR0FBRyxDQUFDRixLQUFLdEUsRUFBRSxFQUFFdUU7WUFDdkI7UUFDRjtRQUVBLE1BQU0vRyxRQUFRaUgsR0FBRyxDQUFDSjtRQUVsQixvQ0FBb0M7UUFDcEMsSUFBSUYsSUFBSUQsWUFBWUgsTUFBTTlDLE1BQU0sRUFBRTtZQUNoQyxNQUFNLElBQUl6RCxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO1FBQ25EO0lBQ0Y7SUFFQSxPQUFPdUc7QUFDVDtBQUVBLDBDQUEwQztBQUNuQyxTQUFTVTtJQUNkLElBQUksS0FBNkIsRUFBRSxFQUFPO0lBRTFDLElBQUk7UUFDRixNQUFNMUQsT0FBT0QsT0FBT0MsSUFBSSxDQUFDckM7UUFDekJxQyxLQUFLWSxPQUFPLENBQUNuRCxDQUFBQTtZQUNYLElBQUlBLElBQUlrRyxVQUFVLENBQUMsYUFBYTtnQkFDOUJoRyxhQUFhTSxVQUFVLENBQUNSO1lBQzFCO1FBQ0Y7UUFDQWQsUUFBUUMsR0FBRyxDQUFDO0lBQ2QsRUFBRSxPQUFPTyxPQUFPO1FBQ2RSLFFBQVFRLEtBQUssQ0FBQyxpQ0FBaUNBO0lBQ2pEO0FBQ0Y7QUFFQSx1QkFBdUI7QUFDaEIsU0FBU3lHO0lBQ2QsSUFBSSxLQUE2QixFQUFFLEVBQVk7SUFFL0MsSUFBSTtRQUNGLE1BQU01RCxPQUFPRCxPQUFPQyxJQUFJLENBQUNyQztRQUN6QixNQUFNa0csY0FBYzdELEtBQUs4RCxNQUFNLENBQUNyRyxDQUFBQSxNQUFPQSxJQUFJa0csVUFBVSxDQUFDO1FBRXRELElBQUlJLFlBQVk7UUFDaEIsTUFBTUMsZUFBZUgsWUFBWW5DLEdBQUcsQ0FBQ2pFLENBQUFBO1lBQ25DLE1BQU1TLE9BQU9QLGFBQWFDLE9BQU8sQ0FBQ0g7WUFDbEMsTUFBTXdHLE9BQU8vRixPQUFPQSxLQUFLK0IsTUFBTSxHQUFHO1lBQ2xDOEQsYUFBYUU7WUFFYixPQUFPO2dCQUNMeEc7Z0JBQ0F3RztnQkFDQUMsZUFBZSxHQUE0QixPQUF6QixDQUFDRCxPQUFPLElBQUcsRUFBR0UsT0FBTyxDQUFDLElBQUc7WUFDN0M7UUFDRjtRQUVBLE9BQU87WUFDTEMsY0FBY1AsWUFBWTVELE1BQU07WUFDaEM4RDtZQUNBTSxvQkFBb0IsR0FBd0MsT0FBckMsQ0FBQ04sWUFBWSxPQUFPLElBQUcsRUFBR0ksT0FBTyxDQUFDLElBQUc7WUFDNURHLFNBQVNOO1FBQ1g7SUFDRixFQUFFLE9BQU83RyxPQUFPO1FBQ2RSLFFBQVFRLEtBQUssQ0FBQyw4QkFBOEJBO1FBQzVDLE9BQU87SUFDVDtBQUNGO0FBRUEsd0NBQXdDO0FBQ2QiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcbXRnLWluZGV4XFxzcmNcXGxpYlxcYXBpXFxtdGdqc29uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxyXG4gIE1UR0pTT05DYXJkLCBcclxuICBNVEdKU09OQ2FyZFByaWNlcywgXHJcbiAgTVRHSlNPTlByaWNlUG9pbnQsIFxyXG4gIE1UR0pTT05Db25maWcsIFxyXG4gIE1UR0pTT05DYWNoZSxcclxuICBQcmljZUhpc3RvcnksXHJcbiAgUHJvY2Vzc2VkQ2FyZFByaWNlLFxyXG4gIE1UR0NhcmQgXHJcbn0gZnJvbSAnQC9saWIvdHlwZXMnO1xyXG5cclxuLy8gTVRHSlNPTiBDb25maWd1cmF0aW9uXHJcbmNvbnN0IE1UR0pTT05fQ09ORklHOiBNVEdKU09OQ29uZmlnID0ge1xyXG4gIGJhc2VVcmw6ICdodHRwczovL210Z2pzb24uY29tL2FwaS92NScsXHJcbiAgY2FjaGVFeHBpcnk6IDI0ICogNjAgKiA2MCAqIDEwMDAsIC8vIDI0IGhvdXJzXHJcbiAgcHJlZmVycmVkUHJvdmlkZXI6ICd0Y2dwbGF5ZXInLFxyXG4gIGVuYWJsZUNhY2hpbmc6IHRydWUsXHJcbn07XHJcblxyXG4vLyBDYWNoZSBtYW5hZ2VtZW50XHJcbmNvbnN0IENBQ0hFX0tFWVMgPSB7XHJcbiAgQUxMX1BSSUNFUzogJ210Z2pzb24tYWxsLXByaWNlcycsXHJcbiAgQ0FSRF9NQVBQSU5HUzogJ210Z2pzb24tY2FyZC1tYXBwaW5ncycsXHJcbiAgUFJJQ0VfSElTVE9SWTogJ210Z2pzb24tcHJpY2UtaGlzdG9yeS0nLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuLy8gUmF0ZSBsaW1pdGluZzogTVRHSlNPTiBkb2Vzbid0IHNwZWNpZnkgbGltaXRzLCBidXQgd2UnbGwgYmUgY29uc2VydmF0aXZlXHJcbmNvbnN0IFJBVEVfTElNSVRfREVMQVkgPSAyMDA7IC8vIDIwMG1zIGJldHdlZW4gcmVxdWVzdHNcclxubGV0IGxhc3RSZXF1ZXN0VGltZSA9IDA7XHJcblxyXG5hc3luYyBmdW5jdGlvbiByYXRlTGltaXRlZEZldGNoKHVybDogc3RyaW5nKTogUHJvbWlzZTxSZXNwb25zZT4ge1xyXG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgY29uc3QgdGltZVNpbmNlTGFzdFJlcXVlc3QgPSBub3cgLSBsYXN0UmVxdWVzdFRpbWU7XHJcbiAgXHJcbiAgaWYgKHRpbWVTaW5jZUxhc3RSZXF1ZXN0IDwgUkFURV9MSU1JVF9ERUxBWSkge1xyXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIFJBVEVfTElNSVRfREVMQVkgLSB0aW1lU2luY2VMYXN0UmVxdWVzdCkpO1xyXG4gIH1cclxuICBcclxuICBsYXN0UmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgTVRHSlNPTiBkYXRhOiAke3VybH1gKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1UR0pTT04gQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ01UR0pTT04gQVBJIHJlcXVlc3QgZmFpbGVkOicsIHtcclxuICAgICAgdXJsLFxyXG4gICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0ZhaWxlZCB0byBmZXRjaCcpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yOiBVbmFibGUgdG8gY29ubmVjdCB0byBNVEdKU09OIEFQSS4gUGxlYXNlIGNoZWNrIHlvdXIgaW50ZXJuZXQgY29ubmVjdGlvbi4nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbi8vIENhY2hlIHV0aWxpdGllc1xyXG5mdW5jdGlvbiBnZXRDYWNoZWREYXRhPFQ+KGtleTogc3RyaW5nKTogVCB8IG51bGwge1xyXG4gIGlmICghTVRHSlNPTl9DT05GSUcuZW5hYmxlQ2FjaGluZyB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgY2FjaGVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcclxuICAgIGlmICghY2FjaGVkKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGNhY2hlZCk7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgXHJcbiAgICBpZiAocGFyc2VkLmV4cGlyZXNBdCAmJiBub3cgPiBwYXJzZWQuZXhwaXJlc0F0KSB7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJzZWQuZGF0YTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVhZGluZyBjYWNoZSBmb3Iga2V5ICR7a2V5fTpgLCBlcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldENhY2hlZERhdGE8VD4oa2V5OiBzdHJpbmcsIGRhdGE6IFQsIGN1c3RvbUV4cGlyeT86IG51bWJlcik6IHZvaWQge1xyXG4gIGlmICghTVRHSlNPTl9DT05GSUcuZW5hYmxlQ2FjaGluZyB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGV4cGlyeSA9IGN1c3RvbUV4cGlyeSB8fCBNVEdKU09OX0NPTkZJRy5jYWNoZUV4cGlyeTtcclxuICAgIGNvbnN0IGNhY2hlRW50cnkgPSB7XHJcbiAgICAgIGRhdGEsXHJcbiAgICAgIGV4cGlyZXNBdDogRGF0ZS5ub3coKSArIGV4cGlyeSxcclxuICAgICAgY2FjaGVkQXQ6IERhdGUubm93KCksXHJcbiAgICB9O1xyXG5cclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkoY2FjaGVFbnRyeSkpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzZXR0aW5nIGNhY2hlIGZvciBrZXkgJHtrZXl9OmAsIGVycm9yKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEltcG9ydCB0aGUgY2FyZCBtYXBwaW5nIHNlcnZpY2VcclxuaW1wb3J0IHsgY2FyZE1hcHBpbmdTZXJ2aWNlIH0gZnJvbSAnQC9saWIvc2VydmljZXMvY2FyZE1hcHBpbmdTZXJ2aWNlJztcclxuXHJcbi8vIE1hcCBTY3J5ZmFsbCBjYXJkIHRvIE1UR0pTT04gVVVJRFxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FyZE1hcHBpbmcoc2NyeWZhbGxDYXJkOiBNVEdDYXJkKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIFVzZSB0aGUgY2FyZCBtYXBwaW5nIHNlcnZpY2VcclxuICAgIGNvbnN0IHV1aWQgPSBhd2FpdCBjYXJkTWFwcGluZ1NlcnZpY2UuZ2V0TWFwcGluZyhzY3J5ZmFsbENhcmQpO1xyXG4gICAgXHJcbiAgICBpZiAodXVpZCkge1xyXG4gICAgICAvLyBDYWNoZSB0aGUgc3VjY2Vzc2Z1bCBtYXBwaW5nXHJcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7Q0FDSEVfS0VZUy5DQVJEX01BUFBJTkdTfSR7c2NyeWZhbGxDYXJkLmlkfWA7XHJcbiAgICAgIHNldENhY2hlZERhdGEoY2FjaGVLZXksIHV1aWQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gdXVpZDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyBjYXJkIG1hcHBpbmcgZm9yICR7c2NyeWZhbGxDYXJkLm5hbWV9OmAsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRmV0Y2ggcHJpY2UgaGlzdG9yeSBmb3IgYSBzcGVjaWZpYyBVVUlEXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFByaWNlSGlzdG9yeUJ5VVVJRCh1dWlkOiBzdHJpbmcpOiBQcm9taXNlPE1UR0pTT05DYXJkUHJpY2VzIHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxyXG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtDQUNIRV9LRVlTLlBSSUNFX0hJU1RPUll9JHt1dWlkfWA7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBnZXRDYWNoZWREYXRhPE1UR0pTT05DYXJkUHJpY2VzPihjYWNoZUtleSk7XHJcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xyXG5cclxuICAgIC8vIFRyeSB0byBnZXQgZnJvbSBBbGxQcmljZXMgZGF0YVxyXG4gICAgY29uc3QgcHJpY2VEYXRhID0gYXdhaXQgZ2V0QWxsUHJpY2VzRGF0YSgpO1xyXG4gICAgaWYgKHByaWNlRGF0YSAmJiBwcmljZURhdGFbdXVpZF0pIHtcclxuICAgICAgY29uc3QgY2FyZFByaWNlcyA9IHByaWNlRGF0YVt1dWlkXTtcclxuICAgICAgXHJcbiAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRcclxuICAgICAgc2V0Q2FjaGVkRGF0YShjYWNoZUtleSwgY2FyZFByaWNlcyk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gY2FyZFByaWNlcztcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhgTm8gcHJpY2UgaGlzdG9yeSBmb3VuZCBmb3IgVVVJRCAke3V1aWR9YCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJpY2UgaGlzdG9yeTonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8vIEZldGNoIGFuZCBjYWNoZSBBbGxQcmljZXMuanNvbiBkYXRhXHJcbmxldCBhbGxQcmljZXNDYWNoZTogUmVjb3JkPHN0cmluZywgTVRHSlNPTkNhcmRQcmljZXM+IHwgbnVsbCA9IG51bGw7XHJcbmxldCBhbGxQcmljZXNMb2FkaW5nUHJvbWlzZTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBNVEdKU09OQ2FyZFByaWNlcz4gfCBudWxsPiB8IG51bGwgPSBudWxsO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0QWxsUHJpY2VzRGF0YSgpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIE1UR0pTT05DYXJkUHJpY2VzPiB8IG51bGw+IHtcclxuICAvLyBSZXR1cm4gY2FjaGVkIGRhdGEgaWYgYXZhaWxhYmxlXHJcbiAgaWYgKGFsbFByaWNlc0NhY2hlKSB7XHJcbiAgICByZXR1cm4gYWxsUHJpY2VzQ2FjaGU7XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gZXhpc3RpbmcgbG9hZGluZyBwcm9taXNlIGlmIGluIHByb2dyZXNzXHJcbiAgaWYgKGFsbFByaWNlc0xvYWRpbmdQcm9taXNlKSB7XHJcbiAgICByZXR1cm4gYWxsUHJpY2VzTG9hZGluZ1Byb21pc2U7XHJcbiAgfVxyXG5cclxuICAvLyBTdGFydCBsb2FkaW5nIEFsbFByaWNlcyBkYXRhXHJcbiAgYWxsUHJpY2VzTG9hZGluZ1Byb21pc2UgPSBsb2FkQWxsUHJpY2VzRGF0YSgpO1xyXG4gIHJldHVybiBhbGxQcmljZXNMb2FkaW5nUHJvbWlzZTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gbG9hZEFsbFByaWNlc0RhdGEoKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBNVEdKU09OQ2FyZFByaWNlcz4gfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIE1UR0pTT04gQWxsUHJpY2VzIGRhdGEuLi4nKTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGNhY2hlZCBBbGxQcmljZXMgZGF0YVxyXG4gICAgY29uc3QgY2FjaGVkQWxsUHJpY2VzID0gZ2V0Q2FjaGVkRGF0YTx7XHJcbiAgICAgIGRhdGE6IFJlY29yZDxzdHJpbmcsIE1UR0pTT05DYXJkUHJpY2VzPjtcclxuICAgICAgdGltZXN0YW1wOiBudW1iZXI7XHJcbiAgICAgIHZlcnNpb246IHN0cmluZztcclxuICAgIH0+KCdtdGdqc29uLWFsbC1wcmljZXMtZGF0YScpO1xyXG5cclxuICAgIC8vIFVzZSBjYWNoZWQgZGF0YSBpZiBpdCdzIGxlc3MgdGhhbiAyNCBob3VycyBvbGRcclxuICAgIGlmIChjYWNoZWRBbGxQcmljZXMgJiYgKERhdGUubm93KCkgLSBjYWNoZWRBbGxQcmljZXMudGltZXN0YW1wKSA8IDI0ICogNjAgKiA2MCAqIDEwMDApIHtcclxuICAgICAgY29uc29sZS5sb2coJ1VzaW5nIGNhY2hlZCBBbGxQcmljZXMgZGF0YScpO1xyXG4gICAgICBhbGxQcmljZXNDYWNoZSA9IGNhY2hlZEFsbFByaWNlcy5kYXRhO1xyXG4gICAgICByZXR1cm4gYWxsUHJpY2VzQ2FjaGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmV0Y2ggZnJlc2ggQWxsUHJpY2VzIGRhdGFcclxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBmcmVzaCBBbGxQcmljZXMgZGF0YSBmcm9tIE1UR0pTT04uLi4nKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmF0ZUxpbWl0ZWRGZXRjaCgnaHR0cHM6Ly9tdGdqc29uLmNvbS9hcGkvdjUvQWxsUHJpY2VzLmpzb24nKTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBBbGxQcmljZXM6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFyc2UgdGhlIEpTT04gcmVzcG9uc2VcclxuICAgIGNvbnN0IGFsbFByaWNlc1Jlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgXHJcbiAgICBpZiAoIWFsbFByaWNlc1Jlc3BvbnNlLmRhdGEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEFsbFByaWNlcyByZXNwb25zZSBmb3JtYXQnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWNoZSB0aGUgZGF0YVxyXG4gICAgY29uc3QgY2FjaGVEYXRhID0ge1xyXG4gICAgICBkYXRhOiBhbGxQcmljZXNSZXNwb25zZS5kYXRhLFxyXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgIHZlcnNpb246IGFsbFByaWNlc1Jlc3BvbnNlLm1ldGE/LnZlcnNpb24gfHwgJ3Vua25vd24nLFxyXG4gICAgfTtcclxuXHJcbiAgICBzZXRDYWNoZWREYXRhKCdtdGdqc29uLWFsbC1wcmljZXMtZGF0YScsIGNhY2hlRGF0YSk7XHJcbiAgICBhbGxQcmljZXNDYWNoZSA9IGFsbFByaWNlc1Jlc3BvbnNlLmRhdGE7XHJcblxyXG4gICAgY29uc29sZS5sb2coYExvYWRlZCBBbGxQcmljZXMgZGF0YSBmb3IgJHtPYmplY3Qua2V5cyhhbGxQcmljZXNDYWNoZSB8fCB7fSkubGVuZ3RofSBjYXJkc2ApO1xyXG4gICAgcmV0dXJuIGFsbFByaWNlc0NhY2hlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBBbGxQcmljZXMgZGF0YTonLCBlcnJvcik7XHJcbiAgICBcclxuICAgIC8vIFRyeSB0byB1c2Ugc3RhbGUgY2FjaGVkIGRhdGEgYXMgZmFsbGJhY2tcclxuICAgIGNvbnN0IHN0YWxlQ2FjaGUgPSBnZXRDYWNoZWREYXRhPHtcclxuICAgICAgZGF0YTogUmVjb3JkPHN0cmluZywgTVRHSlNPTkNhcmRQcmljZXM+O1xyXG4gICAgICB0aW1lc3RhbXA6IG51bWJlcjtcclxuICAgIH0+KCdtdGdqc29uLWFsbC1wcmljZXMtZGF0YScpO1xyXG5cclxuICAgIGlmIChzdGFsZUNhY2hlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignVXNpbmcgc3RhbGUgQWxsUHJpY2VzIGNhY2hlIGR1ZSB0byBmZXRjaCBmYWlsdXJlJyk7XHJcbiAgICAgIGFsbFByaWNlc0NhY2hlID0gc3RhbGVDYWNoZS5kYXRhO1xyXG4gICAgICByZXR1cm4gYWxsUHJpY2VzQ2FjaGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIGFsbFByaWNlc0xvYWRpbmdQcm9taXNlID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8vIENvbnZlcnQgTVRHSlNPTiBwcmljZSBkYXRhIHRvIG91ciBpbnRlcm5hbCBmb3JtYXRcclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRNVEdKU09OUHJpY2VzKFxyXG4gIHV1aWQ6IHN0cmluZyxcclxuICBtdGdqc29uUHJpY2VzOiBNVEdKU09OQ2FyZFByaWNlcyxcclxuICBjYXJkTmFtZTogc3RyaW5nXHJcbik6IFByb2Nlc3NlZENhcmRQcmljZVtdIHtcclxuICBjb25zdCBwcm9jZXNzZWRQcmljZXM6IFByb2Nlc3NlZENhcmRQcmljZVtdID0gW107XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIC8vIEdldCB0aGUgcHJlZmVycmVkIHByb3ZpZGVyJ3MgZGF0YVxyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBNVEdKU09OX0NPTkZJRy5wcmVmZXJyZWRQcm92aWRlcjtcclxuICAgIGNvbnN0IHBhcGVyUHJpY2VzID0gbXRnanNvblByaWNlcy5wYXBlcj8uW3Byb3ZpZGVyXTtcclxuICAgIFxyXG4gICAgaWYgKHBhcGVyUHJpY2VzPy5ub3JtYWwpIHtcclxuICAgICAgcGFwZXJQcmljZXMubm9ybWFsLmZvckVhY2gocHJpY2VQb2ludCA9PiB7XHJcbiAgICAgICAgcHJvY2Vzc2VkUHJpY2VzLnB1c2goe1xyXG4gICAgICAgICAgY2FyZElkOiB1dWlkLFxyXG4gICAgICAgICAgZGF0ZTogcHJpY2VQb2ludC5kYXRlLFxyXG4gICAgICAgICAgcHJpY2U6IHByaWNlUG9pbnQucHJpY2UsXHJcbiAgICAgICAgICBwcmljZVR5cGU6ICd1c2QnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHBhcGVyUHJpY2VzPy5mb2lsKSB7XHJcbiAgICAgIHBhcGVyUHJpY2VzLmZvaWwuZm9yRWFjaChwcmljZVBvaW50ID0+IHtcclxuICAgICAgICBwcm9jZXNzZWRQcmljZXMucHVzaCh7XHJcbiAgICAgICAgICBjYXJkSWQ6IHV1aWQsXHJcbiAgICAgICAgICBkYXRlOiBwcmljZVBvaW50LmRhdGUsXHJcbiAgICAgICAgICBwcmljZTogcHJpY2VQb2ludC5wcmljZSxcclxuICAgICAgICAgIHByaWNlVHlwZTogJ3VzZEZvaWwnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgY29udmVydGluZyBNVEdKU09OIHByaWNlcyBmb3IgJHtjYXJkTmFtZX06YCwgZXJyb3IpO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gcHJvY2Vzc2VkUHJpY2VzLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGEuZGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5kYXRlKS5nZXRUaW1lKCkpO1xyXG59XHJcblxyXG4vLyBHZXQgcHJpY2UgaGlzdG9yeSBmb3IgYSBTY3J5ZmFsbCBjYXJkXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcmljZUhpc3RvcnlGb3JDYXJkKHNjcnlmYWxsQ2FyZDogTVRHQ2FyZCk6IFByb21pc2U8UHJpY2VIaXN0b3J5IHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBGaXJzdCwgZ2V0IHRoZSBNVEdKU09OIFVVSUQgbWFwcGluZ1xyXG4gICAgY29uc3QgdXVpZCA9IGF3YWl0IGdldENhcmRNYXBwaW5nKHNjcnlmYWxsQ2FyZCk7XHJcbiAgICBpZiAoIXV1aWQpIHtcclxuICAgICAgY29uc29sZS5sb2coYE5vIE1UR0pTT04gbWFwcGluZyBmb3VuZCBmb3IgJHtzY3J5ZmFsbENhcmQubmFtZX1gKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmV0Y2ggdGhlIHByaWNlIGhpc3RvcnlcclxuICAgIGNvbnN0IG10Z2pzb25QcmljZXMgPSBhd2FpdCBmZXRjaFByaWNlSGlzdG9yeUJ5VVVJRCh1dWlkKTtcclxuICAgIGlmICghbXRnanNvblByaWNlcykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb252ZXJ0IHRvIG91ciBpbnRlcm5hbCBmb3JtYXRcclxuICAgIGNvbnN0IHByb2Nlc3NlZFByaWNlcyA9IGNvbnZlcnRNVEdKU09OUHJpY2VzKHV1aWQsIG10Z2pzb25QcmljZXMsIHNjcnlmYWxsQ2FyZC5uYW1lKTtcclxuICAgIFxyXG4gICAgaWYgKHByb2Nlc3NlZFByaWNlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRyZW5kIGFuZCB2b2xhdGlsaXR5XHJcbiAgICBjb25zdCBwcmljZXMgPSBwcm9jZXNzZWRQcmljZXMubWFwKHAgPT4gcC5wcmljZSk7XHJcbiAgICBjb25zdCBhdmVyYWdlUHJpY2UgPSBwcmljZXMucmVkdWNlKChzdW0sIHByaWNlKSA9PiBzdW0gKyBwcmljZSwgMCkgLyBwcmljZXMubGVuZ3RoO1xyXG4gICAgXHJcbiAgICAvLyBTaW1wbGUgdHJlbmQgY2FsY3VsYXRpb24gKGxhc3QgNyBkYXlzIHZzIHByZXZpb3VzIDcgZGF5cylcclxuICAgIGNvbnN0IHJlY2VudCA9IHByaWNlcy5zbGljZSgtNyk7XHJcbiAgICBjb25zdCBwcmV2aW91cyA9IHByaWNlcy5zbGljZSgtMTQsIC03KTtcclxuICAgIGNvbnN0IHJlY2VudEF2ZyA9IHJlY2VudC5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcCwgMCkgLyByZWNlbnQubGVuZ3RoO1xyXG4gICAgY29uc3QgcHJldmlvdXNBdmcgPSBwcmV2aW91cy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcCwgMCkgLyBwcmV2aW91cy5sZW5ndGg7XHJcbiAgICBcclxuICAgIGNvbnN0IHRyZW5kOiAndXAnIHwgJ2Rvd24nIHwgJ3N0YWJsZScgPSBcclxuICAgICAgcmVjZW50QXZnID4gcHJldmlvdXNBdmcgKiAxLjA1ID8gJ3VwJyA6XHJcbiAgICAgIHJlY2VudEF2ZyA8IHByZXZpb3VzQXZnICogMC45NSA/ICdkb3duJyA6ICdzdGFibGUnO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB2b2xhdGlsaXR5IChzdGFuZGFyZCBkZXZpYXRpb24pXHJcbiAgICBjb25zdCB2YXJpYW5jZSA9IHByaWNlcy5yZWR1Y2UoKHN1bSwgcHJpY2UpID0+IHN1bSArIE1hdGgucG93KHByaWNlIC0gYXZlcmFnZVByaWNlLCAyKSwgMCkgLyBwcmljZXMubGVuZ3RoO1xyXG4gICAgY29uc3Qgdm9sYXRpbGl0eSA9IE1hdGguc3FydCh2YXJpYW5jZSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHBlcmNlbnRhZ2UgY2hhbmdlc1xyXG4gICAgY29uc3QgcGVyY2VudENoYW5nZTI0aCA9IHByaWNlcy5sZW5ndGggPj0gMiA/IFxyXG4gICAgICAoKHByaWNlc1twcmljZXMubGVuZ3RoIC0gMV0gLSBwcmljZXNbcHJpY2VzLmxlbmd0aCAtIDJdKSAvIHByaWNlc1twcmljZXMubGVuZ3RoIC0gMl0pICogMTAwIDogdW5kZWZpbmVkO1xyXG4gICAgXHJcbiAgICBjb25zdCBwZXJjZW50Q2hhbmdlN2QgPSByZWNlbnQubGVuZ3RoID4gMCAmJiBwcmV2aW91cy5sZW5ndGggPiAwID8gXHJcbiAgICAgICgocmVjZW50QXZnIC0gcHJldmlvdXNBdmcpIC8gcHJldmlvdXNBdmcpICogMTAwIDogdW5kZWZpbmVkO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNhcmRJZDogc2NyeWZhbGxDYXJkLmlkLFxyXG4gICAgICB1dWlkLFxyXG4gICAgICBwcmljZXM6IHByb2Nlc3NlZFByaWNlcyxcclxuICAgICAgdHJlbmQsXHJcbiAgICAgIHZvbGF0aWxpdHksXHJcbiAgICAgIGF2ZXJhZ2VQcmljZSxcclxuICAgICAgcGVyY2VudENoYW5nZTI0aCxcclxuICAgICAgcGVyY2VudENoYW5nZTdkLFxyXG4gICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBwcm92aWRlcjogJ210Z2pzb24nLFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyBwcmljZSBoaXN0b3J5IGZvciAke3NjcnlmYWxsQ2FyZC5uYW1lfTpgLCBlcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8vIEJhdGNoIGZldGNoIHByaWNlIGhpc3RvcmllcyBmb3IgbXVsdGlwbGUgY2FyZHNcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJhdGNoR2V0UHJpY2VIaXN0b3JpZXMoY2FyZHM6IE1UR0NhcmRbXSk6IFByb21pc2U8TWFwPHN0cmluZywgUHJpY2VIaXN0b3J5Pj4ge1xyXG4gIGNvbnN0IHJlc3VsdHMgPSBuZXcgTWFwPHN0cmluZywgUHJpY2VIaXN0b3J5PigpO1xyXG4gIFxyXG4gIC8vIFByb2Nlc3MgY2FyZHMgaW4gYmF0Y2hlcyB0byBhdm9pZCBvdmVyd2hlbG1pbmcgdGhlIHN5c3RlbVxyXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IDEwO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2FyZHMubGVuZ3RoOyBpICs9IGJhdGNoU2l6ZSkge1xyXG4gICAgY29uc3QgYmF0Y2ggPSBjYXJkcy5zbGljZShpLCBpICsgYmF0Y2hTaXplKTtcclxuICAgIFxyXG4gICAgY29uc3QgYmF0Y2hQcm9taXNlcyA9IGJhdGNoLm1hcChhc3luYyAoY2FyZCkgPT4ge1xyXG4gICAgICBjb25zdCBoaXN0b3J5ID0gYXdhaXQgZ2V0UHJpY2VIaXN0b3J5Rm9yQ2FyZChjYXJkKTtcclxuICAgICAgaWYgKGhpc3RvcnkpIHtcclxuICAgICAgICByZXN1bHRzLnNldChjYXJkLmlkLCBoaXN0b3J5KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGF3YWl0IFByb21pc2UuYWxsKGJhdGNoUHJvbWlzZXMpO1xyXG4gICAgXHJcbiAgICAvLyBBZGQgYSBzbWFsbCBkZWxheSBiZXR3ZWVuIGJhdGNoZXNcclxuICAgIGlmIChpICsgYmF0Y2hTaXplIDwgY2FyZHMubGVuZ3RoKSB7XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiByZXN1bHRzO1xyXG59XHJcblxyXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNsZWFyIE1UR0pTT04gY2FjaGVcclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyTVRHSlNPTkNhY2hlKCk6IHZvaWQge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKTtcclxuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ210Z2pzb24tJykpIHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKCdNVEdKU09OIGNhY2hlIGNsZWFyZWQnKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2xlYXJpbmcgTVRHSlNPTiBjYWNoZTonLCBlcnJvcik7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBHZXQgY2FjaGUgc3RhdGlzdGljc1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TVRHSlNPTkNhY2hlU3RhdHMoKSB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcclxuICBcclxuICB0cnkge1xyXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGxvY2FsU3RvcmFnZSk7XHJcbiAgICBjb25zdCBtdGdqc29uS2V5cyA9IGtleXMuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aCgnbXRnanNvbi0nKSk7XHJcbiAgICBcclxuICAgIGxldCB0b3RhbFNpemUgPSAwO1xyXG4gICAgY29uc3QgY2FjaGVFbnRyaWVzID0gbXRnanNvbktleXMubWFwKGtleSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xyXG4gICAgICBjb25zdCBzaXplID0gZGF0YSA/IGRhdGEubGVuZ3RoIDogMDtcclxuICAgICAgdG90YWxTaXplICs9IHNpemU7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGtleSxcclxuICAgICAgICBzaXplLFxyXG4gICAgICAgIHNpemVGb3JtYXR0ZWQ6IGAkeyhzaXplIC8gMTAyNCkudG9GaXhlZCgyKX0gS0JgLFxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvdGFsRW50cmllczogbXRnanNvbktleXMubGVuZ3RoLFxyXG4gICAgICB0b3RhbFNpemUsXHJcbiAgICAgIHRvdGFsU2l6ZUZvcm1hdHRlZDogYCR7KHRvdGFsU2l6ZSAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDIpfSBNQmAsXHJcbiAgICAgIGVudHJpZXM6IGNhY2hlRW50cmllcyxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY2FjaGUgc3RhdHM6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgY29uZmlndXJhdGlvbiBmb3IgZXh0ZXJuYWwgdXNlXHJcbmV4cG9ydCB7IE1UR0pTT05fQ09ORklHIH07XHJcbiJdLCJuYW1lcyI6WyJNVEdKU09OX0NPTkZJRyIsImJhc2VVcmwiLCJjYWNoZUV4cGlyeSIsInByZWZlcnJlZFByb3ZpZGVyIiwiZW5hYmxlQ2FjaGluZyIsIkNBQ0hFX0tFWVMiLCJBTExfUFJJQ0VTIiwiQ0FSRF9NQVBQSU5HUyIsIlBSSUNFX0hJU1RPUlkiLCJSQVRFX0xJTUlUX0RFTEFZIiwibGFzdFJlcXVlc3RUaW1lIiwicmF0ZUxpbWl0ZWRGZXRjaCIsInVybCIsIm5vdyIsIkRhdGUiLCJ0aW1lU2luY2VMYXN0UmVxdWVzdCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJlcnJvciIsIm1lc3NhZ2UiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsImluY2x1ZGVzIiwiZ2V0Q2FjaGVkRGF0YSIsImtleSIsImNhY2hlZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJleHBpcmVzQXQiLCJyZW1vdmVJdGVtIiwiZGF0YSIsInNldENhY2hlZERhdGEiLCJjdXN0b21FeHBpcnkiLCJleHBpcnkiLCJjYWNoZUVudHJ5IiwiY2FjaGVkQXQiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiY2FyZE1hcHBpbmdTZXJ2aWNlIiwiZ2V0Q2FyZE1hcHBpbmciLCJzY3J5ZmFsbENhcmQiLCJ1dWlkIiwiZ2V0TWFwcGluZyIsImNhY2hlS2V5IiwiaWQiLCJuYW1lIiwiZmV0Y2hQcmljZUhpc3RvcnlCeVVVSUQiLCJwcmljZURhdGEiLCJnZXRBbGxQcmljZXNEYXRhIiwiY2FyZFByaWNlcyIsImFsbFByaWNlc0NhY2hlIiwiYWxsUHJpY2VzTG9hZGluZ1Byb21pc2UiLCJsb2FkQWxsUHJpY2VzRGF0YSIsImFsbFByaWNlc1Jlc3BvbnNlIiwiY2FjaGVkQWxsUHJpY2VzIiwianNvbiIsImNhY2hlRGF0YSIsInZlcnNpb24iLCJtZXRhIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInN0YWxlQ2FjaGUiLCJ3YXJuIiwiY29udmVydE1UR0pTT05QcmljZXMiLCJtdGdqc29uUHJpY2VzIiwiY2FyZE5hbWUiLCJwcm9jZXNzZWRQcmljZXMiLCJwcm92aWRlciIsInBhcGVyUHJpY2VzIiwicGFwZXIiLCJub3JtYWwiLCJmb3JFYWNoIiwicHJpY2VQb2ludCIsInB1c2giLCJjYXJkSWQiLCJkYXRlIiwicHJpY2UiLCJwcmljZVR5cGUiLCJmb2lsIiwic29ydCIsImEiLCJiIiwiZ2V0VGltZSIsImdldFByaWNlSGlzdG9yeUZvckNhcmQiLCJwcmljZXMiLCJtYXAiLCJwIiwiYXZlcmFnZVByaWNlIiwicmVkdWNlIiwic3VtIiwicmVjZW50Iiwic2xpY2UiLCJwcmV2aW91cyIsInJlY2VudEF2ZyIsInByZXZpb3VzQXZnIiwidHJlbmQiLCJ2YXJpYW5jZSIsIk1hdGgiLCJwb3ciLCJ2b2xhdGlsaXR5Iiwic3FydCIsInBlcmNlbnRDaGFuZ2UyNGgiLCJ1bmRlZmluZWQiLCJwZXJjZW50Q2hhbmdlN2QiLCJsYXN0VXBkYXRlZCIsImJhdGNoR2V0UHJpY2VIaXN0b3JpZXMiLCJjYXJkcyIsInJlc3VsdHMiLCJNYXAiLCJiYXRjaFNpemUiLCJpIiwiYmF0Y2giLCJiYXRjaFByb21pc2VzIiwiY2FyZCIsImhpc3RvcnkiLCJzZXQiLCJhbGwiLCJjbGVhck1UR0pTT05DYWNoZSIsInN0YXJ0c1dpdGgiLCJnZXRNVEdKU09OQ2FjaGVTdGF0cyIsIm10Z2pzb25LZXlzIiwiZmlsdGVyIiwidG90YWxTaXplIiwiY2FjaGVFbnRyaWVzIiwic2l6ZSIsInNpemVGb3JtYXR0ZWQiLCJ0b0ZpeGVkIiwidG90YWxFbnRyaWVzIiwidG90YWxTaXplRm9ybWF0dGVkIiwiZW50cmllcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api/mtgjson.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/services/cardMappingService.ts":
/*!************************************************!*\
  !*** ./src/lib/services/cardMappingService.ts ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cardMappingService: () => (/* binding */ cardMappingService)\n/* harmony export */ });\n/* harmony import */ var _lib_utils_mtgjsonCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/utils/mtgjsonCache */ \"(app-pages-browser)/./src/lib/utils/mtgjsonCache.ts\");\n\nclass CardMappingService {\n    /**\r\n   * Initialize the mapping service by loading AllPrintings data\r\n   */ async initialize() {\n        if (this.loadingPromise) {\n            return this.loadingPromise;\n        }\n        this.loadingPromise = this.loadAllPrintingsData();\n        return this.loadingPromise;\n    }\n    /**\r\n   * Load and cache AllPrintings.json data\r\n   */ async loadAllPrintingsData() {\n        try {\n            console.log('Loading MTGJSON AllPrintings data...');\n            // Try to load from cache first\n            const cached = await this.getCachedAllPrintings();\n            if (cached && this.isDataFresh(cached.meta.date)) {\n                this.allPrintingsData = cached;\n                console.log('Loaded AllPrintings from cache');\n                await this.loadMappingCache();\n                return;\n            }\n            // Fetch fresh data from MTGJSON\n            console.log('Fetching fresh AllPrintings data from MTGJSON...');\n            const response = await fetch(this.MTGJSON_ALL_PRINTINGS_URL);\n            if (!response.ok) {\n                throw new Error(\"Failed to fetch AllPrintings: \".concat(response.status, \" \").concat(response.statusText));\n            }\n            // Parse the response\n            const data = await response.json();\n            if (!data.data || !data.meta) {\n                throw new Error('Invalid AllPrintings response format');\n            }\n            this.allPrintingsData = data;\n            // Store using the optimized storage system\n            const { allPrintingsStorage } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_utils_allPrintingsStorage_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/utils/allPrintingsStorage */ \"(app-pages-browser)/./src/lib/utils/allPrintingsStorage.ts\"));\n            await allPrintingsStorage.storeAllPrintings(data);\n            await this.loadMappingCache();\n            console.log(\"Loaded \".concat(Object.keys(data.data).length, \" sets from MTGJSON\"));\n        } catch (error) {\n            console.error('Failed to load AllPrintings data:', error);\n            // Try to use optimized storage as fallback\n            try {\n                const { allPrintingsStorage } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_utils_allPrintingsStorage_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/utils/allPrintingsStorage */ \"(app-pages-browser)/./src/lib/utils/allPrintingsStorage.ts\"));\n                const isAvailable = await allPrintingsStorage.isDataAvailable();\n                if (isAvailable) {\n                    console.log('Using stored AllPrintings data as fallback');\n                    // We'll work with the stored data without loading everything into memory\n                    await this.loadMappingCache();\n                    return;\n                }\n            } catch (storageError) {\n                console.error('Failed to access stored AllPrintings data:', storageError);\n            }\n            throw new Error('Failed to load AllPrintings data and no cache available');\n        }\n    }\n    /**\r\n   * Get the MTGJSON UUID for a Scryfall card\r\n   */ async getMapping(scryfallCard) {\n        await this.initialize();\n        // Check cache first\n        const cached = this.mappingCache.get(scryfallCard.id);\n        if (cached) {\n            return cached.mtgjsonUuid;\n        }\n        // Try to find mapping\n        const mapping = await this.findCardMapping(scryfallCard);\n        if (mapping) {\n            // Cache the mapping\n            this.mappingCache.set(scryfallCard.id, mapping);\n            await this.saveMappingToCache(mapping);\n            return mapping.mtgjsonUuid;\n        }\n        return null;\n    }\n    /**\r\n   * Find mapping for a Scryfall card using multiple strategies\r\n   */ async findCardMapping(scryfallCard) {\n        // First try with in-memory AllPrintings data if available\n        if (this.allPrintingsData) {\n            const strategies = [\n                ()=>this.findByDirectScryfallId(scryfallCard),\n                ()=>this.findByNameAndSet(scryfallCard),\n                ()=>this.findByCollectorNumber(scryfallCard),\n                ()=>this.findByFuzzyName(scryfallCard)\n            ];\n            for (const strategy of strategies){\n                const result = strategy();\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        // Fallback to optimized storage search\n        try {\n            const { allPrintingsStorage } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_utils_allPrintingsStorage_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/utils/allPrintingsStorage */ \"(app-pages-browser)/./src/lib/utils/allPrintingsStorage.ts\"));\n            // Strategy 1: Direct Scryfall ID search\n            if (scryfallCard.scryfallId) {\n                const card = await allPrintingsStorage.findCardByScryfallId(scryfallCard.scryfallId);\n                if (card) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: 1.0,\n                        matchMethod: 'direct',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n            }\n            // Strategy 2: Search by name and try to match with set\n            const searchResults = await allPrintingsStorage.searchCards(scryfallCard.name, 20);\n            for (const card of searchResults){\n                // Exact name and set match\n                if (this.normalizeCardName(card.name) === this.normalizeCardName(scryfallCard.name) && card.setCode.toLowerCase() === scryfallCard.setCode.toLowerCase()) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: 0.95,\n                        matchMethod: 'name_set',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n                // Collector number match within same set\n                if (card.setCode.toLowerCase() === scryfallCard.setCode.toLowerCase() && card.number.toLowerCase() === (scryfallCard.number || '').toLowerCase()) {\n                    const nameSimilarity = this.calculateNameSimilarity(scryfallCard.name, card.name);\n                    if (nameSimilarity > 0.8) {\n                        return {\n                            scryfallId: scryfallCard.id,\n                            mtgjsonUuid: card.uuid,\n                            confidence: 0.9,\n                            matchMethod: 'collector_number',\n                            lastUpdated: new Date().toISOString()\n                        };\n                    }\n                }\n                // Fuzzy name match\n                const similarity = this.calculateNameSimilarity(scryfallCard.name, card.name);\n                if (similarity > 0.9) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: similarity * 0.8,\n                        matchMethod: 'name_fuzzy',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n            }\n        } catch (error) {\n            console.error('Error searching optimized storage:', error);\n        }\n        console.warn(\"No mapping found for card: \".concat(scryfallCard.name, \" (\").concat(scryfallCard.setCode, \")\"));\n        return null;\n    }\n    /**\r\n   * Strategy 1: Direct Scryfall ID match (most reliable)\r\n   */ findByDirectScryfallId(scryfallCard) {\n        if (!scryfallCard.scryfallId) return null;\n        for (const set of Object.values(this.allPrintingsData.data)){\n            for (const card of set.cards){\n                var _card_identifiers;\n                if (((_card_identifiers = card.identifiers) === null || _card_identifiers === void 0 ? void 0 : _card_identifiers.scryfallId) === scryfallCard.scryfallId) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: 1.0,\n                        matchMethod: 'direct',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    /**\r\n   * Strategy 2: Match by exact name and set code\r\n   */ findByNameAndSet(scryfallCard) {\n        const normalizedName = this.normalizeCardName(scryfallCard.name);\n        const setCode = scryfallCard.setCode.toLowerCase();\n        for (const set of Object.values(this.allPrintingsData.data)){\n            if (set.code.toLowerCase() !== setCode) continue;\n            for (const card of set.cards){\n                const cardNormalizedName = this.normalizeCardName(card.name);\n                if (cardNormalizedName === normalizedName) {\n                    return {\n                        scryfallId: scryfallCard.id,\n                        mtgjsonUuid: card.uuid,\n                        confidence: 0.95,\n                        matchMethod: 'name_set',\n                        lastUpdated: new Date().toISOString()\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    /**\r\n   * Strategy 3: Match by collector number and set\r\n   */ findByCollectorNumber(scryfallCard) {\n        if (!scryfallCard.number) return null;\n        const setCode = scryfallCard.setCode.toLowerCase();\n        const collectorNumber = scryfallCard.number.toLowerCase();\n        for (const set of Object.values(this.allPrintingsData.data)){\n            if (set.code.toLowerCase() !== setCode) continue;\n            for (const card of set.cards){\n                if (card.number.toLowerCase() === collectorNumber) {\n                    // Also check if names are similar to avoid false positives\n                    const nameSimilarity = this.calculateNameSimilarity(scryfallCard.name, card.name);\n                    if (nameSimilarity > 0.8) {\n                        return {\n                            scryfallId: scryfallCard.id,\n                            mtgjsonUuid: card.uuid,\n                            confidence: 0.9,\n                            matchMethod: 'collector_number',\n                            lastUpdated: new Date().toISOString()\n                        };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    /**\r\n   * Strategy 4: Fuzzy name matching (least reliable)\r\n   */ findByFuzzyName(scryfallCard) {\n        const normalizedName = this.normalizeCardName(scryfallCard.name);\n        let bestMatch = null;\n        for (const set of Object.values(this.allPrintingsData.data)){\n            for (const card of set.cards){\n                const cardNormalizedName = this.normalizeCardName(card.name);\n                const similarity = this.calculateNameSimilarity(normalizedName, cardNormalizedName);\n                if (similarity > 0.9 && (!bestMatch || similarity > bestMatch.similarity)) {\n                    bestMatch = {\n                        card,\n                        similarity\n                    };\n                }\n            }\n        }\n        if (bestMatch && bestMatch.similarity > 0.9) {\n            return {\n                scryfallId: scryfallCard.id,\n                mtgjsonUuid: bestMatch.card.uuid,\n                confidence: bestMatch.similarity * 0.8,\n                matchMethod: 'name_fuzzy',\n                lastUpdated: new Date().toISOString()\n            };\n        }\n        return null;\n    }\n    /**\r\n   * Normalize card names for comparison\r\n   */ normalizeCardName(name) {\n        return name.toLowerCase().replace(/[^\\w\\s]/g, '') // Remove special characters\n        .replace(/\\s+/g, ' ') // Normalize whitespace\n        .trim();\n    }\n    /**\r\n   * Calculate similarity between two strings using Levenshtein distance\r\n   */ calculateNameSimilarity(str1, str2) {\n        const len1 = str1.length;\n        const len2 = str2.length;\n        if (len1 === 0) return len2 === 0 ? 1 : 0;\n        if (len2 === 0) return 0;\n        const matrix = [];\n        // Initialize matrix\n        for(let i = 0; i <= len1; i++){\n            matrix[i] = [\n                i\n            ];\n        }\n        for(let j = 0; j <= len2; j++){\n            matrix[0][j] = j;\n        }\n        // Fill matrix\n        for(let i = 1; i <= len1; i++){\n            for(let j = 1; j <= len2; j++){\n                const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + cost // substitution\n                );\n            }\n        }\n        const distance = matrix[len1][len2];\n        const maxLength = Math.max(len1, len2);\n        return 1 - distance / maxLength;\n    }\n    /**\r\n   * Cache AllPrintings data\r\n   */ async cacheAllPrintings(data) {\n        try {\n            // Store in IndexedDB via mtgjsonCache\n            await _lib_utils_mtgjsonCache__WEBPACK_IMPORTED_MODULE_0__.mtgjsonCache.setMetadata({\n                lastPriceUpdate: data.meta.date,\n                totalCards: this.countTotalCards(data),\n                cacheVersion: data.meta.version\n            });\n            // For now, we'll store a subset of the data to avoid storage issues\n            // In production, you might want to use a more sophisticated storage strategy\n            console.log('AllPrintings data cached successfully');\n        } catch (error) {\n            console.error('Failed to cache AllPrintings data:', error);\n        }\n    }\n    /**\r\n   * Get cached AllPrintings data\r\n   */ async getCachedAllPrintings() {\n        try {\n            // This is a placeholder - in reality, you'd need to implement\n            // efficient storage and retrieval of the large AllPrintings dataset\n            return null;\n        } catch (error) {\n            console.error('Failed to get cached AllPrintings:', error);\n            return null;\n        }\n    }\n    /**\r\n   * Load mapping cache from storage\r\n   */ async loadMappingCache() {\n        try {\n            // Load existing mappings from localStorage or IndexedDB\n            const cached = localStorage.getItem(this.MAPPING_CACHE_KEY);\n            if (cached) {\n                const mappings = JSON.parse(cached);\n                for (const mapping of mappings){\n                    this.mappingCache.set(mapping.scryfallId, mapping);\n                }\n                console.log(\"Loaded \".concat(mappings.length, \" cached mappings\"));\n            }\n        } catch (error) {\n            console.error('Failed to load mapping cache:', error);\n        }\n    }\n    /**\r\n   * Save a single mapping to cache\r\n   */ async saveMappingToCache(mapping) {\n        try {\n            // Save to localStorage (for now)\n            const existingMappings = this.getAllCachedMappings();\n            const updatedMappings = existingMappings.filter((m)=>m.scryfallId !== mapping.scryfallId);\n            updatedMappings.push(mapping);\n            localStorage.setItem(this.MAPPING_CACHE_KEY, JSON.stringify(updatedMappings));\n        } catch (error) {\n            console.error('Failed to save mapping to cache:', error);\n        }\n    }\n    /**\r\n   * Get all cached mappings\r\n   */ getAllCachedMappings() {\n        try {\n            const cached = localStorage.getItem(this.MAPPING_CACHE_KEY);\n            return cached ? JSON.parse(cached) : [];\n        } catch (error) {\n            console.error('Failed to get cached mappings:', error);\n            return [];\n        }\n    }\n    /**\r\n   * Check if data is fresh (within 7 days)\r\n   */ isDataFresh(dateString) {\n        const dataDate = new Date(dateString);\n        const now = new Date();\n        const daysDiff = (now.getTime() - dataDate.getTime()) / (1000 * 60 * 60 * 24);\n        return daysDiff < 7;\n    }\n    /**\r\n   * Count total cards in AllPrintings data\r\n   */ countTotalCards(data) {\n        return Object.values(data.data).reduce((total, set)=>total + set.cards.length, 0);\n    }\n    /**\r\n   * Get mapping statistics\r\n   */ async getMappingStats() {\n        const cachedMappings = this.getAllCachedMappings();\n        return {\n            totalMappings: cachedMappings.length,\n            directMatches: cachedMappings.filter((m)=>m.matchMethod === 'direct').length,\n            fuzzyMatches: cachedMappings.filter((m)=>m.matchMethod === 'name_fuzzy').length,\n            unmappedCards: 0,\n            lastUpdate: cachedMappings.length > 0 ? Math.max(...cachedMappings.map((m)=>new Date(m.lastUpdated).getTime())).toString() : new Date().toISOString()\n        };\n    }\n    /**\r\n   * Clear all cached mappings\r\n   */ async clearMappingCache() {\n        this.mappingCache.clear();\n        localStorage.removeItem(this.MAPPING_CACHE_KEY);\n        console.log('Mapping cache cleared');\n    }\n    /**\r\n   * Batch process multiple cards for mapping\r\n   */ async batchGetMappings(scryfallCards) {\n        await this.initialize();\n        const results = new Map();\n        for (const card of scryfallCards){\n            try {\n                const uuid = await this.getMapping(card);\n                if (uuid) {\n                    results.set(card.id, uuid);\n                }\n            } catch (error) {\n                console.error(\"Failed to map card \".concat(card.name, \":\"), error);\n            }\n        }\n        return results;\n    }\n    constructor(){\n        this.allPrintingsData = null;\n        this.mappingCache = new Map();\n        this.loadingPromise = null;\n        // MTGJSON AllPrintings.json URL\n        this.MTGJSON_ALL_PRINTINGS_URL = 'https://mtgjson.com/api/v5/AllPrintings.json';\n        this.CACHE_KEY = 'mtgjson-all-printings';\n        this.MAPPING_CACHE_KEY = 'card-mappings';\n    }\n}\n// Export singleton instance\nconst cardMappingService = new CardMappingService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvY2FyZE1hcHBpbmdTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQ3dEO0FBc0R4RCxNQUFNQztJQVVKOztHQUVDLEdBQ0QsTUFBTUMsYUFBNEI7UUFDaEMsSUFBSSxJQUFJLENBQUNDLGNBQWMsRUFBRTtZQUN2QixPQUFPLElBQUksQ0FBQ0EsY0FBYztRQUM1QjtRQUVBLElBQUksQ0FBQ0EsY0FBYyxHQUFHLElBQUksQ0FBQ0Msb0JBQW9CO1FBQy9DLE9BQU8sSUFBSSxDQUFDRCxjQUFjO0lBQzVCO0lBRUE7O0dBRUMsR0FDRCxNQUFjQyx1QkFBc0M7UUFDbEQsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFFWiwrQkFBK0I7WUFDL0IsTUFBTUMsU0FBUyxNQUFNLElBQUksQ0FBQ0MscUJBQXFCO1lBQy9DLElBQUlELFVBQVUsSUFBSSxDQUFDRSxXQUFXLENBQUNGLE9BQU9HLElBQUksQ0FBQ0MsSUFBSSxHQUFHO2dCQUNoRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHTDtnQkFDeEJGLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixNQUFNLElBQUksQ0FBQ08sZ0JBQWdCO2dCQUMzQjtZQUNGO1lBRUEsZ0NBQWdDO1lBQ2hDUixRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNUSxXQUFXLE1BQU1DLE1BQU0sSUFBSSxDQUFDQyx5QkFBeUI7WUFFM0QsSUFBSSxDQUFDRixTQUFTRyxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSUMsTUFBTSxpQ0FBb0RKLE9BQW5CQSxTQUFTSyxNQUFNLEVBQUMsS0FBdUIsT0FBcEJMLFNBQVNNLFVBQVU7WUFDekY7WUFFQSxxQkFBcUI7WUFDckIsTUFBTUMsT0FBNEIsTUFBTVAsU0FBU1EsSUFBSTtZQUVyRCxJQUFJLENBQUNELEtBQUtBLElBQUksSUFBSSxDQUFDQSxLQUFLWCxJQUFJLEVBQUU7Z0JBQzVCLE1BQU0sSUFBSVEsTUFBTTtZQUNsQjtZQUVBLElB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QUFvZnZDO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1vQyxxQkFBcUIsSUFBSXhJLHFCQUFxQiIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFxtdGctaW5kZXhcXHNyY1xcbGliXFxzZXJ2aWNlc1xcY2FyZE1hcHBpbmdTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1UR0NhcmQsIE1UR0pTT05DYXJkIH0gZnJvbSAnQC9saWIvdHlwZXMnO1xyXG5pbXBvcnQgeyBtdGdqc29uQ2FjaGUgfSBmcm9tICdAL2xpYi91dGlscy9tdGdqc29uQ2FjaGUnO1xyXG5cclxuLy8gTVRHSlNPTiBBbGxQcmludGluZ3MgZGF0YSBzdHJ1Y3R1cmVcclxuaW50ZXJmYWNlIE1UR0pTT05TZXQge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBjb2RlOiBzdHJpbmc7XHJcbiAgY2FyZHM6IE1UR0pTT05DYXJkRGF0YVtdO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgTVRHSlNPTkNhcmREYXRhIHtcclxuICB1dWlkOiBzdHJpbmc7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIHNldENvZGU6IHN0cmluZztcclxuICBudW1iZXI6IHN0cmluZztcclxuICByYXJpdHk6IHN0cmluZztcclxuICBjb2xvcnM/OiBzdHJpbmdbXTtcclxuICBjb2xvcklkZW50aXR5Pzogc3RyaW5nW107XHJcbiAgbWFuYUNvc3Q/OiBzdHJpbmc7XHJcbiAgY29udmVydGVkTWFuYUNvc3Q/OiBudW1iZXI7XHJcbiAgdHlwZT86IHN0cmluZztcclxuICBzdWJ0eXBlcz86IHN0cmluZ1tdO1xyXG4gIHN1cGVydHlwZXM/OiBzdHJpbmdbXTtcclxuICBhcnRpc3Q/OiBzdHJpbmc7XHJcbiAgaWRlbnRpZmllcnM/OiB7XHJcbiAgICBzY3J5ZmFsbElkPzogc3RyaW5nO1xyXG4gICAgbXVsdGl2ZXJzZUlkPzogbnVtYmVyO1xyXG4gICAgbXRnanNvblY0SWQ/OiBzdHJpbmc7XHJcbiAgfTtcclxufVxyXG5cclxuaW50ZXJmYWNlIE1UR0pTT05BbGxQcmludGluZ3Mge1xyXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIE1UR0pTT05TZXQ+O1xyXG4gIG1ldGE6IHtcclxuICAgIGRhdGU6IHN0cmluZztcclxuICAgIHZlcnNpb246IHN0cmluZztcclxuICB9O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQ2FyZE1hcHBpbmcge1xyXG4gIHNjcnlmYWxsSWQ6IHN0cmluZztcclxuICBtdGdqc29uVXVpZDogc3RyaW5nO1xyXG4gIGNvbmZpZGVuY2U6IG51bWJlcjsgLy8gMC0xIHNjb3JlIG9mIG1hcHBpbmcgY29uZmlkZW5jZVxyXG4gIG1hdGNoTWV0aG9kOiAnZGlyZWN0JyB8ICduYW1lX3NldCcgfCAnbmFtZV9mdXp6eScgfCAnY29sbGVjdG9yX251bWJlcicgfCAnbWFudWFsJztcclxuICBsYXN0VXBkYXRlZDogc3RyaW5nO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgTWFwcGluZ1N0YXRzIHtcclxuICB0b3RhbE1hcHBpbmdzOiBudW1iZXI7XHJcbiAgZGlyZWN0TWF0Y2hlczogbnVtYmVyO1xyXG4gIGZ1enp5TWF0Y2hlczogbnVtYmVyO1xyXG4gIHVubWFwcGVkQ2FyZHM6IG51bWJlcjtcclxuICBsYXN0VXBkYXRlOiBzdHJpbmc7XHJcbn1cclxuXHJcbmNsYXNzIENhcmRNYXBwaW5nU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBhbGxQcmludGluZ3NEYXRhOiBNVEdKU09OQWxsUHJpbnRpbmdzIHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBtYXBwaW5nQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgQ2FyZE1hcHBpbmc+KCk7XHJcbiAgcHJpdmF0ZSBsb2FkaW5nUHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsO1xyXG5cclxuICAvLyBNVEdKU09OIEFsbFByaW50aW5ncy5qc29uIFVSTFxyXG4gIHByaXZhdGUgcmVhZG9ubHkgTVRHSlNPTl9BTExfUFJJTlRJTkdTX1VSTCA9ICdodHRwczovL210Z2pzb24uY29tL2FwaS92NS9BbGxQcmludGluZ3MuanNvbic7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBDQUNIRV9LRVkgPSAnbXRnanNvbi1hbGwtcHJpbnRpbmdzJztcclxuICBwcml2YXRlIHJlYWRvbmx5IE1BUFBJTkdfQ0FDSEVfS0VZID0gJ2NhcmQtbWFwcGluZ3MnO1xyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIHNlcnZpY2UgYnkgbG9hZGluZyBBbGxQcmludGluZ3MgZGF0YVxyXG4gICAqL1xyXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAodGhpcy5sb2FkaW5nUHJvbWlzZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5sb2FkaW5nUHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxvYWRpbmdQcm9taXNlID0gdGhpcy5sb2FkQWxsUHJpbnRpbmdzRGF0YSgpO1xyXG4gICAgcmV0dXJuIHRoaXMubG9hZGluZ1Byb21pc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIGFuZCBjYWNoZSBBbGxQcmludGluZ3MuanNvbiBkYXRhXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBsb2FkQWxsUHJpbnRpbmdzRGF0YSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIE1UR0pTT04gQWxsUHJpbnRpbmdzIGRhdGEuLi4nKTtcclxuXHJcbiAgICAgIC8vIFRyeSB0byBsb2FkIGZyb20gY2FjaGUgZmlyc3RcclxuICAgICAgY29uc3QgY2FjaGVkID0gYXdhaXQgdGhpcy5nZXRDYWNoZWRBbGxQcmludGluZ3MoKTtcclxuICAgICAgaWYgKGNhY2hlZCAmJiB0aGlzLmlzRGF0YUZyZXNoKGNhY2hlZC5tZXRhLmRhdGUpKSB7XHJcbiAgICAgICAgdGhpcy5hbGxQcmludGluZ3NEYXRhID0gY2FjaGVkO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2FkZWQgQWxsUHJpbnRpbmdzIGZyb20gY2FjaGUnKTtcclxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXBwaW5nQ2FjaGUoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZldGNoIGZyZXNoIGRhdGEgZnJvbSBNVEdKU09OXHJcbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBmcmVzaCBBbGxQcmludGluZ3MgZGF0YSBmcm9tIE1UR0pTT04uLi4nKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLk1UR0pTT05fQUxMX1BSSU5USU5HU19VUkwpO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIEFsbFByaW50aW5nczogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUGFyc2UgdGhlIHJlc3BvbnNlXHJcbiAgICAgIGNvbnN0IGRhdGE6IE1UR0pTT05BbGxQcmludGluZ3MgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIWRhdGEuZGF0YSB8fCAhZGF0YS5tZXRhKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEFsbFByaW50aW5ncyByZXNwb25zZSBmb3JtYXQnKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgdGhpcy5hbGxQcmludGluZ3NEYXRhID0gZGF0YTtcclxuICAgICAgXHJcbiAgICAgIC8vIFN0b3JlIHVzaW5nIHRoZSBvcHRpbWl6ZWQgc3RvcmFnZSBzeXN0ZW1cclxuICAgICAgY29uc3QgeyBhbGxQcmludGluZ3NTdG9yYWdlIH0gPSBhd2FpdCBpbXBvcnQoJ0AvbGliL3V0aWxzL2FsbFByaW50aW5nc1N0b3JhZ2UnKTtcclxuICAgICAgYXdhaXQgYWxsUHJpbnRpbmdzU3RvcmFnZS5zdG9yZUFsbFByaW50aW5ncyhkYXRhKTtcclxuICAgICAgXHJcbiAgICAgIGF3YWl0IHRoaXMubG9hZE1hcHBpbmdDYWNoZSgpO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYExvYWRlZCAke09iamVjdC5rZXlzKGRhdGEuZGF0YSkubGVuZ3RofSBzZXRzIGZyb20gTVRHSlNPTmApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgQWxsUHJpbnRpbmdzIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICBcclxuICAgICAgLy8gVHJ5IHRvIHVzZSBvcHRpbWl6ZWQgc3RvcmFnZSBhcyBmYWxsYmFja1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHsgYWxsUHJpbnRpbmdzU3RvcmFnZSB9ID0gYXdhaXQgaW1wb3J0KCdAL2xpYi91dGlscy9hbGxQcmludGluZ3NTdG9yYWdlJyk7XHJcbiAgICAgICAgY29uc3QgaXNBdmFpbGFibGUgPSBhd2FpdCBhbGxQcmludGluZ3NTdG9yYWdlLmlzRGF0YUF2YWlsYWJsZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChpc0F2YWlsYWJsZSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIHN0b3JlZCBBbGxQcmludGluZ3MgZGF0YSBhcyBmYWxsYmFjaycpO1xyXG4gICAgICAgICAgLy8gV2UnbGwgd29yayB3aXRoIHRoZSBzdG9yZWQgZGF0YSB3aXRob3V0IGxvYWRpbmcgZXZlcnl0aGluZyBpbnRvIG1lbW9yeVxyXG4gICAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFwcGluZ0NhY2hlKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChzdG9yYWdlRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYWNjZXNzIHN0b3JlZCBBbGxQcmludGluZ3MgZGF0YTonLCBzdG9yYWdlRXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIEFsbFByaW50aW5ncyBkYXRhIGFuZCBubyBjYWNoZSBhdmFpbGFibGUnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgTVRHSlNPTiBVVUlEIGZvciBhIFNjcnlmYWxsIGNhcmRcclxuICAgKi9cclxuICBhc3luYyBnZXRNYXBwaW5nKHNjcnlmYWxsQ2FyZDogTVRHQ2FyZCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XHJcblxyXG4gICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcclxuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMubWFwcGluZ0NhY2hlLmdldChzY3J5ZmFsbENhcmQuaWQpO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICByZXR1cm4gY2FjaGVkLm10Z2pzb25VdWlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyeSB0byBmaW5kIG1hcHBpbmdcclxuICAgIGNvbnN0IG1hcHBpbmcgPSBhd2FpdCB0aGlzLmZpbmRDYXJkTWFwcGluZyhzY3J5ZmFsbENhcmQpO1xyXG4gICAgaWYgKG1hcHBpbmcpIHtcclxuICAgICAgLy8gQ2FjaGUgdGhlIG1hcHBpbmdcclxuICAgICAgdGhpcy5tYXBwaW5nQ2FjaGUuc2V0KHNjcnlmYWxsQ2FyZC5pZCwgbWFwcGluZyk7XHJcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZU1hcHBpbmdUb0NhY2hlKG1hcHBpbmcpO1xyXG4gICAgICByZXR1cm4gbWFwcGluZy5tdGdqc29uVXVpZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmQgbWFwcGluZyBmb3IgYSBTY3J5ZmFsbCBjYXJkIHVzaW5nIG11bHRpcGxlIHN0cmF0ZWdpZXNcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGZpbmRDYXJkTWFwcGluZyhzY3J5ZmFsbENhcmQ6IE1UR0NhcmQpOiBQcm9taXNlPENhcmRNYXBwaW5nIHwgbnVsbD4ge1xyXG4gICAgLy8gRmlyc3QgdHJ5IHdpdGggaW4tbWVtb3J5IEFsbFByaW50aW5ncyBkYXRhIGlmIGF2YWlsYWJsZVxyXG4gICAgaWYgKHRoaXMuYWxsUHJpbnRpbmdzRGF0YSkge1xyXG4gICAgICBjb25zdCBzdHJhdGVnaWVzID0gW1xyXG4gICAgICAgICgpID0+IHRoaXMuZmluZEJ5RGlyZWN0U2NyeWZhbGxJZChzY3J5ZmFsbENhcmQpLFxyXG4gICAgICAgICgpID0+IHRoaXMuZmluZEJ5TmFtZUFuZFNldChzY3J5ZmFsbENhcmQpLFxyXG4gICAgICAgICgpID0+IHRoaXMuZmluZEJ5Q29sbGVjdG9yTnVtYmVyKHNjcnlmYWxsQ2FyZCksXHJcbiAgICAgICAgKCkgPT4gdGhpcy5maW5kQnlGdXp6eU5hbWUoc2NyeWZhbGxDYXJkKSxcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgc3RyYXRlZ3kgb2Ygc3RyYXRlZ2llcykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN0cmF0ZWd5KCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGYWxsYmFjayB0byBvcHRpbWl6ZWQgc3RvcmFnZSBzZWFyY2hcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgYWxsUHJpbnRpbmdzU3RvcmFnZSB9ID0gYXdhaXQgaW1wb3J0KCdAL2xpYi91dGlscy9hbGxQcmludGluZ3NTdG9yYWdlJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdHJhdGVneSAxOiBEaXJlY3QgU2NyeWZhbGwgSUQgc2VhcmNoXHJcbiAgICAgIGlmIChzY3J5ZmFsbENhcmQuc2NyeWZhbGxJZCkge1xyXG4gICAgICAgIGNvbnN0IGNhcmQgPSBhd2FpdCBhbGxQcmludGluZ3NTdG9yYWdlLmZpbmRDYXJkQnlTY3J5ZmFsbElkKHNjcnlmYWxsQ2FyZC5zY3J5ZmFsbElkKTtcclxuICAgICAgICBpZiAoY2FyZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2NyeWZhbGxJZDogc2NyeWZhbGxDYXJkLmlkLFxyXG4gICAgICAgICAgICBtdGdqc29uVXVpZDogY2FyZC51dWlkLFxyXG4gICAgICAgICAgICBjb25maWRlbmNlOiAxLjAsXHJcbiAgICAgICAgICAgIG1hdGNoTWV0aG9kOiAnZGlyZWN0JyxcclxuICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTdHJhdGVneSAyOiBTZWFyY2ggYnkgbmFtZSBhbmQgdHJ5IHRvIG1hdGNoIHdpdGggc2V0XHJcbiAgICAgIGNvbnN0IHNlYXJjaFJlc3VsdHMgPSBhd2FpdCBhbGxQcmludGluZ3NTdG9yYWdlLnNlYXJjaENhcmRzKHNjcnlmYWxsQ2FyZC5uYW1lLCAyMCk7XHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGNvbnN0IGNhcmQgb2Ygc2VhcmNoUmVzdWx0cykge1xyXG4gICAgICAgIC8vIEV4YWN0IG5hbWUgYW5kIHNldCBtYXRjaFxyXG4gICAgICAgIGlmICh0aGlzLm5vcm1hbGl6ZUNhcmROYW1lKGNhcmQubmFtZSkgPT09IHRoaXMubm9ybWFsaXplQ2FyZE5hbWUoc2NyeWZhbGxDYXJkLm5hbWUpICYmXHJcbiAgICAgICAgICAgIGNhcmQuc2V0Q29kZS50b0xvd2VyQ2FzZSgpID09PSBzY3J5ZmFsbENhcmQuc2V0Q29kZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzY3J5ZmFsbElkOiBzY3J5ZmFsbENhcmQuaWQsXHJcbiAgICAgICAgICAgIG10Z2pzb25VdWlkOiBjYXJkLnV1aWQsXHJcbiAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOTUsXHJcbiAgICAgICAgICAgIG1hdGNoTWV0aG9kOiAnbmFtZV9zZXQnLFxyXG4gICAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbGxlY3RvciBudW1iZXIgbWF0Y2ggd2l0aGluIHNhbWUgc2V0XHJcbiAgICAgICAgaWYgKGNhcmQuc2V0Q29kZS50b0xvd2VyQ2FzZSgpID09PSBzY3J5ZmFsbENhcmQuc2V0Q29kZS50b0xvd2VyQ2FzZSgpICYmXHJcbiAgICAgICAgICAgIGNhcmQubnVtYmVyLnRvTG93ZXJDYXNlKCkgPT09IChzY3J5ZmFsbENhcmQubnVtYmVyIHx8ICcnKS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICBjb25zdCBuYW1lU2ltaWxhcml0eSA9IHRoaXMuY2FsY3VsYXRlTmFtZVNpbWlsYXJpdHkoc2NyeWZhbGxDYXJkLm5hbWUsIGNhcmQubmFtZSk7XHJcbiAgICAgICAgICBpZiAobmFtZVNpbWlsYXJpdHkgPiAwLjgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICBzY3J5ZmFsbElkOiBzY3J5ZmFsbENhcmQuaWQsXHJcbiAgICAgICAgICAgICAgbXRnanNvblV1aWQ6IGNhcmQudXVpZCxcclxuICAgICAgICAgICAgICBjb25maWRlbmNlOiAwLjksXHJcbiAgICAgICAgICAgICAgbWF0Y2hNZXRob2Q6ICdjb2xsZWN0b3JfbnVtYmVyJyxcclxuICAgICAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRnV6enkgbmFtZSBtYXRjaFxyXG4gICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSB0aGlzLmNhbGN1bGF0ZU5hbWVTaW1pbGFyaXR5KHNjcnlmYWxsQ2FyZC5uYW1lLCBjYXJkLm5hbWUpO1xyXG4gICAgICAgIGlmIChzaW1pbGFyaXR5ID4gMC45KSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzY3J5ZmFsbElkOiBzY3J5ZmFsbENhcmQuaWQsXHJcbiAgICAgICAgICAgIG10Z2pzb25VdWlkOiBjYXJkLnV1aWQsXHJcbiAgICAgICAgICAgIGNvbmZpZGVuY2U6IHNpbWlsYXJpdHkgKiAwLjgsXHJcbiAgICAgICAgICAgIG1hdGNoTWV0aG9kOiAnbmFtZV9mdXp6eScsXHJcbiAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VhcmNoaW5nIG9wdGltaXplZCBzdG9yYWdlOicsIGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLndhcm4oYE5vIG1hcHBpbmcgZm91bmQgZm9yIGNhcmQ6ICR7c2NyeWZhbGxDYXJkLm5hbWV9ICgke3NjcnlmYWxsQ2FyZC5zZXRDb2RlfSlgKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RyYXRlZ3kgMTogRGlyZWN0IFNjcnlmYWxsIElEIG1hdGNoIChtb3N0IHJlbGlhYmxlKVxyXG4gICAqL1xyXG4gIHByaXZhdGUgZmluZEJ5RGlyZWN0U2NyeWZhbGxJZChzY3J5ZmFsbENhcmQ6IE1UR0NhcmQpOiBDYXJkTWFwcGluZyB8IG51bGwge1xyXG4gICAgaWYgKCFzY3J5ZmFsbENhcmQuc2NyeWZhbGxJZCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgZm9yIChjb25zdCBzZXQgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmFsbFByaW50aW5nc0RhdGEhLmRhdGEpKSB7XHJcbiAgICAgIGZvciAoY29uc3QgY2FyZCBvZiBzZXQuY2FyZHMpIHtcclxuICAgICAgICBpZiAoY2FyZC5pZGVudGlmaWVycz8uc2NyeWZhbGxJZCA9PT0gc2NyeWZhbGxDYXJkLnNjcnlmYWxsSWQpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNjcnlmYWxsSWQ6IHNjcnlmYWxsQ2FyZC5pZCxcclxuICAgICAgICAgICAgbXRnanNvblV1aWQ6IGNhcmQudXVpZCxcclxuICAgICAgICAgICAgY29uZmlkZW5jZTogMS4wLFxyXG4gICAgICAgICAgICBtYXRjaE1ldGhvZDogJ2RpcmVjdCcsXHJcbiAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RyYXRlZ3kgMjogTWF0Y2ggYnkgZXhhY3QgbmFtZSBhbmQgc2V0IGNvZGVcclxuICAgKi9cclxuICBwcml2YXRlIGZpbmRCeU5hbWVBbmRTZXQoc2NyeWZhbGxDYXJkOiBNVEdDYXJkKTogQ2FyZE1hcHBpbmcgfCBudWxsIHtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gdGhpcy5ub3JtYWxpemVDYXJkTmFtZShzY3J5ZmFsbENhcmQubmFtZSk7XHJcbiAgICBjb25zdCBzZXRDb2RlID0gc2NyeWZhbGxDYXJkLnNldENvZGUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHNldCBvZiBPYmplY3QudmFsdWVzKHRoaXMuYWxsUHJpbnRpbmdzRGF0YSEuZGF0YSkpIHtcclxuICAgICAgaWYgKHNldC5jb2RlLnRvTG93ZXJDYXNlKCkgIT09IHNldENvZGUpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjYXJkIG9mIHNldC5jYXJkcykge1xyXG4gICAgICAgIGNvbnN0IGNhcmROb3JtYWxpemVkTmFtZSA9IHRoaXMubm9ybWFsaXplQ2FyZE5hbWUoY2FyZC5uYW1lKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY2FyZE5vcm1hbGl6ZWROYW1lID09PSBub3JtYWxpemVkTmFtZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2NyeWZhbGxJZDogc2NyeWZhbGxDYXJkLmlkLFxyXG4gICAgICAgICAgICBtdGdqc29uVXVpZDogY2FyZC51dWlkLFxyXG4gICAgICAgICAgICBjb25maWRlbmNlOiAwLjk1LFxyXG4gICAgICAgICAgICBtYXRjaE1ldGhvZDogJ25hbWVfc2V0JyxcclxuICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdHJhdGVneSAzOiBNYXRjaCBieSBjb2xsZWN0b3IgbnVtYmVyIGFuZCBzZXRcclxuICAgKi9cclxuICBwcml2YXRlIGZpbmRCeUNvbGxlY3Rvck51bWJlcihzY3J5ZmFsbENhcmQ6IE1UR0NhcmQpOiBDYXJkTWFwcGluZyB8IG51bGwge1xyXG4gICAgaWYgKCFzY3J5ZmFsbENhcmQubnVtYmVyKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBjb25zdCBzZXRDb2RlID0gc2NyeWZhbGxDYXJkLnNldENvZGUudG9Mb3dlckNhc2UoKTtcclxuICAgIGNvbnN0IGNvbGxlY3Rvck51bWJlciA9IHNjcnlmYWxsQ2FyZC5udW1iZXIudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHNldCBvZiBPYmplY3QudmFsdWVzKHRoaXMuYWxsUHJpbnRpbmdzRGF0YSEuZGF0YSkpIHtcclxuICAgICAgaWYgKHNldC5jb2RlLnRvTG93ZXJDYXNlKCkgIT09IHNldENvZGUpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjYXJkIG9mIHNldC5jYXJkcykge1xyXG4gICAgICAgIGlmIChjYXJkLm51bWJlci50b0xvd2VyQ2FzZSgpID09PSBjb2xsZWN0b3JOdW1iZXIpIHtcclxuICAgICAgICAgIC8vIEFsc28gY2hlY2sgaWYgbmFtZXMgYXJlIHNpbWlsYXIgdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzXHJcbiAgICAgICAgICBjb25zdCBuYW1lU2ltaWxhcml0eSA9IHRoaXMuY2FsY3VsYXRlTmFtZVNpbWlsYXJpdHkoc2NyeWZhbGxDYXJkLm5hbWUsIGNhcmQubmFtZSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChuYW1lU2ltaWxhcml0eSA+IDAuOCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIHNjcnlmYWxsSWQ6IHNjcnlmYWxsQ2FyZC5pZCxcclxuICAgICAgICAgICAgICBtdGdqc29uVXVpZDogY2FyZC51dWlkLFxyXG4gICAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcclxuICAgICAgICAgICAgICBtYXRjaE1ldGhvZDogJ2NvbGxlY3Rvcl9udW1iZXInLFxyXG4gICAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdHJhdGVneSA0OiBGdXp6eSBuYW1lIG1hdGNoaW5nIChsZWFzdCByZWxpYWJsZSlcclxuICAgKi9cclxuICBwcml2YXRlIGZpbmRCeUZ1enp5TmFtZShzY3J5ZmFsbENhcmQ6IE1UR0NhcmQpOiBDYXJkTWFwcGluZyB8IG51bGwge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSB0aGlzLm5vcm1hbGl6ZUNhcmROYW1lKHNjcnlmYWxsQ2FyZC5uYW1lKTtcclxuICAgIGxldCBiZXN0TWF0Y2g6IHsgY2FyZDogTVRHSlNPTkNhcmREYXRhOyBzaW1pbGFyaXR5OiBudW1iZXIgfSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIGZvciAoY29uc3Qgc2V0IG9mIE9iamVjdC52YWx1ZXModGhpcy5hbGxQcmludGluZ3NEYXRhIS5kYXRhKSkge1xyXG4gICAgICBmb3IgKGNvbnN0IGNhcmQgb2Ygc2V0LmNhcmRzKSB7XHJcbiAgICAgICAgY29uc3QgY2FyZE5vcm1hbGl6ZWROYW1lID0gdGhpcy5ub3JtYWxpemVDYXJkTmFtZShjYXJkLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSB0aGlzLmNhbGN1bGF0ZU5hbWVTaW1pbGFyaXR5KG5vcm1hbGl6ZWROYW1lLCBjYXJkTm9ybWFsaXplZE5hbWUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChzaW1pbGFyaXR5ID4gMC45ICYmICghYmVzdE1hdGNoIHx8IHNpbWlsYXJpdHkgPiBiZXN0TWF0Y2guc2ltaWxhcml0eSkpIHtcclxuICAgICAgICAgIGJlc3RNYXRjaCA9IHsgY2FyZCwgc2ltaWxhcml0eSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChiZXN0TWF0Y2ggJiYgYmVzdE1hdGNoLnNpbWlsYXJpdHkgPiAwLjkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzY3J5ZmFsbElkOiBzY3J5ZmFsbENhcmQuaWQsXHJcbiAgICAgICAgbXRnanNvblV1aWQ6IGJlc3RNYXRjaC5jYXJkLnV1aWQsXHJcbiAgICAgICAgY29uZmlkZW5jZTogYmVzdE1hdGNoLnNpbWlsYXJpdHkgKiAwLjgsIC8vIFJlZHVjZSBjb25maWRlbmNlIGZvciBmdXp6eSBtYXRjaGVzXHJcbiAgICAgICAgbWF0Y2hNZXRob2Q6ICduYW1lX2Z1enp5JyxcclxuICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplIGNhcmQgbmFtZXMgZm9yIGNvbXBhcmlzb25cclxuICAgKi9cclxuICBwcml2YXRlIG5vcm1hbGl6ZUNhcmROYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gbmFtZVxyXG4gICAgICAudG9Mb3dlckNhc2UoKVxyXG4gICAgICAucmVwbGFjZSgvW15cXHdcXHNdL2csICcnKSAvLyBSZW1vdmUgc3BlY2lhbCBjaGFyYWN0ZXJzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJykgLy8gTm9ybWFsaXplIHdoaXRlc3BhY2VcclxuICAgICAgLnRyaW0oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBzaW1pbGFyaXR5IGJldHdlZW4gdHdvIHN0cmluZ3MgdXNpbmcgTGV2ZW5zaHRlaW4gZGlzdGFuY2VcclxuICAgKi9cclxuICBwcml2YXRlIGNhbGN1bGF0ZU5hbWVTaW1pbGFyaXR5KHN0cjE6IHN0cmluZywgc3RyMjogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IGxlbjEgPSBzdHIxLmxlbmd0aDtcclxuICAgIGNvbnN0IGxlbjIgPSBzdHIyLmxlbmd0aDtcclxuICAgIFxyXG4gICAgaWYgKGxlbjEgPT09IDApIHJldHVybiBsZW4yID09PSAwID8gMSA6IDA7XHJcbiAgICBpZiAobGVuMiA9PT0gMCkgcmV0dXJuIDA7XHJcblxyXG4gICAgY29uc3QgbWF0cml4OiBudW1iZXJbXVtdID0gW107XHJcbiAgICBcclxuICAgIC8vIEluaXRpYWxpemUgbWF0cml4XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsZW4xOyBpKyspIHtcclxuICAgICAgbWF0cml4W2ldID0gW2ldO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPD0gbGVuMjsgaisrKSB7XHJcbiAgICAgIG1hdHJpeFswXVtqXSA9IGo7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmlsbCBtYXRyaXhcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGxlbjE7IGkrKykge1xyXG4gICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBsZW4yOyBqKyspIHtcclxuICAgICAgICBjb25zdCBjb3N0ID0gc3RyMVtpIC0gMV0gPT09IHN0cjJbaiAtIDFdID8gMCA6IDE7XHJcbiAgICAgICAgbWF0cml4W2ldW2pdID0gTWF0aC5taW4oXHJcbiAgICAgICAgICBtYXRyaXhbaSAtIDFdW2pdICsgMSwgICAgIC8vIGRlbGV0aW9uXHJcbiAgICAgICAgICBtYXRyaXhbaV1baiAtIDFdICsgMSwgICAgIC8vIGluc2VydGlvblxyXG4gICAgICAgICAgbWF0cml4W2kgLSAxXVtqIC0gMV0gKyBjb3N0IC8vIHN1YnN0aXR1dGlvblxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkaXN0YW5jZSA9IG1hdHJpeFtsZW4xXVtsZW4yXTtcclxuICAgIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWF4KGxlbjEsIGxlbjIpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gMSAtIChkaXN0YW5jZSAvIG1heExlbmd0aCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWNoZSBBbGxQcmludGluZ3MgZGF0YVxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgY2FjaGVBbGxQcmludGluZ3MoZGF0YTogTVRHSlNPTkFsbFByaW50aW5ncyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU3RvcmUgaW4gSW5kZXhlZERCIHZpYSBtdGdqc29uQ2FjaGVcclxuICAgICAgYXdhaXQgbXRnanNvbkNhY2hlLnNldE1ldGFkYXRhKHtcclxuICAgICAgICBsYXN0UHJpY2VVcGRhdGU6IGRhdGEubWV0YS5kYXRlLFxyXG4gICAgICAgIHRvdGFsQ2FyZHM6IHRoaXMuY291bnRUb3RhbENhcmRzKGRhdGEpLFxyXG4gICAgICAgIGNhY2hlVmVyc2lvbjogZGF0YS5tZXRhLnZlcnNpb24sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gRm9yIG5vdywgd2UnbGwgc3RvcmUgYSBzdWJzZXQgb2YgdGhlIGRhdGEgdG8gYXZvaWQgc3RvcmFnZSBpc3N1ZXNcclxuICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgeW91IG1pZ2h0IHdhbnQgdG8gdXNlIGEgbW9yZSBzb3BoaXN0aWNhdGVkIHN0b3JhZ2Ugc3RyYXRlZ3lcclxuICAgICAgY29uc29sZS5sb2coJ0FsbFByaW50aW5ncyBkYXRhIGNhY2hlZCBzdWNjZXNzZnVsbHknKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjYWNoZSBBbGxQcmludGluZ3MgZGF0YTonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY2FjaGVkIEFsbFByaW50aW5ncyBkYXRhXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRDYWNoZWRBbGxQcmludGluZ3MoKTogUHJvbWlzZTxNVEdKU09OQWxsUHJpbnRpbmdzIHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVGhpcyBpcyBhIHBsYWNlaG9sZGVyIC0gaW4gcmVhbGl0eSwgeW91J2QgbmVlZCB0byBpbXBsZW1lbnRcclxuICAgICAgLy8gZWZmaWNpZW50IHN0b3JhZ2UgYW5kIHJldHJpZXZhbCBvZiB0aGUgbGFyZ2UgQWxsUHJpbnRpbmdzIGRhdGFzZXRcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGNhY2hlZCBBbGxQcmludGluZ3M6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWQgbWFwcGluZyBjYWNoZSBmcm9tIHN0b3JhZ2VcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGxvYWRNYXBwaW5nQ2FjaGUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBMb2FkIGV4aXN0aW5nIG1hcHBpbmdzIGZyb20gbG9jYWxTdG9yYWdlIG9yIEluZGV4ZWREQlxyXG4gICAgICBjb25zdCBjYWNoZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLk1BUFBJTkdfQ0FDSEVfS0VZKTtcclxuICAgICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIGNvbnN0IG1hcHBpbmdzOiBDYXJkTWFwcGluZ1tdID0gSlNPTi5wYXJzZShjYWNoZWQpO1xyXG4gICAgICAgIGZvciAoY29uc3QgbWFwcGluZyBvZiBtYXBwaW5ncykge1xyXG4gICAgICAgICAgdGhpcy5tYXBwaW5nQ2FjaGUuc2V0KG1hcHBpbmcuc2NyeWZhbGxJZCwgbWFwcGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBMb2FkZWQgJHttYXBwaW5ncy5sZW5ndGh9IGNhY2hlZCBtYXBwaW5nc2ApO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBtYXBwaW5nIGNhY2hlOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNhdmUgYSBzaW5nbGUgbWFwcGluZyB0byBjYWNoZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgc2F2ZU1hcHBpbmdUb0NhY2hlKG1hcHBpbmc6IENhcmRNYXBwaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZSAoZm9yIG5vdylcclxuICAgICAgY29uc3QgZXhpc3RpbmdNYXBwaW5ncyA9IHRoaXMuZ2V0QWxsQ2FjaGVkTWFwcGluZ3MoKTtcclxuICAgICAgY29uc3QgdXBkYXRlZE1hcHBpbmdzID0gZXhpc3RpbmdNYXBwaW5ncy5maWx0ZXIobSA9PiBtLnNjcnlmYWxsSWQgIT09IG1hcHBpbmcuc2NyeWZhbGxJZCk7XHJcbiAgICAgIHVwZGF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xyXG4gICAgICBcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5NQVBQSU5HX0NBQ0hFX0tFWSwgSlNPTi5zdHJpbmdpZnkodXBkYXRlZE1hcHBpbmdzKSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBtYXBwaW5nIHRvIGNhY2hlOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbGwgY2FjaGVkIG1hcHBpbmdzXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRBbGxDYWNoZWRNYXBwaW5ncygpOiBDYXJkTWFwcGluZ1tdIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuTUFQUElOR19DQUNIRV9LRVkpO1xyXG4gICAgICByZXR1cm4gY2FjaGVkID8gSlNPTi5wYXJzZShjYWNoZWQpIDogW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGNhY2hlZCBtYXBwaW5nczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGRhdGEgaXMgZnJlc2ggKHdpdGhpbiA3IGRheXMpXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBpc0RhdGFGcmVzaChkYXRlU3RyaW5nOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGRhdGFEYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZyk7XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgY29uc3QgZGF5c0RpZmYgPSAobm93LmdldFRpbWUoKSAtIGRhdGFEYXRlLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCk7XHJcbiAgICByZXR1cm4gZGF5c0RpZmYgPCA3O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ291bnQgdG90YWwgY2FyZHMgaW4gQWxsUHJpbnRpbmdzIGRhdGFcclxuICAgKi9cclxuICBwcml2YXRlIGNvdW50VG90YWxDYXJkcyhkYXRhOiBNVEdKU09OQWxsUHJpbnRpbmdzKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGRhdGEuZGF0YSkucmVkdWNlKCh0b3RhbCwgc2V0KSA9PiB0b3RhbCArIHNldC5jYXJkcy5sZW5ndGgsIDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG1hcHBpbmcgc3RhdGlzdGljc1xyXG4gICAqL1xyXG4gIGFzeW5jIGdldE1hcHBpbmdTdGF0cygpOiBQcm9taXNlPE1hcHBpbmdTdGF0cz4ge1xyXG4gICAgY29uc3QgY2FjaGVkTWFwcGluZ3MgPSB0aGlzLmdldEFsbENhY2hlZE1hcHBpbmdzKCk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvdGFsTWFwcGluZ3M6IGNhY2hlZE1hcHBpbmdzLmxlbmd0aCxcclxuICAgICAgZGlyZWN0TWF0Y2hlczogY2FjaGVkTWFwcGluZ3MuZmlsdGVyKG0gPT4gbS5tYXRjaE1ldGhvZCA9PT0gJ2RpcmVjdCcpLmxlbmd0aCxcclxuICAgICAgZnV6enlNYXRjaGVzOiBjYWNoZWRNYXBwaW5ncy5maWx0ZXIobSA9PiBtLm1hdGNoTWV0aG9kID09PSAnbmFtZV9mdXp6eScpLmxlbmd0aCxcclxuICAgICAgdW5tYXBwZWRDYXJkczogMCwgLy8gV291bGQgbmVlZCB0byB0cmFjayB0aGlzIHNlcGFyYXRlbHlcclxuICAgICAgbGFzdFVwZGF0ZTogY2FjaGVkTWFwcGluZ3MubGVuZ3RoID4gMCBcclxuICAgICAgICA/IE1hdGgubWF4KC4uLmNhY2hlZE1hcHBpbmdzLm1hcChtID0+IG5ldyBEYXRlKG0ubGFzdFVwZGF0ZWQpLmdldFRpbWUoKSkpLnRvU3RyaW5nKClcclxuICAgICAgICA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhciBhbGwgY2FjaGVkIG1hcHBpbmdzXHJcbiAgICovXHJcbiAgYXN5bmMgY2xlYXJNYXBwaW5nQ2FjaGUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0aGlzLm1hcHBpbmdDYWNoZS5jbGVhcigpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5NQVBQSU5HX0NBQ0hFX0tFWSk7XHJcbiAgICBjb25zb2xlLmxvZygnTWFwcGluZyBjYWNoZSBjbGVhcmVkJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCYXRjaCBwcm9jZXNzIG11bHRpcGxlIGNhcmRzIGZvciBtYXBwaW5nXHJcbiAgICovXHJcbiAgYXN5bmMgYmF0Y2hHZXRNYXBwaW5ncyhzY3J5ZmFsbENhcmRzOiBNVEdDYXJkW10pOiBQcm9taXNlPE1hcDxzdHJpbmcsIHN0cmluZz4+IHtcclxuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgXHJcbiAgICBjb25zdCByZXN1bHRzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBjYXJkIG9mIHNjcnlmYWxsQ2FyZHMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB1dWlkID0gYXdhaXQgdGhpcy5nZXRNYXBwaW5nKGNhcmQpO1xyXG4gICAgICAgIGlmICh1dWlkKSB7XHJcbiAgICAgICAgICByZXN1bHRzLnNldChjYXJkLmlkLCB1dWlkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIG1hcCBjYXJkICR7Y2FyZC5uYW1lfTpgLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBjYXJkTWFwcGluZ1NlcnZpY2UgPSBuZXcgQ2FyZE1hcHBpbmdTZXJ2aWNlKCk7XHJcblxyXG4vLyBFeHBvcnQgdHlwZXMgZm9yIGV4dGVybmFsIHVzZVxyXG5leHBvcnQgdHlwZSB7IENhcmRNYXBwaW5nLCBNYXBwaW5nU3RhdHMgfTtcclxuIl0sIm5hbWVzIjpbIm10Z2pzb25DYWNoZSIsIkNhcmRNYXBwaW5nU2VydmljZSIsImluaXRpYWxpemUiLCJsb2FkaW5nUHJvbWlzZSIsImxvYWRBbGxQcmludGluZ3NEYXRhIiwiY29uc29sZSIsImxvZyIsImNhY2hlZCIsImdldENhY2hlZEFsbFByaW50aW5ncyIsImlzRGF0YUZyZXNoIiwibWV0YSIsImRhdGUiLCJhbGxQcmludGluZ3NEYXRhIiwibG9hZE1hcHBpbmdDYWNoZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJNVEdKU09OX0FMTF9QUklOVElOR1NfVVJMIiwib2siLCJFcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJkYXRhIiwianNvbiIsImFsbFByaW50aW5nc1N0b3JhZ2UiLCJzdG9yZUFsbFByaW50aW5ncyIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJlcnJvciIsImlzQXZhaWxhYmxlIiwiaXNEYXRhQXZhaWxhYmxlIiwic3RvcmFnZUVycm9yIiwiZ2V0TWFwcGluZyIsInNjcnlmYWxsQ2FyZCIsIm1hcHBpbmdDYWNoZSIsImdldCIsImlkIiwibXRnanNvblV1aWQiLCJtYXBwaW5nIiwiZmluZENhcmRNYXBwaW5nIiwic2V0Iiwic2F2ZU1hcHBpbmdUb0NhY2hlIiwic3RyYXRlZ2llcyIsImZpbmRCeURpcmVjdFNjcnlmYWxsSWQiLCJmaW5kQnlOYW1lQW5kU2V0IiwiZmluZEJ5Q29sbGVjdG9yTnVtYmVyIiwiZmluZEJ5RnV6enlOYW1lIiwic3RyYXRlZ3kiLCJyZXN1bHQiLCJzY3J5ZmFsbElkIiwiY2FyZCIsImZpbmRDYXJkQnlTY3J5ZmFsbElkIiwidXVpZCIsImNvbmZpZGVuY2UiLCJtYXRjaE1ldGhvZCIsImxhc3RVcGRhdGVkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic2VhcmNoUmVzdWx0cyIsInNlYXJjaENhcmRzIiwibmFtZSIsIm5vcm1hbGl6ZUNhcmROYW1lIiwic2V0Q29kZSIsInRvTG93ZXJDYXNlIiwibnVtYmVyIiwibmFtZVNpbWlsYXJpdHkiLCJjYWxjdWxhdGVOYW1lU2ltaWxhcml0eSIsInNpbWlsYXJpdHkiLCJ3YXJuIiwidmFsdWVzIiwiY2FyZHMiLCJpZGVudGlmaWVycyIsIm5vcm1hbGl6ZWROYW1lIiwiY29kZSIsImNhcmROb3JtYWxpemVkTmFtZSIsImNvbGxlY3Rvck51bWJlciIsImJlc3RNYXRjaCIsInJlcGxhY2UiLCJ0cmltIiwic3RyMSIsInN0cjIiLCJsZW4xIiwibGVuMiIsIm1hdHJpeCIsImkiLCJqIiwiY29zdCIsIk1hdGgiLCJtaW4iLCJkaXN0YW5jZSIsIm1heExlbmd0aCIsIm1heCIsImNhY2hlQWxsUHJpbnRpbmdzIiwic2V0TWV0YWRhdGEiLCJsYXN0UHJpY2VVcGRhdGUiLCJ0b3RhbENhcmRzIiwiY291bnRUb3RhbENhcmRzIiwiY2FjaGVWZXJzaW9uIiwidmVyc2lvbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJNQVBQSU5HX0NBQ0hFX0tFWSIsIm1hcHBpbmdzIiwiSlNPTiIsInBhcnNlIiwiZXhpc3RpbmdNYXBwaW5ncyIsImdldEFsbENhY2hlZE1hcHBpbmdzIiwidXBkYXRlZE1hcHBpbmdzIiwiZmlsdGVyIiwibSIsInB1c2giLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZGF0ZVN0cmluZyIsImRhdGFEYXRlIiwibm93IiwiZGF5c0RpZmYiLCJnZXRUaW1lIiwicmVkdWNlIiwidG90YWwiLCJnZXRNYXBwaW5nU3RhdHMiLCJjYWNoZWRNYXBwaW5ncyIsInRvdGFsTWFwcGluZ3MiLCJkaXJlY3RNYXRjaGVzIiwiZnV6enlNYXRjaGVzIiwidW5tYXBwZWRDYXJkcyIsImxhc3RVcGRhdGUiLCJtYXAiLCJ0b1N0cmluZyIsImNsZWFyTWFwcGluZ0NhY2hlIiwiY2xlYXIiLCJyZW1vdmVJdGVtIiwiYmF0Y2hHZXRNYXBwaW5ncyIsInNjcnlmYWxsQ2FyZHMiLCJyZXN1bHRzIiwiTWFwIiwiQ0FDSEVfS0VZIiwiY2FyZE1hcHBpbmdTZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/cardMappingService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/utils/mtgjsonCache.ts":
/*!***************************************!*\
  !*** ./src/lib/utils/mtgjsonCache.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   mtgjsonCache: () => (/* binding */ mtgjsonCache)\n/* harmony export */ });\n// IndexedDB configuration for MTGJSON data\nconst DB_NAME = 'MTGJSONCache';\nconst DB_VERSION = 1;\nconst STORES = {\n    PRICE_HISTORY: 'priceHistory',\n    CARD_MAPPINGS: 'cardMappings',\n    METADATA: 'metadata'\n};\n// Cache expiry times\nconst CACHE_EXPIRY = {\n    PRICE_HISTORY: 24 * 60 * 60 * 1000,\n    CARD_MAPPINGS: 7 * 24 * 60 * 60 * 1000,\n    METADATA: 60 * 60 * 1000\n};\nclass MTGJSONCache {\n    async init() {\n        if (this.db) return;\n        if (this.initPromise) return this.initPromise;\n        this.initPromise = new Promise((resolve, reject)=>{\n            if (false) {}\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n            request.onerror = ()=>{\n                reject(new Error('Failed to open IndexedDB'));\n            };\n            request.onsuccess = ()=>{\n                this.db = request.result;\n                resolve();\n            };\n            request.onupgradeneeded = (event)=>{\n                const db = event.target.result;\n                // Create price history store\n                if (!db.objectStoreNames.contains(STORES.PRICE_HISTORY)) {\n                    const priceStore = db.createObjectStore(STORES.PRICE_HISTORY, {\n                        keyPath: 'uuid'\n                    });\n                    priceStore.createIndex('cardId', 'cardId', {\n                        unique: false\n                    });\n                    priceStore.createIndex('lastUpdated', 'lastUpdated', {\n                        unique: false\n                    });\n                }\n                // Create card mappings store\n                if (!db.objectStoreNames.contains(STORES.CARD_MAPPINGS)) {\n                    const mappingStore = db.createObjectStore(STORES.CARD_MAPPINGS, {\n                        keyPath: 'scryfallId'\n                    });\n                    mappingStore.createIndex('uuid', 'uuid', {\n                        unique: false\n                    });\n                    mappingStore.createIndex('name', 'name', {\n                        unique: false\n                    });\n                }\n                // Create metadata store\n                if (!db.objectStoreNames.contains(STORES.METADATA)) {\n                    db.createObjectStore(STORES.METADATA, {\n                        keyPath: 'key'\n                    });\n                }\n            };\n        });\n        return this.initPromise;\n    }\n    async getStore(storeName) {\n        let mode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'readonly';\n        await this.init();\n        if (!this.db) throw new Error('Database not initialized');\n        const transaction = this.db.transaction([\n            storeName\n        ], mode);\n        return transaction.objectStore(storeName);\n    }\n    // Price History Cache Methods\n    async getPriceHistory(uuid) {\n        try {\n            const store = await this.getStore(STORES.PRICE_HISTORY);\n            const request = store.get(uuid);\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>{\n                    const result = request.result;\n                    if (!result) {\n                        resolve(null);\n                        return;\n                    }\n                    // Check if cache entry is expired\n                    if (Date.now() > result.expiresAt) {\n                        // Remove expired entry\n                        this.removePriceHistory(uuid);\n                        resolve(null);\n                        return;\n                    }\n                    resolve(result.data);\n                };\n                request.onerror = ()=>{\n                    reject(new Error('Failed to get price history from cache'));\n                };\n            });\n        } catch (error) {\n            console.error('Error getting price history from cache:', error);\n            return null;\n        }\n    }\n    async setPriceHistory(uuid, priceHistory) {\n        try {\n            const store = await this.getStore(STORES.PRICE_HISTORY, 'readwrite');\n            const cacheEntry = {\n                data: priceHistory,\n                timestamp: Date.now(),\n                expiresAt: Date.now() + CACHE_EXPIRY.PRICE_HISTORY\n            };\n            const request = store.put({\n                uuid,\n                ...cacheEntry\n            });\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to cache price history'));\n            });\n        } catch (error) {\n            console.error('Error caching price history:', error);\n            throw error;\n        }\n    }\n    async removePriceHistory(uuid) {\n        try {\n            const store = await this.getStore(STORES.PRICE_HISTORY, 'readwrite');\n            const request = store.delete(uuid);\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to remove price history'));\n            });\n        } catch (error) {\n            console.error('Error removing price history:', error);\n        }\n    }\n    // Card Mapping Cache Methods\n    async getCardMapping(scryfallId) {\n        try {\n            const store = await this.getStore(STORES.CARD_MAPPINGS);\n            const request = store.get(scryfallId);\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>{\n                    const result = request.result;\n                    if (!result) {\n                        resolve(null);\n                        return;\n                    }\n                    // Check if cache entry is expired\n                    if (Date.now() > result.expiresAt) {\n                        this.removeCardMapping(scryfallId);\n                        resolve(null);\n                        return;\n                    }\n                    resolve(result.data);\n                };\n                request.onerror = ()=>{\n                    reject(new Error('Failed to get card mapping from cache'));\n                };\n            });\n        } catch (error) {\n            console.error('Error getting card mapping from cache:', error);\n            return null;\n        }\n    }\n    async setCardMapping(scryfallId, mtgjsonCard) {\n        try {\n            const store = await this.getStore(STORES.CARD_MAPPINGS, 'readwrite');\n            const cacheEntry = {\n                data: mtgjsonCard,\n                timestamp: Date.now(),\n                expiresAt: Date.now() + CACHE_EXPIRY.CARD_MAPPINGS\n            };\n            const request = store.put({\n                scryfallId,\n                ...cacheEntry\n            });\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to cache card mapping'));\n            });\n        } catch (error) {\n            console.error('Error caching card mapping:', error);\n            throw error;\n        }\n    }\n    async removeCardMapping(scryfallId) {\n        try {\n            const store = await this.getStore(STORES.CARD_MAPPINGS, 'readwrite');\n            const request = store.delete(scryfallId);\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to remove card mapping'));\n            });\n        } catch (error) {\n            console.error('Error removing card mapping:', error);\n        }\n    }\n    // Metadata Methods\n    async getMetadata() {\n        try {\n            const store = await this.getStore(STORES.METADATA);\n            const request = store.get('metadata');\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>{\n                    const result = request.result;\n                    if (!result) {\n                        resolve(null);\n                        return;\n                    }\n                    // Check if metadata is expired\n                    if (Date.now() > result.expiresAt) {\n                        this.setMetadata({\n                            lastPriceUpdate: '',\n                            totalCards: 0,\n                            cacheVersion: '1.0'\n                        });\n                        resolve(null);\n                        return;\n                    }\n                    resolve(result.data);\n                };\n                request.onerror = ()=>{\n                    reject(new Error('Failed to get metadata from cache'));\n                };\n            });\n        } catch (error) {\n            console.error('Error getting metadata from cache:', error);\n            return null;\n        }\n    }\n    async setMetadata(metadata) {\n        try {\n            const store = await this.getStore(STORES.METADATA, 'readwrite');\n            const cacheEntry = {\n                data: metadata,\n                timestamp: Date.now(),\n                expiresAt: Date.now() + CACHE_EXPIRY.METADATA\n            };\n            const request = store.put({\n                key: 'metadata',\n                ...cacheEntry\n            });\n            return new Promise((resolve, reject)=>{\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(new Error('Failed to cache metadata'));\n            });\n        } catch (error) {\n            console.error('Error caching metadata:', error);\n            throw error;\n        }\n    }\n    // Bulk Operations\n    async batchSetPriceHistories(priceHistories) {\n        try {\n            const store = await this.getStore(STORES.PRICE_HISTORY, 'readwrite');\n            const transaction = store.transaction;\n            const promises = priceHistories.map((param)=>{\n                let { uuid, data } = param;\n                const cacheEntry = {\n                    data,\n                    timestamp: Date.now(),\n                    expiresAt: Date.now() + CACHE_EXPIRY.PRICE_HISTORY\n                };\n                const request = store.put({\n                    uuid,\n                    ...cacheEntry\n                });\n                return new Promise((resolve, reject)=>{\n                    request.onsuccess = ()=>resolve();\n                    request.onerror = ()=>reject(new Error(\"Failed to cache price history for \".concat(uuid)));\n                });\n            });\n            await Promise.all(promises);\n            return new Promise((resolve, reject)=>{\n                transaction.oncomplete = ()=>resolve();\n                transaction.onerror = ()=>reject(new Error('Batch price history caching failed'));\n            });\n        } catch (error) {\n            console.error('Error batch caching price histories:', error);\n            throw error;\n        }\n    }\n    // Cache Management\n    async clearExpiredEntries() {\n        try {\n            const now = Date.now();\n            const stores = [\n                STORES.PRICE_HISTORY,\n                STORES.CARD_MAPPINGS,\n                STORES.METADATA\n            ];\n            for (const storeName of stores){\n                const store = await this.getStore(storeName, 'readwrite');\n                const request = store.openCursor();\n                await new Promise((resolve, reject)=>{\n                    request.onsuccess = ()=>{\n                        const cursor = request.result;\n                        if (cursor) {\n                            const entry = cursor.value;\n                            if (now > entry.expiresAt) {\n                                cursor.delete();\n                            }\n                            cursor.continue();\n                        } else {\n                            resolve();\n                        }\n                    };\n                    request.onerror = ()=>{\n                        reject(new Error(\"Failed to clear expired entries from \".concat(storeName)));\n                    };\n                });\n            }\n        } catch (error) {\n            console.error('Error clearing expired cache entries:', error);\n        }\n    }\n    async clearAllCache() {\n        try {\n            const stores = [\n                STORES.PRICE_HISTORY,\n                STORES.CARD_MAPPINGS,\n                STORES.METADATA\n            ];\n            for (const storeName of stores){\n                const store = await this.getStore(storeName, 'readwrite');\n                const request = store.clear();\n                await new Promise((resolve, reject)=>{\n                    request.onsuccess = ()=>resolve();\n                    request.onerror = ()=>reject(new Error(\"Failed to clear \".concat(storeName)));\n                });\n            }\n        } catch (error) {\n            console.error('Error clearing cache:', error);\n            throw error;\n        }\n    }\n    async getCacheStats() {\n        try {\n            const [priceCount, mappingCount] = await Promise.all([\n                this.getStoreCount(STORES.PRICE_HISTORY),\n                this.getStoreCount(STORES.CARD_MAPPINGS)\n            ]);\n            return {\n                priceHistoryCount: priceCount,\n                cardMappingCount: mappingCount,\n                totalSize: 0,\n                lastCleanup: null\n            };\n        } catch (error) {\n            console.error('Error getting cache stats:', error);\n            return {\n                priceHistoryCount: 0,\n                cardMappingCount: 0,\n                totalSize: 0,\n                lastCleanup: null\n            };\n        }\n    }\n    async getStoreCount(storeName) {\n        const store = await this.getStore(storeName);\n        const request = store.count();\n        return new Promise((resolve, reject)=>{\n            request.onsuccess = ()=>resolve(request.result);\n            request.onerror = ()=>reject(new Error(\"Failed to get count for \".concat(storeName)));\n        });\n    }\n    // Cleanup\n    async close() {\n        if (this.db) {\n            this.db.close();\n            this.db = null;\n            this.initPromise = null;\n        }\n    }\n    constructor(){\n        this.db = null;\n        this.initPromise = null;\n    }\n}\n// Export singleton instance\nconst mtgjsonCache = new MTGJSONCache();\n// Initialize cache on import (client-side only)\nif (true) {\n    mtgjsonCache.init().catch(console.error);\n    // Clean up expired entries on page load\n    setTimeout(()=>{\n        mtgjsonCache.clearExpiredEntries().catch(console.error);\n    }, 5000);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mtgjsonCache);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdXRpbHMvbXRnanNvbkNhY2hlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRUEsMkNBQTJDO0FBQzNDLE1BQU1BLFVBQVU7QUFDaEIsTUFBTUMsYUFBYTtBQUNuQixNQUFNQyxTQUFTO0lBQ2JDLGVBQWU7SUFDZkMsZUFBZTtJQUNmQyxVQUFVO0FBQ1o7QUFFQSxxQkFBcUI7QUFDckIsTUFBTUMsZUFBZTtJQUNuQkgsZUFBZSxLQUFLLEtBQUssS0FBSztJQUM5QkMsZUFBZSxJQUFJLEtBQUssS0FBSyxLQUFLO0lBQ2xDQyxVQUFVLEtBQUssS0FBSztBQUN0QjtBQWNBLE1BQU1FO0lBSUosTUFBTUMsT0FBc0I7UUFDMUIsSUFBSSxJQUFJLENBQUNDLEVBQUUsRUFBRTtRQUNiLElBQUksSUFBSSxDQUFDQyxXQUFXLEVBQUUsT0FBTyxJQUFJLENBQUNBLFdBQVc7UUFFN0MsSUFBSSxDQUFDQSxXQUFXLEdBQUcsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUN2QyxJQUFJLEtBQTZCLEVBQUUsRUFHbEM7WUFFRCxNQUFNRSxVQUFVQyxVQUFVQyxJQUFJLENBQUNqQixTQUFTQztZQUV4Q2MsUUFBUUcsT0FBTyxHQUFHO2dCQUNoQkwsT0FBTyxJQUFJQyxNQUFNO1lBQ25CO1lBRUFDLFFBQVFJLFNBQVMsR0FBRztnQkFDbEIsSUFBSSxDQUFDVixFQUFFLEdBQUdNLFFBQVFLLE1BQU07Z0JBQ3hCUjtZQUNGO1lBRUFHLFFBQVFNLGVBQWUsR0FBRyxDQUFDQztnQkFDekIsTUFBTWIsS0FBSyxNQUFPYyxNQUFNLENBQXNCSCxNQUFNO2dCQUVwRCw2QkFBNkI7Z0JBQzdCLElBQUksQ0FBQ1gsR0FBR2UsZ0JBQWdCLENBQUNDLFFBQVEsQ0FBQ3ZCLE9BQU9DLGFBQWEsR0FBRztvQkFDdkQsTUFBTXVCLGFBQWFqQixHQUFHa0IsaUJBQWlCLENBQUN6QixPQUFPQyxhQUFhLEVBQUU7d0JBQUV5QixTQUFTO29CQUFPO29CQUNoRkYs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R0FBRztRQUNyQjtJQUNGOzthQTNZUUQsS0FBeUI7YUFDekJDLGNBQW9DOztBQTJZOUM7QUFFQSw0QkFBNEI7QUFDckIsTUFBTWlGLGVBQWUsSUFBSXBGLGVBQWU7QUFFL0MsZ0RBQWdEO0FBQ2hELElBQUksSUFBNkIsRUFBRTtJQUNqQ29GLGFBQWFuRixJQUFJLEdBQUdvRixLQUFLLENBQUM3QyxRQUFRRCxLQUFLO0lBRXZDLHdDQUF3QztJQUN4QytDLFdBQVc7UUFDVEYsYUFBYW5CLG1CQUFtQixHQUFHb0IsS0FBSyxDQUFDN0MsUUFBUUQsS0FBSztJQUN4RCxHQUFHO0FBQ0w7QUFFQSxpRUFBZTZDLFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcbXRnLWluZGV4XFxzcmNcXGxpYlxcdXRpbHNcXG10Z2pzb25DYWNoZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNVEdKU09OQ2FyZFByaWNlcywgTVRHSlNPTkNhcmQsIFByaWNlSGlzdG9yeSB9IGZyb20gJ0AvbGliL3R5cGVzJztcclxuXHJcbi8vIEluZGV4ZWREQiBjb25maWd1cmF0aW9uIGZvciBNVEdKU09OIGRhdGFcclxuY29uc3QgREJfTkFNRSA9ICdNVEdKU09OQ2FjaGUnO1xyXG5jb25zdCBEQl9WRVJTSU9OID0gMTtcclxuY29uc3QgU1RPUkVTID0ge1xyXG4gIFBSSUNFX0hJU1RPUlk6ICdwcmljZUhpc3RvcnknLFxyXG4gIENBUkRfTUFQUElOR1M6ICdjYXJkTWFwcGluZ3MnLFxyXG4gIE1FVEFEQVRBOiAnbWV0YWRhdGEnLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuLy8gQ2FjaGUgZXhwaXJ5IHRpbWVzXHJcbmNvbnN0IENBQ0hFX0VYUElSWSA9IHtcclxuICBQUklDRV9ISVNUT1JZOiAyNCAqIDYwICogNjAgKiAxMDAwLCAvLyAyNCBob3Vyc1xyXG4gIENBUkRfTUFQUElOR1M6IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwLCAvLyA3IGRheXNcclxuICBNRVRBREFUQTogNjAgKiA2MCAqIDEwMDAsIC8vIDEgaG91clxyXG59IGFzIGNvbnN0O1xyXG5cclxuaW50ZXJmYWNlIENhY2hlRW50cnk8VD4ge1xyXG4gIGRhdGE6IFQ7XHJcbiAgdGltZXN0YW1wOiBudW1iZXI7XHJcbiAgZXhwaXJlc0F0OiBudW1iZXI7XHJcbn1cclxuXHJcbmludGVyZmFjZSBDYWNoZU1ldGFkYXRhIHtcclxuICBsYXN0UHJpY2VVcGRhdGU6IHN0cmluZztcclxuICB0b3RhbENhcmRzOiBudW1iZXI7XHJcbiAgY2FjaGVWZXJzaW9uOiBzdHJpbmc7XHJcbn1cclxuXHJcbmNsYXNzIE1UR0pTT05DYWNoZSB7XHJcbiAgcHJpdmF0ZSBkYjogSURCRGF0YWJhc2UgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIGluaXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIGFzeW5jIGluaXQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAodGhpcy5kYikgcmV0dXJuO1xyXG4gICAgaWYgKHRoaXMuaW5pdFByb21pc2UpIHJldHVybiB0aGlzLmluaXRQcm9taXNlO1xyXG5cclxuICAgIHRoaXMuaW5pdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0luZGV4ZWREQiBub3QgYXZhaWxhYmxlIGluIHNlcnZlciBlbnZpcm9ubWVudCcpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihEQl9OQU1FLCBEQl9WRVJTSU9OKTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gb3BlbiBJbmRleGVkREInKSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLmRiID0gcmVxdWVzdC5yZXN1bHQ7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCBkYiA9IChldmVudC50YXJnZXQgYXMgSURCT3BlbkRCUmVxdWVzdCkucmVzdWx0O1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgcHJpY2UgaGlzdG9yeSBzdG9yZVxyXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhTVE9SRVMuUFJJQ0VfSElTVE9SWSkpIHtcclxuICAgICAgICAgIGNvbnN0IHByaWNlU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShTVE9SRVMuUFJJQ0VfSElTVE9SWSwgeyBrZXlQYXRoOiAndXVpZCcgfSk7XHJcbiAgICAgICAgICBwcmljZVN0b3JlLmNyZWF0ZUluZGV4KCdjYXJkSWQnLCAnY2FyZElkJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgcHJpY2VTdG9yZS5jcmVhdGVJbmRleCgnbGFzdFVwZGF0ZWQnLCAnbGFzdFVwZGF0ZWQnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgY2FyZCBtYXBwaW5ncyBzdG9yZVxyXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhTVE9SRVMuQ0FSRF9NQVBQSU5HUykpIHtcclxuICAgICAgICAgIGNvbnN0IG1hcHBpbmdTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFUy5DQVJEX01BUFBJTkdTLCB7IGtleVBhdGg6ICdzY3J5ZmFsbElkJyB9KTtcclxuICAgICAgICAgIG1hcHBpbmdTdG9yZS5jcmVhdGVJbmRleCgndXVpZCcsICd1dWlkJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgbWFwcGluZ1N0b3JlLmNyZWF0ZUluZGV4KCduYW1lJywgJ25hbWUnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgbWV0YWRhdGEgc3RvcmVcclxuICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoU1RPUkVTLk1FVEFEQVRBKSkge1xyXG4gICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoU1RPUkVTLk1FVEFEQVRBLCB7IGtleVBhdGg6ICdrZXknIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRTdG9yZShzdG9yZU5hbWU6IHN0cmluZywgbW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlID0gJ3JlYWRvbmx5Jyk6IFByb21pc2U8SURCT2JqZWN0U3RvcmU+IHtcclxuICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG4gICAgaWYgKCF0aGlzLmRiKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIG5vdCBpbml0aWFsaXplZCcpO1xyXG5cclxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbc3RvcmVOYW1lXSwgbW9kZSk7XHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcclxuICB9XHJcblxyXG4gIC8vIFByaWNlIEhpc3RvcnkgQ2FjaGUgTWV0aG9kc1xyXG4gIGFzeW5jIGdldFByaWNlSGlzdG9yeSh1dWlkOiBzdHJpbmcpOiBQcm9taXNlPFByaWNlSGlzdG9yeSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuUFJJQ0VfSElTVE9SWSk7XHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXQodXVpZCk7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVxdWVzdC5yZXN1bHQgYXMgQ2FjaGVFbnRyeTxQcmljZUhpc3Rvcnk+IHwgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgY2FjaGUgZW50cnkgaXMgZXhwaXJlZFxyXG4gICAgICAgICAgaWYgKERhdGUubm93KCkgPiByZXN1bHQuZXhwaXJlc0F0KSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBleHBpcmVkIGVudHJ5XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUHJpY2VIaXN0b3J5KHV1aWQpO1xyXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBwcmljZSBoaXN0b3J5IGZyb20gY2FjaGUnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHByaWNlIGhpc3RvcnkgZnJvbSBjYWNoZTonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2V0UHJpY2VIaXN0b3J5KHV1aWQ6IHN0cmluZywgcHJpY2VIaXN0b3J5OiBQcmljZUhpc3RvcnkpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuUFJJQ0VfSElTVE9SWSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgY2FjaGVFbnRyeTogQ2FjaGVFbnRyeTxQcmljZUhpc3Rvcnk+ID0ge1xyXG4gICAgICAgIGRhdGE6IHByaWNlSGlzdG9yeSxcclxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgZXhwaXJlc0F0OiBEYXRlLm5vdygpICsgQ0FDSEVfRVhQSVJZLlBSSUNFX0hJU1RPUlksXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUucHV0KHsgdXVpZCwgLi4uY2FjaGVFbnRyeSB9KTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGNhY2hlIHByaWNlIGhpc3RvcnknKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FjaGluZyBwcmljZSBoaXN0b3J5OicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyByZW1vdmVQcmljZUhpc3RvcnkodXVpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuZ2V0U3RvcmUoU1RPUkVTLlBSSUNFX0hJU1RPUlksICdyZWFkd3JpdGUnKTtcclxuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmRlbGV0ZSh1dWlkKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHJlbW92ZSBwcmljZSBoaXN0b3J5JykpO1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHByaWNlIGhpc3Rvcnk6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2FyZCBNYXBwaW5nIENhY2hlIE1ldGhvZHNcclxuICBhc3luYyBnZXRDYXJkTWFwcGluZyhzY3J5ZmFsbElkOiBzdHJpbmcpOiBQcm9taXNlPE1UR0pTT05DYXJkIHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RvcmUgPSBhd2FpdCB0aGlzLmdldFN0b3JlKFNUT1JFUy5DQVJEX01BUFBJTkdTKTtcclxuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldChzY3J5ZmFsbElkKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXF1ZXN0LnJlc3VsdCBhcyBDYWNoZUVudHJ5PE1UR0pTT05DYXJkPiB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENoZWNrIGlmIGNhY2hlIGVudHJ5IGlzIGV4cGlyZWRcclxuICAgICAgICAgIGlmIChEYXRlLm5vdygpID4gcmVzdWx0LmV4cGlyZXNBdCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNhcmRNYXBwaW5nKHNjcnlmYWxsSWQpO1xyXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBjYXJkIG1hcHBpbmcgZnJvbSBjYWNoZScpKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY2FyZCBtYXBwaW5nIGZyb20gY2FjaGU6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHNldENhcmRNYXBwaW5nKHNjcnlmYWxsSWQ6IHN0cmluZywgbXRnanNvbkNhcmQ6IE1UR0pTT05DYXJkKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuZ2V0U3RvcmUoU1RPUkVTLkNBUkRfTUFQUElOR1MsICdyZWFkd3JpdGUnKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGNhY2hlRW50cnk6IENhY2hlRW50cnk8TVRHSlNPTkNhcmQ+ID0ge1xyXG4gICAgICAgIGRhdGE6IG10Z2pzb25DYXJkLFxyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICBleHBpcmVzQXQ6IERhdGUubm93KCkgKyBDQUNIRV9FWFBJUlkuQ0FSRF9NQVBQSU5HUyxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoeyBzY3J5ZmFsbElkLCAuLi5jYWNoZUVudHJ5IH0pO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gY2FjaGUgY2FyZCBtYXBwaW5nJykpO1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhY2hpbmcgY2FyZCBtYXBwaW5nOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyByZW1vdmVDYXJkTWFwcGluZyhzY3J5ZmFsbElkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuQ0FSRF9NQVBQSU5HUywgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZGVsZXRlKHNjcnlmYWxsSWQpO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVtb3ZlIGNhcmQgbWFwcGluZycpKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBjYXJkIG1hcHBpbmc6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTWV0YWRhdGEgTWV0aG9kc1xyXG4gIGFzeW5jIGdldE1ldGFkYXRhKCk6IFByb21pc2U8Q2FjaGVNZXRhZGF0YSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuTUVUQURBVEEpO1xyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KCdtZXRhZGF0YScpO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlcXVlc3QucmVzdWx0IGFzIENhY2hlRW50cnk8Q2FjaGVNZXRhZGF0YT4gfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDaGVjayBpZiBtZXRhZGF0YSBpcyBleHBpcmVkXHJcbiAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IHJlc3VsdC5leHBpcmVzQXQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRNZXRhZGF0YSh7XHJcbiAgICAgICAgICAgICAgbGFzdFByaWNlVXBkYXRlOiAnJyxcclxuICAgICAgICAgICAgICB0b3RhbENhcmRzOiAwLFxyXG4gICAgICAgICAgICAgIGNhY2hlVmVyc2lvbjogJzEuMCcsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBtZXRhZGF0YSBmcm9tIGNhY2hlJykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBtZXRhZGF0YSBmcm9tIGNhY2hlOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzZXRNZXRhZGF0YShtZXRhZGF0YTogQ2FjaGVNZXRhZGF0YSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RvcmUgPSBhd2FpdCB0aGlzLmdldFN0b3JlKFNUT1JFUy5NRVRBREFUQSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgY2FjaGVFbnRyeTogQ2FjaGVFbnRyeTxDYWNoZU1ldGFkYXRhPiA9IHtcclxuICAgICAgICBkYXRhOiBtZXRhZGF0YSxcclxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgZXhwaXJlc0F0OiBEYXRlLm5vdygpICsgQ0FDSEVfRVhQSVJZLk1FVEFEQVRBLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLnB1dCh7IGtleTogJ21ldGFkYXRhJywgLi4uY2FjaGVFbnRyeSB9KTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGNhY2hlIG1ldGFkYXRhJykpO1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhY2hpbmcgbWV0YWRhdGE6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJ1bGsgT3BlcmF0aW9uc1xyXG4gIGFzeW5jIGJhdGNoU2V0UHJpY2VIaXN0b3JpZXMocHJpY2VIaXN0b3JpZXM6IEFycmF5PHsgdXVpZDogc3RyaW5nOyBkYXRhOiBQcmljZUhpc3RvcnkgfT4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShTVE9SRVMuUFJJQ0VfSElTVE9SWSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHN0b3JlLnRyYW5zYWN0aW9uO1xyXG5cclxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBwcmljZUhpc3Rvcmllcy5tYXAoKHsgdXVpZCwgZGF0YSB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2FjaGVFbnRyeTogQ2FjaGVFbnRyeTxQcmljZUhpc3Rvcnk+ID0ge1xyXG4gICAgICAgICAgZGF0YSxcclxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIGV4cGlyZXNBdDogRGF0ZS5ub3coKSArIENBQ0hFX0VYUElSWS5QUklDRV9ISVNUT1JZLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoeyB1dWlkLCAuLi5jYWNoZUVudHJ5IH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gY2FjaGUgcHJpY2UgaGlzdG9yeSBmb3IgJHt1dWlkfWApKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0JhdGNoIHByaWNlIGhpc3RvcnkgY2FjaGluZyBmYWlsZWQnKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYmF0Y2ggY2FjaGluZyBwcmljZSBoaXN0b3JpZXM6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENhY2hlIE1hbmFnZW1lbnRcclxuICBhc3luYyBjbGVhckV4cGlyZWRFbnRyaWVzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgY29uc3Qgc3RvcmVzID0gW1NUT1JFUy5QUklDRV9ISVNUT1JZLCBTVE9SRVMuQ0FSRF9NQVBQSU5HUywgU1RPUkVTLk1FVEFEQVRBXTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgc3RvcmVOYW1lIG9mIHN0b3Jlcykge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRTdG9yZShzdG9yZU5hbWUsICdyZWFkd3JpdGUnKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUub3BlbkN1cnNvcigpO1xyXG5cclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVxdWVzdC5yZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcclxuICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGN1cnNvci52YWx1ZSBhcyBDYWNoZUVudHJ5PGFueT47XHJcbiAgICAgICAgICAgICAgaWYgKG5vdyA+IGVudHJ5LmV4cGlyZXNBdCkge1xyXG4gICAgICAgICAgICAgICAgY3Vyc29yLmRlbGV0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gY2xlYXIgZXhwaXJlZCBlbnRyaWVzIGZyb20gJHtzdG9yZU5hbWV9YCkpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2xlYXJpbmcgZXhwaXJlZCBjYWNoZSBlbnRyaWVzOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGNsZWFyQWxsQ2FjaGUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdG9yZXMgPSBbU1RPUkVTLlBSSUNFX0hJU1RPUlksIFNUT1JFUy5DQVJEX01BUFBJTkdTLCBTVE9SRVMuTUVUQURBVEFdO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBzdG9yZU5hbWUgb2Ygc3RvcmVzKSB7XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBhd2FpdCB0aGlzLmdldFN0b3JlKHN0b3JlTmFtZSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5jbGVhcigpO1xyXG5cclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBjbGVhciAke3N0b3JlTmFtZX1gKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFyaW5nIGNhY2hlOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDYWNoZVN0YXRzKCk6IFByb21pc2U8e1xyXG4gICAgcHJpY2VIaXN0b3J5Q291bnQ6IG51bWJlcjtcclxuICAgIGNhcmRNYXBwaW5nQ291bnQ6IG51bWJlcjtcclxuICAgIHRvdGFsU2l6ZTogbnVtYmVyO1xyXG4gICAgbGFzdENsZWFudXA6IERhdGUgfCBudWxsO1xyXG4gIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IFtwcmljZUNvdW50LCBtYXBwaW5nQ291bnRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgIHRoaXMuZ2V0U3RvcmVDb3VudChTVE9SRVMuUFJJQ0VfSElTVE9SWSksXHJcbiAgICAgICAgdGhpcy5nZXRTdG9yZUNvdW50KFNUT1JFUy5DQVJEX01BUFBJTkdTKSxcclxuICAgICAgXSk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHByaWNlSGlzdG9yeUNvdW50OiBwcmljZUNvdW50LFxyXG4gICAgICAgIGNhcmRNYXBwaW5nQ291bnQ6IG1hcHBpbmdDb3VudCxcclxuICAgICAgICB0b3RhbFNpemU6IDAsIC8vIEluZGV4ZWREQiBkb2Vzbid0IHByb3ZpZGUgZWFzeSBzaXplIGNhbGN1bGF0aW9uXHJcbiAgICAgICAgbGFzdENsZWFudXA6IG51bGwsIC8vIFdvdWxkIG5lZWQgdG8gdHJhY2sgdGhpcyBzZXBhcmF0ZWx5XHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGNhY2hlIHN0YXRzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwcmljZUhpc3RvcnlDb3VudDogMCxcclxuICAgICAgICBjYXJkTWFwcGluZ0NvdW50OiAwLFxyXG4gICAgICAgIHRvdGFsU2l6ZTogMCxcclxuICAgICAgICBsYXN0Q2xlYW51cDogbnVsbCxcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0U3RvcmVDb3VudChzdG9yZU5hbWU6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuZ2V0U3RvcmUoc3RvcmVOYW1lKTtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5jb3VudCgpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCk7XHJcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgY291bnQgZm9yICR7c3RvcmVOYW1lfWApKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2xlYW51cFxyXG4gIGFzeW5jIGNsb3NlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKHRoaXMuZGIpIHtcclxuICAgICAgdGhpcy5kYi5jbG9zZSgpO1xyXG4gICAgICB0aGlzLmRiID0gbnVsbDtcclxuICAgICAgdGhpcy5pbml0UHJvbWlzZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBtdGdqc29uQ2FjaGUgPSBuZXcgTVRHSlNPTkNhY2hlKCk7XHJcblxyXG4vLyBJbml0aWFsaXplIGNhY2hlIG9uIGltcG9ydCAoY2xpZW50LXNpZGUgb25seSlcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbXRnanNvbkNhY2hlLmluaXQoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICBcclxuICAvLyBDbGVhbiB1cCBleHBpcmVkIGVudHJpZXMgb24gcGFnZSBsb2FkXHJcbiAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICBtdGdqc29uQ2FjaGUuY2xlYXJFeHBpcmVkRW50cmllcygpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gIH0sIDUwMDApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtdGdqc29uQ2FjaGU7XHJcbiJdLCJuYW1lcyI6WyJEQl9OQU1FIiwiREJfVkVSU0lPTiIsIlNUT1JFUyIsIlBSSUNFX0hJU1RPUlkiLCJDQVJEX01BUFBJTkdTIiwiTUVUQURBVEEiLCJDQUNIRV9FWFBJUlkiLCJNVEdKU09OQ2FjaGUiLCJpbml0IiwiZGIiLCJpbml0UHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiRXJyb3IiLCJyZXF1ZXN0IiwiaW5kZXhlZERCIiwib3BlbiIsIm9uZXJyb3IiLCJvbnN1Y2Nlc3MiLCJyZXN1bHQiLCJvbnVwZ3JhZGVuZWVkZWQiLCJldmVudCIsInRhcmdldCIsIm9iamVjdFN0b3JlTmFtZXMiLCJjb250YWlucyIsInByaWNlU3RvcmUiLCJjcmVhdGVPYmplY3RTdG9yZSIsImtleVBhdGgiLCJjcmVhdGVJbmRleCIsInVuaXF1ZSIsIm1hcHBpbmdTdG9yZSIsImdldFN0b3JlIiwic3RvcmVOYW1lIiwibW9kZSIsInRyYW5zYWN0aW9uIiwib2JqZWN0U3RvcmUiLCJnZXRQcmljZUhpc3RvcnkiLCJ1dWlkIiwic3RvcmUiLCJnZXQiLCJEYXRlIiwibm93IiwiZXhwaXJlc0F0IiwicmVtb3ZlUHJpY2VIaXN0b3J5IiwiZGF0YSIsImVycm9yIiwiY29uc29sZSIsInNldFByaWNlSGlzdG9yeSIsInByaWNlSGlzdG9yeSIsImNhY2hlRW50cnkiLCJ0aW1lc3RhbXAiLCJwdXQiLCJkZWxldGUiLCJnZXRDYXJkTWFwcGluZyIsInNjcnlmYWxsSWQiLCJyZW1vdmVDYXJkTWFwcGluZyIsInNldENhcmRNYXBwaW5nIiwibXRnanNvbkNhcmQiLCJnZXRNZXRhZGF0YSIsInNldE1ldGFkYXRhIiwibGFzdFByaWNlVXBkYXRlIiwidG90YWxDYXJkcyIsImNhY2hlVmVyc2lvbiIsIm1ldGFkYXRhIiwia2V5IiwiYmF0Y2hTZXRQcmljZUhpc3RvcmllcyIsInByaWNlSGlzdG9yaWVzIiwicHJvbWlzZXMiLCJtYXAiLCJhbGwiLCJvbmNvbXBsZXRlIiwiY2xlYXJFeHBpcmVkRW50cmllcyIsInN0b3JlcyIsIm9wZW5DdXJzb3IiLCJjdXJzb3IiLCJlbnRyeSIsInZhbHVlIiwiY29udGludWUiLCJjbGVhckFsbENhY2hlIiwiY2xlYXIiLCJnZXRDYWNoZVN0YXRzIiwicHJpY2VDb3VudCIsIm1hcHBpbmdDb3VudCIsImdldFN0b3JlQ291bnQiLCJwcmljZUhpc3RvcnlDb3VudCIsImNhcmRNYXBwaW5nQ291bnQiLCJ0b3RhbFNpemUiLCJsYXN0Q2xlYW51cCIsImNvdW50IiwiY2xvc2UiLCJtdGdqc29uQ2FjaGUiLCJjYXRjaCIsInNldFRpbWVvdXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/utils/mtgjsonCache.ts\n"));

/***/ })

}]);