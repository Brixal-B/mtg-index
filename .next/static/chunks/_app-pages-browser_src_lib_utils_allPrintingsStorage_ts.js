"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_utils_allPrintingsStorage_ts"],{

/***/ "(app-pages-browser)/./src/lib/utils/allPrintingsStorage.ts":
/*!**********************************************!*\
  !*** ./src/lib/utils/allPrintingsStorage.ts ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allPrintingsStorage: () => (/* binding */ allPrintingsStorage)\n/* harmony export */ });\n/**\r\n * Optimized storage solution for MTGJSON AllPrintings.json data\r\n * Handles the large (~200MB) dataset efficiently using IndexedDB with compression\r\n */ class AllPrintingsStorage {\n    /**\r\n   * Store AllPrintings data in compressed chunks\r\n   */ async storeAllPrintings(allPrintingsData) {\n        console.log('Starting AllPrintings storage process...');\n        try {\n            const metadata = {\n                version: allPrintingsData.meta.version,\n                date: allPrintingsData.meta.date,\n                totalSets: 0,\n                totalCards: 0,\n                chunks: [],\n                lastUpdated: new Date().toISOString()\n            };\n            const chunks = [];\n            // Process each set\n            for (const [setCode, setData] of Object.entries(allPrintingsData.data)){\n                const cards = setData.cards || [];\n                metadata.totalSets++;\n                metadata.totalCards += cards.length;\n                // Split large sets into chunks\n                for(let i = 0; i < cards.length; i += this.CHUNK_SIZE){\n                    const chunkCards = cards.slice(i, i + this.CHUNK_SIZE);\n                    const chunkId = \"\".concat(setCode, \"-\").concat(Math.floor(i / this.CHUNK_SIZE));\n                    // Extract only necessary data for mapping\n                    const optimizedCards = chunkCards.map((card)=>({\n                            uuid: card.uuid,\n                            name: card.name,\n                            setCode: card.setCode || setCode,\n                            number: card.number,\n                            rarity: card.rarity,\n                            identifiers: card.identifiers ? {\n                                scryfallId: card.identifiers.scryfallId,\n                                multiverseId: card.identifiers.multiverseId\n                            } : undefined\n                        }));\n                    // Compress the data\n                    const compressed = await this.compressData(optimizedCards);\n                    const chunk = {\n                        id: chunkId,\n                        setCode,\n                        compressedData: compressed,\n                        uncompressedSize: JSON.stringify(optimizedCards).length,\n                        cardCount: optimizedCards.length,\n                        lastUpdated: new Date().toISOString()\n                    };\n                    chunks.push(chunk);\n                    metadata.chunks.push(chunkId);\n                }\n            }\n            // Store chunks in batches to avoid overwhelming IndexedDB\n            console.log(\"Storing \".concat(chunks.length, \" chunks...\"));\n            await this.storeChunksInBatches(chunks);\n            // Store metadata\n            await this.storeMetadata(metadata);\n            console.log(\"Successfully stored AllPrintings data: \".concat(metadata.totalCards, \" cards in \").concat(metadata.totalSets, \" sets\"));\n        } catch (error) {\n            console.error('Failed to store AllPrintings data:', error);\n            // Clean up any partially stored data on failure\n            try {\n                await this.clearAllData();\n                console.log('Cleaned up partially stored data due to error');\n            } catch (cleanupError) {\n                console.error('Failed to cleanup after storage error:', cleanupError);\n            }\n            throw error;\n        }\n    }\n    /**\r\n   * Retrieve specific set data\r\n   */ async getSetData(setCode) {\n        try {\n            const metadata = await this.getMetadata();\n            if (!metadata) {\n                throw new Error('AllPrintings metadata not found');\n            }\n            const setChunks = metadata.chunks.filter((chunkId)=>chunkId.startsWith(setCode));\n            const cards = [];\n            for (const chunkId of setChunks){\n                const chunk = await this.getChunk(chunkId);\n                if (chunk) {\n                    const decompressed = await this.decompressData(chunk.compressedData);\n                    cards.push(...decompressed);\n                }\n            }\n            return cards;\n        } catch (error) {\n            console.error(\"Failed to get set data for \".concat(setCode, \":\"), error);\n            return [];\n        }\n    }\n    /**\r\n   * Search for cards across all sets\r\n   */ async searchCards(searchTerm) {\n        let maxResults = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50;\n        try {\n            const metadata = await this.getMetadata();\n            if (!metadata) return [];\n            const results = [];\n            const normalizedSearch = searchTerm.toLowerCase();\n            // Search through chunks until we have enough results\n            for (const chunkId of metadata.chunks){\n                if (results.length >= maxResults) break;\n                const chunk = await this.getChunk(chunkId);\n                if (!chunk) continue;\n                const cards = await this.decompressData(chunk.compressedData);\n                for (const card of cards){\n                    if (results.length >= maxResults) break;\n                    if (card.name.toLowerCase().includes(normalizedSearch)) {\n                        results.push(card);\n                    }\n                }\n            }\n            return results;\n        } catch (error) {\n            console.error('Failed to search cards:', error);\n            return [];\n        }\n    }\n    /**\r\n   * Find card by Scryfall ID\r\n   */ async findCardByScryfallId(scryfallId) {\n        try {\n            const metadata = await this.getMetadata();\n            if (!metadata) return null;\n            // Search through all chunks\n            for (const chunkId of metadata.chunks){\n                const chunk = await this.getChunk(chunkId);\n                if (!chunk) continue;\n                const cards = await this.decompressData(chunk.compressedData);\n                for (const card of cards){\n                    var _card_identifiers;\n                    if (((_card_identifiers = card.identifiers) === null || _card_identifiers === void 0 ? void 0 : _card_identifiers.scryfallId) === scryfallId) {\n                        return card;\n                    }\n                }\n            }\n            return null;\n        } catch (error) {\n            console.error('Failed to find card by Scryfall ID:', error);\n            return null;\n        }\n    }\n    /**\r\n   * Get storage statistics\r\n   */ async getStorageStats() {\n        try {\n            const metadata = await this.getMetadata();\n            if (!metadata) return null;\n            return {\n                totalSets: metadata.totalSets,\n                totalCards: metadata.totalCards,\n                totalChunks: metadata.chunks.length,\n                lastUpdated: metadata.lastUpdated,\n                version: metadata.version\n            };\n        } catch (error) {\n            console.error('Failed to get storage stats:', error);\n            return null;\n        }\n    }\n    /**\r\n   * Clear all stored data\r\n   */ async clearAllData() {\n        try {\n            // Clear IndexedDB data\n            const metadata = await this.getMetadata();\n            if (metadata) {\n                // Remove all chunks\n                for (const chunkId of metadata.chunks){\n                    await this.removeChunk(chunkId);\n                }\n            }\n            // Remove metadata\n            await this.removeMetadata();\n            // Also clear any old localStorage data from previous versions\n            this.clearLegacyLocalStorageData();\n            console.log('All AllPrintings data cleared');\n        } catch (error) {\n            console.error('Failed to clear AllPrintings data:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Clear legacy localStorage data from previous versions\r\n   */ clearLegacyLocalStorageData() {\n        try {\n            // Clear old metadata\n            localStorage.removeItem('allprintings-metadata');\n            // Clear old chunks (scan for chunk- prefixed keys)\n            const keysToRemove = [];\n            for(let i = 0; i < localStorage.length; i++){\n                const key = localStorage.key(i);\n                if (key && key.startsWith('chunk-')) {\n                    keysToRemove.push(key);\n                }\n            }\n            keysToRemove.forEach((key)=>{\n                localStorage.removeItem(key);\n            });\n            if (keysToRemove.length > 0) {\n                console.log(\"Cleared \".concat(keysToRemove.length, \" legacy localStorage chunks\"));\n            }\n        } catch (error) {\n            console.error('Failed to clear legacy localStorage data:', error);\n        }\n    }\n    /**\r\n   * Check if data exists and is fresh\r\n   */ async isDataAvailable() {\n        try {\n            const metadata = await this.getMetadata();\n            if (!metadata) return false;\n            // Check if data is less than 7 days old\n            const dataAge = Date.now() - new Date(metadata.lastUpdated).getTime();\n            const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days\n            return dataAge < maxAge;\n        } catch (error) {\n            console.error('Failed to check data availability:', error);\n            return false;\n        }\n    }\n    // Private helper methods\n    async compressData(data) {\n        try {\n            // Simple compression using JSON stringify with reduced precision\n            const jsonString = JSON.stringify(data);\n            // Basic compression by removing unnecessary whitespace and using shorter keys\n            const compressed = jsonString.replace(/\\s+/g, '').replace(/\"uuid\":/g, '\"u\":').replace(/\"name\":/g, '\"n\":').replace(/\"setCode\":/g, '\"s\":').replace(/\"number\":/g, '\"#\":').replace(/\"rarity\":/g, '\"r\":').replace(/\"identifiers\":/g, '\"i\":').replace(/\"scryfallId\":/g, '\"si\":').replace(/\"multiverseId\":/g, '\"mi\":');\n            // Try different encoding approaches\n            try {\n                // Method 1: Use TextEncoder for proper Unicode handling\n                const encoder = new TextEncoder();\n                const uint8Array = encoder.encode(compressed);\n                // Convert to base64 using proper binary handling\n                let binaryString = '';\n                for(let i = 0; i < uint8Array.length; i++){\n                    binaryString += String.fromCharCode(uint8Array[i]);\n                }\n                return btoa(binaryString);\n            } catch (encodingError) {\n                console.warn('TextEncoder method failed, trying fallback:', encodingError);\n                // Method 2: Fallback - escape Unicode characters first\n                const escapedCompressed = compressed.replace(/[\\u0080-\\uFFFF]/g, (match)=>{\n                    return '\\\\u' + ('0000' + match.charCodeAt(0).toString(16)).substr(-4);\n                });\n                return btoa(escapedCompressed);\n            }\n        } catch (error) {\n            console.error('Failed to compress data with all methods:', error);\n            // Method 3: Last resort - store uncompressed but with key shortening\n            const jsonString = JSON.stringify(data);\n            const shortened = jsonString.replace(/\"uuid\":/g, '\"u\":').replace(/\"name\":/g, '\"n\":').replace(/\"setCode\":/g, '\"s\":').replace(/\"number\":/g, '\"#\":').replace(/\"rarity\":/g, '\"r\":');\n            // Mark as uncompressed with a prefix\n            return 'UNCOMPRESSED:' + shortened;\n        }\n    }\n    async decompressData(compressedData) {\n        try {\n            let decoded;\n            // Check if data is uncompressed (fallback method)\n            if (compressedData.startsWith('UNCOMPRESSED:')) {\n                decoded = compressedData.substring('UNCOMPRESSED:'.length);\n            } else {\n                // Try different decoding approaches\n                try {\n                    // Method 1: Use TextDecoder for proper Unicode handling\n                    const binaryString = atob(compressedData);\n                    // Convert binary string back to Uint8Array\n                    const uint8Array = new Uint8Array(binaryString.length);\n                    for(let i = 0; i < binaryString.length; i++){\n                        uint8Array[i] = binaryString.charCodeAt(i);\n                    }\n                    // Use TextDecoder to handle Unicode characters properly\n                    const decoder = new TextDecoder();\n                    decoded = decoder.decode(uint8Array);\n                } catch (decodingError) {\n                    console.warn('TextDecoder method failed, trying fallback:', decodingError);\n                    // Method 2: Fallback - simple atob and unescape Unicode\n                    decoded = atob(compressedData);\n                    // Unescape Unicode characters\n                    decoded = decoded.replace(/\\\\u([0-9a-fA-F]{4})/g, (match, hex)=>{\n                        return String.fromCharCode(parseInt(hex, 16));\n                    });\n                }\n            }\n            // Expand the shortened keys back to original\n            const expanded = decoded.replace(/\"u\":/g, '\"uuid\":').replace(/\"n\":/g, '\"name\":').replace(/\"s\":/g, '\"setCode\":').replace(/\"#\":/g, '\"number\":').replace(/\"r\":/g, '\"rarity\":').replace(/\"i\":/g, '\"identifiers\":').replace(/\"si\":/g, '\"scryfallId\":').replace(/\"mi\":/g, '\"multiverseId\":');\n            return JSON.parse(expanded);\n        } catch (error) {\n            console.error('Failed to decompress data with all methods:', error);\n            throw error;\n        }\n    }\n    async storeChunksInBatches(chunks) {\n        const batchSize = 10;\n        for(let i = 0; i < chunks.length; i += batchSize){\n            const batch = chunks.slice(i, i + batchSize);\n            const batchPromises = batch.map((chunk)=>this.storeChunk(chunk));\n            await Promise.all(batchPromises);\n            // Small delay to avoid overwhelming IndexedDB\n            await new Promise((resolve)=>setTimeout(resolve, 10));\n            // Progress logging\n            if (i % 100 === 0) {\n                console.log(\"Stored \".concat(Math.min(i + batchSize, chunks.length), \" / \").concat(chunks.length, \" chunks\"));\n            }\n        }\n    }\n    async storeChunk(chunk) {\n        return new Promise(async (resolve, reject)=>{\n            try {\n                const db = await this.openIndexedDB();\n                const transaction = db.transaction([\n                    'chunks'\n                ], 'readwrite');\n                const store = transaction.objectStore('chunks');\n                const request = store.put(chunk, chunk.id);\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(request.error);\n            } catch (error) {\n                console.error(\"Failed to store chunk \".concat(chunk.id, \":\"), error);\n                reject(error);\n            }\n        });\n    }\n    async getChunk(chunkId) {\n        return new Promise(async (resolve, reject)=>{\n            try {\n                const db = await this.openIndexedDB();\n                const transaction = db.transaction([\n                    'chunks'\n                ], 'readonly');\n                const store = transaction.objectStore('chunks');\n                const request = store.get(chunkId);\n                request.onsuccess = ()=>resolve(request.result || null);\n                request.onerror = ()=>reject(request.error);\n            } catch (error) {\n                console.error(\"Failed to get chunk \".concat(chunkId, \":\"), error);\n                resolve(null);\n            }\n        });\n    }\n    async removeChunk(chunkId) {\n        return new Promise(async (resolve, reject)=>{\n            try {\n                const db = await this.openIndexedDB();\n                const transaction = db.transaction([\n                    'chunks'\n                ], 'readwrite');\n                const store = transaction.objectStore('chunks');\n                const request = store.delete(chunkId);\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(request.error);\n            } catch (error) {\n                console.error(\"Failed to remove chunk \".concat(chunkId, \":\"), error);\n                resolve(); // Don't fail the entire operation for cleanup errors\n            }\n        });\n    }\n    async storeMetadata(metadata) {\n        return new Promise(async (resolve, reject)=>{\n            try {\n                const db = await this.openIndexedDB();\n                const transaction = db.transaction([\n                    'metadata'\n                ], 'readwrite');\n                const store = transaction.objectStore('metadata');\n                const request = store.put(metadata, 'allprintings-metadata');\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(request.error);\n            } catch (error) {\n                console.error('Failed to store metadata:', error);\n                reject(error);\n            }\n        });\n    }\n    async getMetadata() {\n        return new Promise(async (resolve, reject)=>{\n            try {\n                const db = await this.openIndexedDB();\n                const transaction = db.transaction([\n                    'metadata'\n                ], 'readonly');\n                const store = transaction.objectStore('metadata');\n                const request = store.get('allprintings-metadata');\n                request.onsuccess = ()=>resolve(request.result || null);\n                request.onerror = ()=>reject(request.error);\n            } catch (error) {\n                console.error('Failed to get metadata:', error);\n                resolve(null);\n            }\n        });\n    }\n    async removeMetadata() {\n        return new Promise(async (resolve, reject)=>{\n            try {\n                const db = await this.openIndexedDB();\n                const transaction = db.transaction([\n                    'metadata'\n                ], 'readwrite');\n                const store = transaction.objectStore('metadata');\n                const request = store.delete('allprintings-metadata');\n                request.onsuccess = ()=>resolve();\n                request.onerror = ()=>reject(request.error);\n            } catch (error) {\n                console.error('Failed to remove metadata:', error);\n                resolve(); // Don't fail for cleanup errors\n            }\n        });\n    }\n    async openIndexedDB() {\n        if (this.dbPromise) {\n            return this.dbPromise;\n        }\n        this.dbPromise = new Promise((resolve, reject)=>{\n            const request = indexedDB.open('MTGJSONStorage', 1);\n            request.onerror = ()=>{\n                reject(new Error('Failed to open IndexedDB'));\n            };\n            request.onsuccess = ()=>{\n                resolve(request.result);\n            };\n            request.onupgradeneeded = (event)=>{\n                const db = event.target.result;\n                // Create object stores\n                if (!db.objectStoreNames.contains('chunks')) {\n                    db.createObjectStore('chunks');\n                }\n                if (!db.objectStoreNames.contains('metadata')) {\n                    db.createObjectStore('metadata');\n                }\n            };\n        });\n        return this.dbPromise;\n    }\n    constructor(){\n        this.CHUNK_SIZE = 50; // Cards per chunk\n        this.METADATA_KEY = 'allprintings-metadata';\n        this.CHUNK_PREFIX = 'chunk-';\n        // IndexedDB helper methods\n        this.dbPromise = null;\n    }\n}\n// Export singleton instance\nconst allPrintingsStorage = new AllPrintingsStorage();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdXRpbHMvYWxsUHJpbnRpbmdzU3RvcmFnZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7OztDQUdDLEdBa0NELE1BQU1BO0lBS0o7O0dBRUMsR0FDRCxNQUFNQyxrQkFBa0JDLGdCQUFxQixFQUFpQjtRQUM1REMsUUFBUUMsR0FBRyxDQUFDO1FBRVosSUFBSTtZQUNGLE1BQU1DLFdBQWlDO2dCQUNyQ0MsU0FBU0osaUJBQWlCSyxJQUFJLENBQUNELE9BQU87Z0JBQ3RDRSxNQUFNTixpQkFBaUJLLElBQUksQ0FBQ0MsSUFBSTtnQkFDaENDLFdBQVc7Z0JBQ1hDLFlBQVk7Z0JBQ1pDLFFBQVEsRUFBRTtnQkFDVkMsYUFBYSxJQUFJQyxPQUFPQyxXQUFXO1lBQ3JDO1lBRUEsTUFBTUgsU0FBNEIsRUFBRTtZQUVwQyxtQkFBbUI7WUFDbkIsS0FBSyxNQUFNLENBQUNJLFNBQVNDLFFBQVEsSUFBSUMsT0FBT0MsT0FBTyxDQUFDaEIsaUJBQWlCaUIsSUFBSSxFQUEwQjtnQkFDN0YsTUFBTUMsUUFBUUosUUFBUUksS0FBSyxJQUFJLEVBQUU7Z0JBQ2pDZixTQUFTSSxTQUFTO2dCQUNsQkosU0FBU0ssVUFBVSxJQUFJVSxNQUFNQyxNQUFNO2dCQUVuQywrQkFBK0I7Z0JBQy9CLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixNQUFNQyxNQUFNLEVBQUVDLEtBQUssSUFBSSxDQUFDQyxVQUFVLENBQUU7b0JBQ3RELE1BQU1DLGFBQWFKLE1BQU1LLEtBQUssQ0FBQ0gsR0FBR0EsSUFBSSxJQUFJLENBQUNDLFVBQVU7b0JBQ3JELE1BQU1HLFVBQVUsR0FBY0MsT0FBWFosU0FBUSxLQUFtQyxPQUFoQ1ksS0FBS0MsS0FBSyxDQUFDTixJQUFJLElBQUksQ0FBQ0MsVUFBVTtvQkFFNUQsMENBQTBDO29CQUMxQyxNQUFNTSxpQkFBZ0NMLFdBQVdNLEdBQUcsQ0FBQyxDQUFDQyxPQUFlOzRCQUNuRUMsTUFBTUQsS0FBS0MsSUFB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QUM7Z0JBQ3ZCO2dCQUVBLElBQUksQ0FBQ3BCLEdBQUdrQixnQkFBZ0IsQ0FBQ0MsUUFBUSxDQUFDLGFBQWE7b0JBQzdDbkIsR0FBR29CLGlCQUFpQixDQUFDO2dCQUN2QjtZQUNGO1FBQ0Y7UUFFQSxPQUFPLElBQUksQ0FBQ1IsU0FBUztJQUN2Qjs7YUFwaUJpQnBILGFBQWEsSUFBSSxrQkFBa0I7YUFDbkM2SCxlQUFlO2FBQ2ZDLGVBQWU7UUFnZ0JoQywyQkFBMkI7YUFDbkJWLFlBQXlDOztBQWtDbkQ7QUFFQSw0QkFBNEI7QUFDckIsTUFBTVcsc0JBQXNCLElBQUl0SixzQkFBc0IiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcbXRnLWluZGV4XFxzcmNcXGxpYlxcdXRpbHNcXGFsbFByaW50aW5nc1N0b3JhZ2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIE9wdGltaXplZCBzdG9yYWdlIHNvbHV0aW9uIGZvciBNVEdKU09OIEFsbFByaW50aW5ncy5qc29uIGRhdGFcclxuICogSGFuZGxlcyB0aGUgbGFyZ2UgKH4yMDBNQikgZGF0YXNldCBlZmZpY2llbnRseSB1c2luZyBJbmRleGVkREIgd2l0aCBjb21wcmVzc2lvblxyXG4gKi9cclxuXHJcbmltcG9ydCB7IG10Z2pzb25DYWNoZSB9IGZyb20gJy4vbXRnanNvbkNhY2hlJztcclxuXHJcbmludGVyZmFjZSBDb21wcmVzc2VkQ2h1bmsge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgc2V0Q29kZTogc3RyaW5nO1xyXG4gIGNvbXByZXNzZWREYXRhOiBzdHJpbmc7XHJcbiAgdW5jb21wcmVzc2VkU2l6ZTogbnVtYmVyO1xyXG4gIGNhcmRDb3VudDogbnVtYmVyO1xyXG4gIGxhc3RVcGRhdGVkOiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBBbGxQcmludGluZ3NNZXRhZGF0YSB7XHJcbiAgdmVyc2lvbjogc3RyaW5nO1xyXG4gIGRhdGU6IHN0cmluZztcclxuICB0b3RhbFNldHM6IG51bWJlcjtcclxuICB0b3RhbENhcmRzOiBudW1iZXI7XHJcbiAgY2h1bmtzOiBzdHJpbmdbXTtcclxuICBsYXN0VXBkYXRlZDogc3RyaW5nO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU2V0Q2FyZERhdGEge1xyXG4gIHV1aWQ6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgc2V0Q29kZTogc3RyaW5nO1xyXG4gIG51bWJlcjogc3RyaW5nO1xyXG4gIHJhcml0eTogc3RyaW5nO1xyXG4gIGlkZW50aWZpZXJzPzoge1xyXG4gICAgc2NyeWZhbGxJZD86IHN0cmluZztcclxuICAgIG11bHRpdmVyc2VJZD86IG51bWJlcjtcclxuICB9O1xyXG59XHJcblxyXG5jbGFzcyBBbGxQcmludGluZ3NTdG9yYWdlIHtcclxuICBwcml2YXRlIHJlYWRvbmx5IENIVU5LX1NJWkUgPSA1MDsgLy8gQ2FyZHMgcGVyIGNodW5rXHJcbiAgcHJpdmF0ZSByZWFkb25seSBNRVRBREFUQV9LRVkgPSAnYWxscHJpbnRpbmdzLW1ldGFkYXRhJztcclxuICBwcml2YXRlIHJlYWRvbmx5IENIVU5LX1BSRUZJWCA9ICdjaHVuay0nO1xyXG5cclxuICAvKipcclxuICAgKiBTdG9yZSBBbGxQcmludGluZ3MgZGF0YSBpbiBjb21wcmVzc2VkIGNodW5rc1xyXG4gICAqL1xyXG4gIGFzeW5jIHN0b3JlQWxsUHJpbnRpbmdzKGFsbFByaW50aW5nc0RhdGE6IGFueSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIEFsbFByaW50aW5ncyBzdG9yYWdlIHByb2Nlc3MuLi4nKTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgbWV0YWRhdGE6IEFsbFByaW50aW5nc01ldGFkYXRhID0ge1xyXG4gICAgICAgIHZlcnNpb246IGFsbFByaW50aW5nc0RhdGEubWV0YS52ZXJzaW9uLFxyXG4gICAgICAgIGRhdGU6IGFsbFByaW50aW5nc0RhdGEubWV0YS5kYXRlLFxyXG4gICAgICAgIHRvdGFsU2V0czogMCxcclxuICAgICAgICB0b3RhbENhcmRzOiAwLFxyXG4gICAgICAgIGNodW5rczogW10sXHJcbiAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IGNodW5rczogQ29tcHJlc3NlZENodW5rW10gPSBbXTtcclxuICAgICAgXHJcbiAgICAgIC8vIFByb2Nlc3MgZWFjaCBzZXRcclxuICAgICAgZm9yIChjb25zdCBbc2V0Q29kZSwgc2V0RGF0YV0gb2YgT2JqZWN0LmVudHJpZXMoYWxsUHJpbnRpbmdzRGF0YS5kYXRhIGFzIFJlY29yZDxzdHJpbmcsIGFueT4pKSB7XHJcbiAgICAgICAgY29uc3QgY2FyZHMgPSBzZXREYXRhLmNhcmRzIHx8IFtdO1xyXG4gICAgICAgIG1ldGFkYXRhLnRvdGFsU2V0cysrO1xyXG4gICAgICAgIG1ldGFkYXRhLnRvdGFsQ2FyZHMgKz0gY2FyZHMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBTcGxpdCBsYXJnZSBzZXRzIGludG8gY2h1bmtzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXJkcy5sZW5ndGg7IGkgKz0gdGhpcy5DSFVOS19TSVpFKSB7XHJcbiAgICAgICAgICBjb25zdCBjaHVua0NhcmRzID0gY2FyZHMuc2xpY2UoaSwgaSArIHRoaXMuQ0hVTktfU0laRSk7XHJcbiAgICAgICAgICBjb25zdCBjaHVua0lkID0gYCR7c2V0Q29kZX0tJHtNYXRoLmZsb29yKGkgLyB0aGlzLkNIVU5LX1NJWkUpfWA7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEV4dHJhY3Qgb25seSBuZWNlc3NhcnkgZGF0YSBmb3IgbWFwcGluZ1xyXG4gICAgICAgICAgY29uc3Qgb3B0aW1pemVkQ2FyZHM6IFNldENhcmREYXRhW10gPSBjaHVua0NhcmRzLm1hcCgoY2FyZDogYW55KSA9PiAoe1xyXG4gICAgICAgICAgICB1dWlkOiBjYXJkLnV1aWQsXHJcbiAgICAgICAgICAgIG5hbWU6IGNhcmQubmFtZSxcclxuICAgICAgICAgICAgc2V0Q29kZTogY2FyZC5zZXRDb2RlIHx8IHNldENvZGUsXHJcbiAgICAgICAgICAgIG51bWJlcjogY2FyZC5udW1iZXIsXHJcbiAgICAgICAgICAgIHJhcml0eTogY2FyZC5yYXJpdHksXHJcbiAgICAgICAgICAgIGlkZW50aWZpZXJzOiBjYXJkLmlkZW50aWZpZXJzID8ge1xyXG4gICAgICAgICAgICAgIHNjcnlmYWxsSWQ6IGNhcmQuaWRlbnRpZmllcnMuc2NyeWZhbGxJZCxcclxuICAgICAgICAgICAgICBtdWx0aXZlcnNlSWQ6IGNhcmQuaWRlbnRpZmllcnMubXVsdGl2ZXJzZUlkLFxyXG4gICAgICAgICAgICB9IDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAgIC8vIENvbXByZXNzIHRoZSBkYXRhXHJcbiAgICAgICAgICBjb25zdCBjb21wcmVzc2VkID0gYXdhaXQgdGhpcy5jb21wcmVzc0RhdGEob3B0aW1pemVkQ2FyZHMpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCBjaHVuazogQ29tcHJlc3NlZENodW5rID0ge1xyXG4gICAgICAgICAgICBpZDogY2h1bmtJZCxcclxuICAgICAgICAgICAgc2V0Q29kZSxcclxuICAgICAgICAgICAgY29tcHJlc3NlZERhdGE6IGNvbXByZXNzZWQsXHJcbiAgICAgICAgICAgIHVuY29tcHJlc3NlZFNpemU6IEpTT04uc3RyaW5naWZ5KG9wdGltaXplZENhcmRzKS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGNhcmRDb3VudDogb3B0aW1pemVkQ2FyZHMubGVuZ3RoLFxyXG4gICAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XHJcbiAgICAgICAgICBtZXRhZGF0YS5jaHVua3MucHVzaChjaHVua0lkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFN0b3JlIGNodW5rcyBpbiBiYXRjaGVzIHRvIGF2b2lkIG92ZXJ3aGVsbWluZyBJbmRleGVkREJcclxuICAgICAgY29uc29sZS5sb2coYFN0b3JpbmcgJHtjaHVua3MubGVuZ3RofSBjaHVua3MuLi5gKTtcclxuICAgICAgYXdhaXQgdGhpcy5zdG9yZUNodW5rc0luQmF0Y2hlcyhjaHVua3MpO1xyXG4gICAgICBcclxuICAgICAgLy8gU3RvcmUgbWV0YWRhdGFcclxuICAgICAgYXdhaXQgdGhpcy5zdG9yZU1ldGFkYXRhKG1ldGFkYXRhKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgc3RvcmVkIEFsbFByaW50aW5ncyBkYXRhOiAke21ldGFkYXRhLnRvdGFsQ2FyZHN9IGNhcmRzIGluICR7bWV0YWRhdGEudG90YWxTZXRzfSBzZXRzYCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc3RvcmUgQWxsUHJpbnRpbmdzIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2xlYW4gdXAgYW55IHBhcnRpYWxseSBzdG9yZWQgZGF0YSBvbiBmYWlsdXJlXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5jbGVhckFsbERhdGEoKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnQ2xlYW5lZCB1cCBwYXJ0aWFsbHkgc3RvcmVkIGRhdGEgZHVlIHRvIGVycm9yJyk7XHJcbiAgICAgIH0gY2F0Y2ggKGNsZWFudXBFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjbGVhbnVwIGFmdGVyIHN0b3JhZ2UgZXJyb3I6JywgY2xlYW51cEVycm9yKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZSBzcGVjaWZpYyBzZXQgZGF0YVxyXG4gICAqL1xyXG4gIGFzeW5jIGdldFNldERhdGEoc2V0Q29kZTogc3RyaW5nKTogUHJvbWlzZTxTZXRDYXJkRGF0YVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEoKTtcclxuICAgICAgaWYgKCFtZXRhZGF0YSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsUHJpbnRpbmdzIG1ldGFkYXRhIG5vdCBmb3VuZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzZXRDaHVua3MgPSBtZXRhZGF0YS5jaHVua3MuZmlsdGVyKGNodW5rSWQgPT4gY2h1bmtJZC5zdGFydHNXaXRoKHNldENvZGUpKTtcclxuICAgICAgY29uc3QgY2FyZHM6IFNldENhcmREYXRhW10gPSBbXTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY2h1bmtJZCBvZiBzZXRDaHVua3MpIHtcclxuICAgICAgICBjb25zdCBjaHVuayA9IGF3YWl0IHRoaXMuZ2V0Q2h1bmsoY2h1bmtJZCk7XHJcbiAgICAgICAgaWYgKGNodW5rKSB7XHJcbiAgICAgICAgICBjb25zdCBkZWNvbXByZXNzZWQgPSBhd2FpdCB0aGlzLmRlY29tcHJlc3NEYXRhKGNodW5rLmNvbXByZXNzZWREYXRhKTtcclxuICAgICAgICAgIGNhcmRzLnB1c2goLi4uZGVjb21wcmVzc2VkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjYXJkcztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBnZXQgc2V0IGRhdGEgZm9yICR7c2V0Q29kZX06YCwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZWFyY2ggZm9yIGNhcmRzIGFjcm9zcyBhbGwgc2V0c1xyXG4gICAqL1xyXG4gIGFzeW5jIHNlYXJjaENhcmRzKHNlYXJjaFRlcm06IHN0cmluZywgbWF4UmVzdWx0cyA9IDUwKTogUHJvbWlzZTxTZXRDYXJkRGF0YVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEoKTtcclxuICAgICAgaWYgKCFtZXRhZGF0YSkgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0czogU2V0Q2FyZERhdGFbXSA9IFtdO1xyXG4gICAgICBjb25zdCBub3JtYWxpemVkU2VhcmNoID0gc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgLy8gU2VhcmNoIHRocm91Z2ggY2h1bmtzIHVudGlsIHdlIGhhdmUgZW5vdWdoIHJlc3VsdHNcclxuICAgICAgZm9yIChjb25zdCBjaHVua0lkIG9mIG1ldGFkYXRhLmNodW5rcykge1xyXG4gICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+PSBtYXhSZXN1bHRzKSBicmVhaztcclxuXHJcbiAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCB0aGlzLmdldENodW5rKGNodW5rSWQpO1xyXG4gICAgICAgIGlmICghY2h1bmspIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBjb25zdCBjYXJkcyA9IGF3YWl0IHRoaXMuZGVjb21wcmVzc0RhdGEoY2h1bmsuY29tcHJlc3NlZERhdGEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoY29uc3QgY2FyZCBvZiBjYXJkcykge1xyXG4gICAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID49IG1heFJlc3VsdHMpIGJyZWFrO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoY2FyZC5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobm9ybWFsaXplZFNlYXJjaCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNhcmQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2VhcmNoIGNhcmRzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZCBjYXJkIGJ5IFNjcnlmYWxsIElEXHJcbiAgICovXHJcbiAgYXN5bmMgZmluZENhcmRCeVNjcnlmYWxsSWQoc2NyeWZhbGxJZDogc3RyaW5nKTogUHJvbWlzZTxTZXRDYXJkRGF0YSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5nZXRNZXRhZGF0YSgpO1xyXG4gICAgICBpZiAoIW1ldGFkYXRhKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIC8vIFNlYXJjaCB0aHJvdWdoIGFsbCBjaHVua3NcclxuICAgICAgZm9yIChjb25zdCBjaHVua0lkIG9mIG1ldGFkYXRhLmNodW5rcykge1xyXG4gICAgICAgIGNvbnN0IGNodW5rID0gYXdhaXQgdGhpcy5nZXRDaHVuayhjaHVua0lkKTtcclxuICAgICAgICBpZiAoIWNodW5rKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgY29uc3QgY2FyZHMgPSBhd2FpdCB0aGlzLmRlY29tcHJlc3NEYXRhKGNodW5rLmNvbXByZXNzZWREYXRhKTtcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKGNvbnN0IGNhcmQgb2YgY2FyZHMpIHtcclxuICAgICAgICAgIGlmIChjYXJkLmlkZW50aWZpZXJzPy5zY3J5ZmFsbElkID09PSBzY3J5ZmFsbElkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYXJkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmluZCBjYXJkIGJ5IFNjcnlmYWxsIElEOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgc3RvcmFnZSBzdGF0aXN0aWNzXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0U3RvcmFnZVN0YXRzKCk6IFByb21pc2U8e1xyXG4gICAgdG90YWxTZXRzOiBudW1iZXI7XHJcbiAgICB0b3RhbENhcmRzOiBudW1iZXI7XHJcbiAgICB0b3RhbENodW5rczogbnVtYmVyO1xyXG4gICAgbGFzdFVwZGF0ZWQ6IHN0cmluZztcclxuICAgIHZlcnNpb246IHN0cmluZztcclxuICB9IHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKCk7XHJcbiAgICAgIGlmICghbWV0YWRhdGEpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3RhbFNldHM6IG1ldGFkYXRhLnRvdGFsU2V0cyxcclxuICAgICAgICB0b3RhbENhcmRzOiBtZXRhZGF0YS50b3RhbENhcmRzLFxyXG4gICAgICAgIHRvdGFsQ2h1bmtzOiBtZXRhZGF0YS5jaHVua3MubGVuZ3RoLFxyXG4gICAgICAgIGxhc3RVcGRhdGVkOiBtZXRhZGF0YS5sYXN0VXBkYXRlZCxcclxuICAgICAgICB2ZXJzaW9uOiBtZXRhZGF0YS52ZXJzaW9uLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBzdG9yYWdlIHN0YXRzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhciBhbGwgc3RvcmVkIGRhdGFcclxuICAgKi9cclxuICBhc3luYyBjbGVhckFsbERhdGEoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDbGVhciBJbmRleGVkREIgZGF0YVxyXG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEoKTtcclxuICAgICAgaWYgKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBjaHVua3NcclxuICAgICAgICBmb3IgKGNvbnN0IGNodW5rSWQgb2YgbWV0YWRhdGEuY2h1bmtzKSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUNodW5rKGNodW5rSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIG1ldGFkYXRhXHJcbiAgICAgIGF3YWl0IHRoaXMucmVtb3ZlTWV0YWRhdGEoKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEFsc28gY2xlYXIgYW55IG9sZCBsb2NhbFN0b3JhZ2UgZGF0YSBmcm9tIHByZXZpb3VzIHZlcnNpb25zXHJcbiAgICAgIHRoaXMuY2xlYXJMZWdhY3lMb2NhbFN0b3JhZ2VEYXRhKCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnQWxsIEFsbFByaW50aW5ncyBkYXRhIGNsZWFyZWQnKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjbGVhciBBbGxQcmludGluZ3MgZGF0YTonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYXIgbGVnYWN5IGxvY2FsU3RvcmFnZSBkYXRhIGZyb20gcHJldmlvdXMgdmVyc2lvbnNcclxuICAgKi9cclxuICBwcml2YXRlIGNsZWFyTGVnYWN5TG9jYWxTdG9yYWdlRGF0YSgpOiB2b2lkIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIENsZWFyIG9sZCBtZXRhZGF0YVxyXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYWxscHJpbnRpbmdzLW1ldGFkYXRhJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDbGVhciBvbGQgY2h1bmtzIChzY2FuIGZvciBjaHVuay0gcHJlZml4ZWQga2V5cylcclxuICAgICAgY29uc3Qga2V5c1RvUmVtb3ZlOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XHJcbiAgICAgICAgaWYgKGtleSAmJiBrZXkuc3RhcnRzV2l0aCgnY2h1bmstJykpIHtcclxuICAgICAgICAgIGtleXNUb1JlbW92ZS5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBrZXlzVG9SZW1vdmUuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgaWYgKGtleXNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYENsZWFyZWQgJHtrZXlzVG9SZW1vdmUubGVuZ3RofSBsZWdhY3kgbG9jYWxTdG9yYWdlIGNodW5rc2ApO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2xlYXIgbGVnYWN5IGxvY2FsU3RvcmFnZSBkYXRhOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGRhdGEgZXhpc3RzIGFuZCBpcyBmcmVzaFxyXG4gICAqL1xyXG4gIGFzeW5jIGlzRGF0YUF2YWlsYWJsZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5nZXRNZXRhZGF0YSgpO1xyXG4gICAgICBpZiAoIW1ldGFkYXRhKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBkYXRhIGlzIGxlc3MgdGhhbiA3IGRheXMgb2xkXHJcbiAgICAgIGNvbnN0IGRhdGFBZ2UgPSBEYXRlLm5vdygpIC0gbmV3IERhdGUobWV0YWRhdGEubGFzdFVwZGF0ZWQpLmdldFRpbWUoKTtcclxuICAgICAgY29uc3QgbWF4QWdlID0gNyAqIDI0ICogNjAgKiA2MCAqIDEwMDA7IC8vIDcgZGF5c1xyXG5cclxuICAgICAgcmV0dXJuIGRhdGFBZ2UgPCBtYXhBZ2U7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2hlY2sgZGF0YSBhdmFpbGFiaWxpdHk6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQcml2YXRlIGhlbHBlciBtZXRob2RzXHJcblxyXG4gIHByaXZhdGUgYXN5bmMgY29tcHJlc3NEYXRhKGRhdGE6IFNldENhcmREYXRhW10pOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU2ltcGxlIGNvbXByZXNzaW9uIHVzaW5nIEpTT04gc3RyaW5naWZ5IHdpdGggcmVkdWNlZCBwcmVjaXNpb25cclxuICAgICAgY29uc3QganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICBcclxuICAgICAgLy8gQmFzaWMgY29tcHJlc3Npb24gYnkgcmVtb3ZpbmcgdW5uZWNlc3Nhcnkgd2hpdGVzcGFjZSBhbmQgdXNpbmcgc2hvcnRlciBrZXlzXHJcbiAgICAgIGNvbnN0IGNvbXByZXNzZWQgPSBqc29uU3RyaW5nXHJcbiAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJycpXHJcbiAgICAgICAgLnJlcGxhY2UoL1widXVpZFwiOi9nLCAnXCJ1XCI6JylcclxuICAgICAgICAucmVwbGFjZSgvXCJuYW1lXCI6L2csICdcIm5cIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cInNldENvZGVcIjovZywgJ1wic1wiOicpXHJcbiAgICAgICAgLnJlcGxhY2UoL1wibnVtYmVyXCI6L2csICdcIiNcIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cInJhcml0eVwiOi9nLCAnXCJyXCI6JylcclxuICAgICAgICAucmVwbGFjZSgvXCJpZGVudGlmaWVyc1wiOi9nLCAnXCJpXCI6JylcclxuICAgICAgICAucmVwbGFjZSgvXCJzY3J5ZmFsbElkXCI6L2csICdcInNpXCI6JylcclxuICAgICAgICAucmVwbGFjZSgvXCJtdWx0aXZlcnNlSWRcIjovZywgJ1wibWlcIjonKTtcclxuXHJcbiAgICAgIC8vIFRyeSBkaWZmZXJlbnQgZW5jb2RpbmcgYXBwcm9hY2hlc1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIE1ldGhvZCAxOiBVc2UgVGV4dEVuY29kZXIgZm9yIHByb3BlciBVbmljb2RlIGhhbmRsaW5nXHJcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG4gICAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBlbmNvZGVyLmVuY29kZShjb21wcmVzc2VkKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDb252ZXJ0IHRvIGJhc2U2NCB1c2luZyBwcm9wZXIgYmluYXJ5IGhhbmRsaW5nXHJcbiAgICAgICAgbGV0IGJpbmFyeVN0cmluZyA9ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgYmluYXJ5U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWludDhBcnJheVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBidG9hKGJpbmFyeVN0cmluZyk7XHJcbiAgICAgIH0gY2F0Y2ggKGVuY29kaW5nRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1RleHRFbmNvZGVyIG1ldGhvZCBmYWlsZWQsIHRyeWluZyBmYWxsYmFjazonLCBlbmNvZGluZ0Vycm9yKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBNZXRob2QgMjogRmFsbGJhY2sgLSBlc2NhcGUgVW5pY29kZSBjaGFyYWN0ZXJzIGZpcnN0XHJcbiAgICAgICAgY29uc3QgZXNjYXBlZENvbXByZXNzZWQgPSBjb21wcmVzc2VkLnJlcGxhY2UoL1tcXHUwMDgwLVxcdUZGRkZdL2csIChtYXRjaCkgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuICdcXFxcdScgKyAoJzAwMDAnICsgbWF0Y2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnN1YnN0cigtNCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGJ0b2EoZXNjYXBlZENvbXByZXNzZWQpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY29tcHJlc3MgZGF0YSB3aXRoIGFsbCBtZXRob2RzOicsIGVycm9yKTtcclxuICAgICAgXHJcbiAgICAgIC8vIE1ldGhvZCAzOiBMYXN0IHJlc29ydCAtIHN0b3JlIHVuY29tcHJlc3NlZCBidXQgd2l0aCBrZXkgc2hvcnRlbmluZ1xyXG4gICAgICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbiAgICAgIGNvbnN0IHNob3J0ZW5lZCA9IGpzb25TdHJpbmdcclxuICAgICAgICAucmVwbGFjZSgvXCJ1dWlkXCI6L2csICdcInVcIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cIm5hbWVcIjovZywgJ1wiblwiOicpXHJcbiAgICAgICAgLnJlcGxhY2UoL1wic2V0Q29kZVwiOi9nLCAnXCJzXCI6JylcclxuICAgICAgICAucmVwbGFjZSgvXCJudW1iZXJcIjovZywgJ1wiI1wiOicpXHJcbiAgICAgICAgLnJlcGxhY2UoL1wicmFyaXR5XCI6L2csICdcInJcIjonKTtcclxuICAgICAgXHJcbiAgICAgIC8vIE1hcmsgYXMgdW5jb21wcmVzc2VkIHdpdGggYSBwcmVmaXhcclxuICAgICAgcmV0dXJuICdVTkNPTVBSRVNTRUQ6JyArIHNob3J0ZW5lZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZGVjb21wcmVzc0RhdGEoY29tcHJlc3NlZERhdGE6IHN0cmluZyk6IFByb21pc2U8U2V0Q2FyZERhdGFbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbGV0IGRlY29kZWQ6IHN0cmluZztcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGlmIGRhdGEgaXMgdW5jb21wcmVzc2VkIChmYWxsYmFjayBtZXRob2QpXHJcbiAgICAgIGlmIChjb21wcmVzc2VkRGF0YS5zdGFydHNXaXRoKCdVTkNPTVBSRVNTRUQ6JykpIHtcclxuICAgICAgICBkZWNvZGVkID0gY29tcHJlc3NlZERhdGEuc3Vic3RyaW5nKCdVTkNPTVBSRVNTRUQ6Jy5sZW5ndGgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRyeSBkaWZmZXJlbnQgZGVjb2RpbmcgYXBwcm9hY2hlc1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBNZXRob2QgMTogVXNlIFRleHREZWNvZGVyIGZvciBwcm9wZXIgVW5pY29kZSBoYW5kbGluZ1xyXG4gICAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihjb21wcmVzc2VkRGF0YSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyBiYWNrIHRvIFVpbnQ4QXJyYXlcclxuICAgICAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcclxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHVpbnQ4QXJyYXlbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVXNlIFRleHREZWNvZGVyIHRvIGhhbmRsZSBVbmljb2RlIGNoYXJhY3RlcnMgcHJvcGVybHlcclxuICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcclxuICAgICAgICAgIGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZSh1aW50OEFycmF5KTtcclxuICAgICAgICB9IGNhdGNoIChkZWNvZGluZ0Vycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RleHREZWNvZGVyIG1ldGhvZCBmYWlsZWQsIHRyeWluZyBmYWxsYmFjazonLCBkZWNvZGluZ0Vycm9yKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gTWV0aG9kIDI6IEZhbGxiYWNrIC0gc2ltcGxlIGF0b2IgYW5kIHVuZXNjYXBlIFVuaWNvZGVcclxuICAgICAgICAgIGRlY29kZWQgPSBhdG9iKGNvbXByZXNzZWREYXRhKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVW5lc2NhcGUgVW5pY29kZSBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICBkZWNvZGVkID0gZGVjb2RlZC5yZXBsYWNlKC9cXFxcdShbMC05YS1mQS1GXXs0fSkvZywgKG1hdGNoLCBoZXgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LCAxNikpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHBhbmQgdGhlIHNob3J0ZW5lZCBrZXlzIGJhY2sgdG8gb3JpZ2luYWxcclxuICAgICAgY29uc3QgZXhwYW5kZWQgPSBkZWNvZGVkXHJcbiAgICAgICAgLnJlcGxhY2UoL1widVwiOi9nLCAnXCJ1dWlkXCI6JylcclxuICAgICAgICAucmVwbGFjZSgvXCJuXCI6L2csICdcIm5hbWVcIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cInNcIjovZywgJ1wic2V0Q29kZVwiOicpXHJcbiAgICAgICAgLnJlcGxhY2UoL1wiI1wiOi9nLCAnXCJudW1iZXJcIjonKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cInJcIjovZywgJ1wicmFyaXR5XCI6JylcclxuICAgICAgICAucmVwbGFjZSgvXCJpXCI6L2csICdcImlkZW50aWZpZXJzXCI6JylcclxuICAgICAgICAucmVwbGFjZSgvXCJzaVwiOi9nLCAnXCJzY3J5ZmFsbElkXCI6JylcclxuICAgICAgICAucmVwbGFjZSgvXCJtaVwiOi9nLCAnXCJtdWx0aXZlcnNlSWRcIjonKTtcclxuXHJcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGV4cGFuZGVkKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWNvbXByZXNzIGRhdGEgd2l0aCBhbGwgbWV0aG9kczonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBzdG9yZUNodW5rc0luQmF0Y2hlcyhjaHVua3M6IENvbXByZXNzZWRDaHVua1tdKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBiYXRjaFNpemUgPSAxMDtcclxuICAgIFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpICs9IGJhdGNoU2l6ZSkge1xyXG4gICAgICBjb25zdCBiYXRjaCA9IGNodW5rcy5zbGljZShpLCBpICsgYmF0Y2hTaXplKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGJhdGNoUHJvbWlzZXMgPSBiYXRjaC5tYXAoY2h1bmsgPT4gdGhpcy5zdG9yZUNodW5rKGNodW5rKSk7XHJcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGJhdGNoUHJvbWlzZXMpO1xyXG4gICAgICBcclxuICAgICAgLy8gU21hbGwgZGVsYXkgdG8gYXZvaWQgb3ZlcndoZWxtaW5nIEluZGV4ZWREQlxyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFByb2dyZXNzIGxvZ2dpbmdcclxuICAgICAgaWYgKGkgJSAxMDAgPT09IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgU3RvcmVkICR7TWF0aC5taW4oaSArIGJhdGNoU2l6ZSwgY2h1bmtzLmxlbmd0aCl9IC8gJHtjaHVua3MubGVuZ3RofSBjaHVua3NgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBzdG9yZUNodW5rKGNodW5rOiBDb21wcmVzc2VkQ2h1bmspOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLm9wZW5JbmRleGVkREIoKTtcclxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFsnY2h1bmtzJ10sICdyZWFkd3JpdGUnKTtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdjaHVua3MnKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUucHV0KGNodW5rLCBjaHVuay5pZCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBzdG9yZSBjaHVuayAke2NodW5rLmlkfTpgLCBlcnJvcik7XHJcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldENodW5rKGNodW5rSWQ6IHN0cmluZyk6IFByb21pc2U8Q29tcHJlc3NlZENodW5rIHwgbnVsbD4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMub3BlbkluZGV4ZWREQigpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oWydjaHVua3MnXSwgJ3JlYWRvbmx5Jyk7XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnY2h1bmtzJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldChjaHVua0lkKTtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUocmVxdWVzdC5yZXN1bHQgfHwgbnVsbCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBnZXQgY2h1bmsgJHtjaHVua0lkfTpgLCBlcnJvcik7XHJcbiAgICAgICAgcmVzb2x2ZShudWxsKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHJlbW92ZUNodW5rKGNodW5rSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMub3BlbkluZGV4ZWREQigpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oWydjaHVua3MnXSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ2NodW5rcycpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5kZWxldGUoY2h1bmtJZCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byByZW1vdmUgY2h1bmsgJHtjaHVua0lkfTpgLCBlcnJvcik7XHJcbiAgICAgICAgcmVzb2x2ZSgpOyAvLyBEb24ndCBmYWlsIHRoZSBlbnRpcmUgb3BlcmF0aW9uIGZvciBjbGVhbnVwIGVycm9yc1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgc3RvcmVNZXRhZGF0YShtZXRhZGF0YTogQWxsUHJpbnRpbmdzTWV0YWRhdGEpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLm9wZW5JbmRleGVkREIoKTtcclxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFsnbWV0YWRhdGEnXSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ21ldGFkYXRhJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLnB1dChtZXRhZGF0YSwgJ2FsbHByaW50aW5ncy1tZXRhZGF0YScpO1xyXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc3RvcmUgbWV0YWRhdGE6JywgZXJyb3IpO1xyXG4gICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRNZXRhZGF0YSgpOiBQcm9taXNlPEFsbFByaW50aW5nc01ldGFkYXRhIHwgbnVsbD4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMub3BlbkluZGV4ZWREQigpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oWydtZXRhZGF0YSddLCAncmVhZG9ubHknKTtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdtZXRhZGF0YScpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXQoJ2FsbHByaW50aW5ncy1tZXRhZGF0YScpO1xyXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCB8fCBudWxsKTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBtZXRhZGF0YTonLCBlcnJvcik7XHJcbiAgICAgICAgcmVzb2x2ZShudWxsKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHJlbW92ZU1ldGFkYXRhKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMub3BlbkluZGV4ZWREQigpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oWydtZXRhZGF0YSddLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnbWV0YWRhdGEnKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZGVsZXRlKCdhbGxwcmludGluZ3MtbWV0YWRhdGEnKTtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlbW92ZSBtZXRhZGF0YTonLCBlcnJvcik7XHJcbiAgICAgICAgcmVzb2x2ZSgpOyAvLyBEb24ndCBmYWlsIGZvciBjbGVhbnVwIGVycm9yc1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIEluZGV4ZWREQiBoZWxwZXIgbWV0aG9kc1xyXG4gIHByaXZhdGUgZGJQcm9taXNlOiBQcm9taXNlPElEQkRhdGFiYXNlPiB8IG51bGwgPSBudWxsO1xyXG5cclxuICBwcml2YXRlIGFzeW5jIG9wZW5JbmRleGVkREIoKTogUHJvbWlzZTxJREJEYXRhYmFzZT4ge1xyXG4gICAgaWYgKHRoaXMuZGJQcm9taXNlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRiUHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRiUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKCdNVEdKU09OU3RvcmFnZScsIDEpO1xyXG5cclxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBvcGVuIEluZGV4ZWREQicpKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xyXG4gICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXN1bHQpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCBkYiA9IChldmVudC50YXJnZXQgYXMgSURCT3BlbkRCUmVxdWVzdCkucmVzdWx0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENyZWF0ZSBvYmplY3Qgc3RvcmVzXHJcbiAgICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCdjaHVua3MnKSkge1xyXG4gICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ2NodW5rcycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ21ldGFkYXRhJykpIHtcclxuICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdtZXRhZGF0YScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmRiUHJvbWlzZTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IGFsbFByaW50aW5nc1N0b3JhZ2UgPSBuZXcgQWxsUHJpbnRpbmdzU3RvcmFnZSgpO1xyXG5cclxuLy8gRXhwb3J0IHR5cGVzXHJcbmV4cG9ydCB0eXBlIHsgU2V0Q2FyZERhdGEsIEFsbFByaW50aW5nc01ldGFkYXRhIH07XHJcbiJdLCJuYW1lcyI6WyJBbGxQcmludGluZ3NTdG9yYWdlIiwic3RvcmVBbGxQcmludGluZ3MiLCJhbGxQcmludGluZ3NEYXRhIiwiY29uc29sZSIsImxvZyIsIm1ldGFkYXRhIiwidmVyc2lvbiIsIm1ldGEiLCJkYXRlIiwidG90YWxTZXRzIiwidG90YWxDYXJkcyIsImNodW5rcyIsImxhc3RVcGRhdGVkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic2V0Q29kZSIsInNldERhdGEiLCJPYmplY3QiLCJlbnRyaWVzIiwiZGF0YSIsImNhcmRzIiwibGVuZ3RoIiwiaSIsIkNIVU5LX1NJWkUiLCJjaHVua0NhcmRzIiwic2xpY2UiLCJjaHVua0lkIiwiTWF0aCIsImZsb29yIiwib3B0aW1pemVkQ2FyZHMiLCJtYXAiLCJjYXJkIiwidXVpZCIsIm5hbWUiLCJudW1iZXIiLCJyYXJpdHkiLCJpZGVudGlmaWVycyIsInNjcnlmYWxsSWQiLCJtdWx0aXZlcnNlSWQiLCJ1bmRlZmluZWQiLCJjb21wcmVzc2VkIiwiY29tcHJlc3NEYXRhIiwiY2h1bmsiLCJpZCIsImNvbXByZXNzZWREYXRhIiwidW5jb21wcmVzc2VkU2l6ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjYXJkQ291bnQiLCJwdXNoIiwic3RvcmVDaHVua3NJbkJhdGNoZXMiLCJzdG9yZU1ldGFkYXRhIiwiZXJyb3IiLCJjbGVhckFsbERhdGEiLCJjbGVhbnVwRXJyb3IiLCJnZXRTZXREYXRhIiwiZ2V0TWV0YWRhdGEiLCJFcnJvciIsInNldENodW5rcyIsImZpbHRlciIsInN0YXJ0c1dpdGgiLCJnZXRDaHVuayIsImRlY29tcHJlc3NlZCIsImRlY29tcHJlc3NEYXRhIiwic2VhcmNoQ2FyZHMiLCJzZWFyY2hUZXJtIiwibWF4UmVzdWx0cyIsInJlc3VsdHMiLCJub3JtYWxpemVkU2VhcmNoIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsImZpbmRDYXJkQnlTY3J5ZmFsbElkIiwiZ2V0U3RvcmFnZVN0YXRzIiwidG90YWxDaHVua3MiLCJyZW1vdmVDaHVuayIsInJlbW92ZU1ldGFkYXRhIiwiY2xlYXJMZWdhY3lMb2NhbFN0b3JhZ2VEYXRhIiwibG9jYWxTdG9yYWdlIiwicmVtb3ZlSXRlbSIsImtleXNUb1JlbW92ZSIsImtleSIsImZvckVhY2giLCJpc0RhdGFBdmFpbGFibGUiLCJkYXRhQWdlIiwibm93IiwiZ2V0VGltZSIsIm1heEFnZSIsImpzb25TdHJpbmciLCJyZXBsYWNlIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwidWludDhBcnJheSIsImVuY29kZSIsImJpbmFyeVN0cmluZyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImJ0b2EiLCJlbmNvZGluZ0Vycm9yIiwid2FybiIsImVzY2FwZWRDb21wcmVzc2VkIiwibWF0Y2giLCJjaGFyQ29kZUF0IiwidG9TdHJpbmciLCJzdWJzdHIiLCJzaG9ydGVuZWQiLCJkZWNvZGVkIiwic3Vic3RyaW5nIiwiYXRvYiIsIlVpbnQ4QXJyYXkiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJkZWNvZGluZ0Vycm9yIiwiaGV4IiwicGFyc2VJbnQiLCJleHBhbmRlZCIsInBhcnNlIiwiYmF0Y2hTaXplIiwiYmF0Y2giLCJiYXRjaFByb21pc2VzIiwic3RvcmVDaHVuayIsIlByb21pc2UiLCJhbGwiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIm1pbiIsInJlamVjdCIsImRiIiwib3BlbkluZGV4ZWREQiIsInRyYW5zYWN0aW9uIiwic3RvcmUiLCJvYmplY3RTdG9yZSIsInJlcXVlc3QiLCJwdXQiLCJvbnN1Y2Nlc3MiLCJvbmVycm9yIiwiZ2V0IiwicmVzdWx0IiwiZGVsZXRlIiwiZGJQcm9taXNlIiwiaW5kZXhlZERCIiwib3BlbiIsIm9udXBncmFkZW5lZWRlZCIsImV2ZW50IiwidGFyZ2V0Iiwib2JqZWN0U3RvcmVOYW1lcyIsImNvbnRhaW5zIiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJNRVRBREFUQV9LRVkiLCJDSFVOS19QUkVGSVgiLCJhbGxQcmludGluZ3NTdG9yYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/utils/allPrintingsStorage.ts\n"));

/***/ })

}]);